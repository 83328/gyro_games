<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maze Runner</title>
<style>
  html,body{height:100%;}
  body{font-family:Arial,Helvetica,sans-serif;background:#111;color:#eee;display:flex;flex-direction:column;align-items:center;padding:20px 20px 36px 20px;margin:0;box-sizing:border-box;overflow:hidden}
  canvas{background:#222;border:2px solid #333;display:block}
  #info{margin:8px}
  #scores{margin:8px}
</style>
</head>
<body>
  <h1>Maze Runner</h1>
  <div id="info">Connecting...</div>
  <div id="scores">
    Players:
    <select id="playerCount" style="margin:0 8px">
      <option value="2">2 players</option>
      <option value="3">3 players</option>
      <option value="4">4 players</option>
      <option value="5">5 players</option>
      <option value="6">6 players</option>
      <option value="7">7 players</option>
      <option value="8">8 players</option>
    </select>
    Blue: <span id="sBlue">0</span> — Red: <span id="sRed">0</span>
      <span id="yellowScoreContainer" style="display:none"> — Yellow: <span id="sYellow">0</span></span>
      <span id="greenScoreContainer" style="display:none"> — Green: <span id="sGreen">0</span></span>
      <span id="orangeScoreContainer" style="display:none"> — Orange: <span id="sOrange">0</span></span>
      <span id="purpleScoreContainer" style="display:none"> — Purple: <span id="sPurple">0</span></span>
      <span id="cyanScoreContainer" style="display:none"> — Cyan: <span id="sCyan">0</span></span>
      <span id="magentaScoreContainer" style="display:none"> — Magenta: <span id="sMagenta">0</span></span>
  </div>
  <canvas id="c" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellowEl = document.getElementById('sYellow');
const sGreenEl = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

// calibration and UI controls
const ctrlContainer = document.createElement('div');
ctrlContainer.style.margin = '8px';
ctrlContainer.innerHTML = `
  <label>Calibration: <button id="calibBtn">Calibrate</button></label>
`;
document.body.insertBefore(ctrlContainer, canvas.nextSibling);
const calibBtn = document.getElementById('calibBtn');
// sensitivity and deadzone are now fixed constants (no sliders)
const DEFAULT_SENS_X = 1.0;
const DEFAULT_SENS_Y = 1.0;
const DEFAULT_DEADZONE = 1.0;
// forward/back tilt mapping: currently non-inverted (tilting device forward increases canvas Y)

let calibration = {beta:0, gamma:0, has:true};
let useOrientation = true; // prefer orientation angles when present
let orientationAvailable = false;

// removed slider listeners: using default constants
calibBtn.addEventListener('click', ()=>{
  // capture current orientation as neutral
  if(lastDeviceOrientation){
    calibration.beta = lastDeviceOrientation.beta || 0;
    calibration.gamma = lastDeviceOrientation.gamma || 0;
    calibration.has = true;
    try{ localStorage.setItem('gyro_maze_calib', JSON.stringify(calibration)); }catch(e){}
    appendLog('Calibrated');
  } else {
    appendLog('No orientation available to calibrate');
  }
});
// reset button removed — calibration can be overwritten by re-calibrating

// Maze grid
const COLS = 15, ROWS = 15;
let cell = {w: 0, h: 0};
let MAX_SPEED = 0;

function resizeCanvasToDisplay(){
  // compute available width/height by subtracting UI elements' heights
  const padW = 24;
  const h1h = (document.querySelector('h1') ? document.querySelector('h1').getBoundingClientRect().height : 40);
  const infoH = (document.getElementById('info') ? document.getElementById('info').getBoundingClientRect().height : 0);
  const scoresH = (document.getElementById('scores') ? document.getElementById('scores').getBoundingClientRect().height : 0);
  const ctrlH = (typeof ctrlContainer !== 'undefined' && ctrlContainer ? ctrlContainer.getBoundingClientRect().height : 0);
  const reservedH = h1h + infoH + scoresH + ctrlH + 120; // extra margin to avoid clipping bottom controls
  const availW = Math.max(400, window.innerWidth - padW);
  const availH = Math.max(300, window.innerHeight - reservedH);
  canvas.width = Math.min(availW, 1400);
  canvas.height = Math.min(availH, 1200);
  cell.w = canvas.width / COLS;
  cell.h = canvas.height / ROWS;
  MAX_SPEED = Math.min(cell.w, cell.h) * 6;
  // update player pixel positions from grid coords if players exist
  if(typeof players !== 'undefined' && players){
    for(const k of Object.keys(players)){
      const p = players[k];
      if(p && typeof p.x === 'number' && typeof p.y === 'number'){
        p.px = (p.x + 0.5) * cell.w;
        p.py = (p.y + 0.5) * cell.h;
      }
    }
  }
}
window.addEventListener('resize', resizeCanvasToDisplay);
let maze = [];

// Players positions (grid coords)
let players = {
  blue: {x:0,y:ROWS-1, px:0, py:0, vx:0, vy:0},
  red:  {x:COLS-1,y:0, px:0, py:0, vx:0, vy:0}
};
let scores = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};
// optional players (created when playerCount increases)
players.yellow = {x: Math.floor(COLS/2), y: ROWS-1, px:0, py:0, vx:0, vy:0};
players.green  = {x: Math.floor(COLS/2), y: 0, px:0, py:0, vx:0, vy:0};
players.orange = {x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2), px:0, py:0, vx:0, vy:0};
players.purple = {x: Math.floor(COLS/2)+1, y: Math.floor(ROWS/2), px:0, py:0, vx:0, vy:0};
players.cyan = {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)-1, px:0, py:0, vx:0, vy:0};
players.magenta = {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)+1, px:0, py:0, vx:0, vy:0};

const playerCountEl = document.createElement('select');
// we'll use the DOM select already added in HTML; wire it below
let activeRoles = ['blue','red'];

// store last orientation received from WS messages
let lastDeviceOrientation = null;
// rotationRate integration state per role with timestamp
const rotState = {};

// debug overlay
const debugEl = document.createElement('div');
debugEl.style.position = 'fixed';
debugEl.style.right = '8px';
debugEl.style.top = '8px';
debugEl.style.background = 'rgba(0,0,0,0.5)';
debugEl.style.color = '#fff';
debugEl.style.padding = '6px';
debugEl.style.fontSize = '12px';
debugEl.style.zIndex = 9999;
document.body.appendChild(debugEl);

// try load calibration from localStorage
try{ const stored = localStorage.getItem('gyro_maze_calib'); if(stored){ calibration = JSON.parse(stored); appendLog('Loaded calibration'); } }catch(e){}

function initMaze(){
  // simple randomized maze generator (depth-first)
  maze = Array(ROWS).fill(0).map(()=>Array(COLS).fill(1));
  const stack = [];
  function carve(x,y){
    maze[y][x] = 0;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs){
      const nx = x + dx*2, ny = y + dy*2;
      if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && maze[ny][nx]===1){
        maze[y+dy][x+dx]=0;
        carve(nx,ny);
      }
    }
  }
  carve(0, ROWS-1);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw maze
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(maze[r][c]===1){
        ctx.fillStyle='#333';
        ctx.fillRect(c*cell.w, r*cell.h, cell.w, cell.h);
      }
    }
  }
  // draw goal squares (corners and additional for optional players)
  // Blue goal: top-right
  ctx.fillStyle='#0033aa'; ctx.fillRect((COLS-1)*cell.w,0,cell.w,cell.h);
  // Red goal: bottom-left
  ctx.fillStyle='#aa0000'; ctx.fillRect(0,(ROWS-1)*cell.h,cell.w,cell.h);
  // Yellow goal: top-left (opposite of yellow start at bottom-right)
  if(activeRoles.includes('yellow')){ ctx.fillStyle='#ffd86b'; ctx.fillRect(0, 0, cell.w, cell.h); }
  // Green goal: bottom-right (opposite of green start at top-left)
  if(activeRoles.includes('green')){ ctx.fillStyle='#8fe58f'; ctx.fillRect((COLS-1)*cell.w, (ROWS-1)*cell.h, cell.w, cell.h); }
  // Orange/Purple/Cyan/Magenta use mid-edges or center targets when present
  if(activeRoles.includes('orange')){ ctx.fillStyle='#ffae42'; ctx.fillRect(Math.floor(COLS/2)*cell.w, 0, cell.w, cell.h); }
  if(activeRoles.includes('purple')){ ctx.fillStyle='#b388ff'; ctx.fillRect(Math.floor(COLS/2)*cell.w, (ROWS-1)*cell.h, cell.w, cell.h); }
  if(activeRoles.includes('cyan')){ ctx.fillStyle='#4deeea'; ctx.fillRect(0, Math.floor(ROWS/2)*cell.h, cell.w, cell.h); }
  if(activeRoles.includes('magenta')){ ctx.fillStyle='#ff6bd6'; ctx.fillRect((COLS-1)*cell.w, Math.floor(ROWS/2)*cell.h, cell.w, cell.h); }

  // draw players as circles at pixel positions
  ctx.fillStyle='#4ea1ff';
  ctx.beginPath(); ctx.arc(players.blue.px, players.blue.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#ff6b6b';
  ctx.beginPath(); ctx.arc(players.red.px, players.red.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill();
  // optional players
  if(activeRoles.includes('yellow')){ ctx.fillStyle='#ffd86b'; ctx.beginPath(); ctx.arc(players.yellow.px, players.yellow.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill(); }
  if(activeRoles.includes('green')){ ctx.fillStyle='#8fe58f'; ctx.beginPath(); ctx.arc(players.green.px, players.green.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill(); }
  if(activeRoles.includes('orange')){ ctx.fillStyle='#ffae42'; ctx.beginPath(); ctx.arc(players.orange.px, players.orange.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill(); }
  if(activeRoles.includes('purple')){ ctx.fillStyle='#b388ff'; ctx.beginPath(); ctx.arc(players.purple.px, players.purple.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill(); }
  if(activeRoles.includes('cyan')){ ctx.fillStyle='#4deeea'; ctx.beginPath(); ctx.arc(players.cyan.px, players.cyan.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill(); }
  if(activeRoles.includes('magenta')){ ctx.fillStyle='#ff6bd6'; ctx.beginPath(); ctx.arc(players.magenta.px, players.magenta.py, Math.min(cell.w,cell.h)/3, 0, Math.PI*2); ctx.fill(); }
}

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

// Continuous movement: map beta/gamma to target velocities and integrate per-frame
const V_SMOOTH = 0.15; // velocity smoothing

function handleTilt(role, beta, gamma){
  const p = players[role];
  // more intuitive mapping:
  // prefer orientation angles if present. beta: front/back tilt, gamma: left/right tilt.
  // apply calibration, deadzone, sensitivity and non-linear scaling for control.
  const sensX = DEFAULT_SENS_X;
  const sensY = DEFAULT_SENS_Y;
  const dead = DEFAULT_DEADZONE;
  let b = beta, g = gamma;
  if(calibration.has){ b = b - calibration.beta; g = g - calibration.gamma; }
  // forward/back mapping: invert beta so up/down are swapped
  b = -b;
  // apply deadzone
  function applyDeadzone(v){ return Math.abs(v) < dead ? 0 : (v > 0 ? v - dead : v + dead); }
  b = applyDeadzone(b); g = applyDeadzone(g);
  // normalize and apply sensitivity
  // use 35deg as comfortable full-tilt reference
  const REF = 35;
  // per-axis sensitivity and use tanh for smooth limiting
  const rawX = Math.max(-1, Math.min(1, (g / REF) * sensX));
  const rawY = Math.max(-1, Math.min(1, (b / REF) * sensY));
  const tanh = (x) => Math.tanh(x * 1.2); // slight gain before tanh
  const nx = tanh(rawX);
  const ny = tanh(rawY);
  const vxTarget = nx * MAX_SPEED;
  const vyTarget = ny * MAX_SPEED;
  p.vx = p.vx * (1 - V_SMOOTH) + vxTarget * V_SMOOTH;
  p.vy = p.vy * (1 - V_SMOOTH) + vyTarget * V_SMOOTH;
}

// circle-rect collision test
function circleRectCollide(cx,cy,r, rx,ry,rw,rh){
  const nearestX = Math.max(rx, Math.min(cx, rx+rw));
  const nearestY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - nearestX; const dy = cy - nearestY;
  return (dx*dx + dy*dy) < (r*r);
}

function checkGoal(role){
  const p = players[role];
  const cx = Math.floor(p.px / cell.w), cy = Math.floor(p.py / cell.h);
  if(role==='blue' && cx===COLS-1 && cy===0){ scores.blue++; sBlue.textContent = scores.blue; appendLog('Blue scored!'); resetRound(); }
  if(role==='red' && cx===0 && cy===ROWS-1){ scores.red++; sRed.textContent = scores.red; appendLog('Red scored!'); resetRound(); }
  if(role==='yellow' && activeRoles.includes('yellow') && cx===0 && cy===0){ scores.yellow++; sYellowEl.textContent = scores.yellow; appendLog('Yellow scored!'); resetRound(); }
  if(role==='green' && activeRoles.includes('green') && cx===COLS-1 && cy===ROWS-1){ scores.green++; sGreenEl.textContent = scores.green; appendLog('Green scored!'); resetRound(); }
  if(role==='orange' && activeRoles.includes('orange') && cx===Math.floor(COLS/2) && cy===0){ scores.orange++; sOrange.textContent = scores.orange; appendLog('Orange scored!'); resetRound(); }
  if(role==='purple' && activeRoles.includes('purple') && cx===Math.floor(COLS/2) && cy===ROWS-1){ scores.purple++; sPurple.textContent = scores.purple; appendLog('Purple scored!'); resetRound(); }
  if(role==='cyan' && activeRoles.includes('cyan') && cx===0 && cy===Math.floor(ROWS/2)){ scores.cyan++; sCyan.textContent = scores.cyan; appendLog('Cyan scored!'); resetRound(); }
  if(role==='magenta' && activeRoles.includes('magenta') && cx===COLS-1 && cy===Math.floor(ROWS/2)){ scores.magenta++; sMagenta.textContent = scores.magenta; appendLog('Magenta scored!'); resetRound(); }
}

function appendLog(msg){
  info.textContent = msg;
}

function resetRound(){
  initMaze();
  // place players at cell centers
  // corners: blue bottom-left, red top-right, yellow bottom-right, green top-left
  players.blue = {x:0,y:ROWS-1, px: (0+0.5)*cell.w, py: (ROWS-1+0.5)*cell.h, vx:0, vy:0};
  players.red  = {x:COLS-1,y:0, px: (COLS-1+0.5)*cell.w, py: (0+0.5)*cell.h, vx:0, vy:0};
  if(activeRoles.includes('yellow')){ players.yellow = {x:COLS-1,y:ROWS-1, px: (COLS-1+0.5)*cell.w, py: (ROWS-1+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('green')){ players.green = {x:0,y:0, px: (0+0.5)*cell.w, py: (0+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('orange')){ players.orange = {x:Math.floor(COLS/2), y:ROWS-1, px: (Math.floor(COLS/2)+0.5)*cell.w, py: ((ROWS-1)+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('purple')){ players.purple = {x:Math.floor(COLS/2), y:0, px: (Math.floor(COLS/2)+0.5)*cell.w, py: (0+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('cyan')){ players.cyan = {x:COLS-1, y:Math.floor(ROWS/2), px: ((COLS-1)+0.5)*cell.w, py: (Math.floor(ROWS/2)+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('magenta')){ players.magenta = {x:0, y:Math.floor(ROWS/2), px: (0+0.5)*cell.w, py: (Math.floor(ROWS/2)+0.5)*cell.h, vx:0, vy:0}; }
  draw();
}

// WebSocket hookup: reuse /api/token to get backend location
let ws=null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  const wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{ info.textContent='Connected'; };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if(!d || d.role==null) return;
      // map short role codes to full names (supports o/p/c/m)
      if(typeof d.role === 'string' && d.role.length===1){
        d.role = (
          d.role === 'b' ? 'blue' :
          d.role === 'r' ? 'red' :
          d.role === 'y' ? 'yellow' :
          d.role === 'g' ? 'green' :
          d.role === 'o' ? 'orange' :
          d.role === 'p' ? 'purple' :
          d.role === 'c' ? 'cyan' :
          d.role === 'm' ? 'magenta' :
          d.role
        );
      }
        // if orientation angles are provided, prefer them (more stable for tilt)
        if(!activeRoles.includes(d.role)) return; // ignore inputs for inactive players
        // ensure the players object has an entry for this role so handleTilt can operate
        if(!players[d.role]){
          // place sensible default grid starts (pixel positions will be updated by resize/reset as needed)
          if(d.role === 'orange'){
            // orange starts at bottom-middle (opposite its goal at top-middle)
            players.orange = { x: Math.floor(COLS/2), y: ROWS-1, px: (Math.floor(COLS/2)+0.5)*cell.w, py: ((ROWS-1)+0.5)*cell.h, vx:0, vy:0 };
          } else if(d.role === 'purple'){
            // purple starts at top-middle (opposite its goal at bottom-middle)
            players.purple = { x: Math.floor(COLS/2), y: 0, px: (Math.floor(COLS/2)+0.5)*cell.w, py: (0+0.5)*cell.h, vx:0, vy:0 };
          } else if(d.role === 'cyan'){
            // cyan starts at right-middle (opposite its goal at left-middle)
            players.cyan = { x: COLS-1, y: Math.floor(ROWS/2), px: ((COLS-1)+0.5)*cell.w, py: (Math.floor(ROWS/2)+0.5)*cell.h, vx:0, vy:0 };
          } else if(d.role === 'magenta'){
            // magenta starts at left-middle (opposite its goal at right-middle)
            players.magenta = { x: 0, y: Math.floor(ROWS/2), px: (0+0.5)*cell.w, py: (Math.floor(ROWS/2)+0.5)*cell.h, vx:0, vy:0 };
          } else {
            const cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
            players[d.role] = { x: cx, y: cy, px: (cx+0.5)*cell.w, py: (cy+0.5)*cell.h, vx:0, vy:0 };
          }
        }
        if(d.orientBeta!==undefined && d.orientGamma!==undefined && d.orientBeta!==null){
          orientationAvailable = true;
          lastDeviceOrientation = { beta: d.orientBeta, gamma: d.orientGamma, alpha: d.orientAlpha };
          // update rotState timestamp to avoid spurious rotationRate integration
          if(!rotState[d.role]) rotState[d.role] = {b:0,g:0,ts:Date.now()};
          rotState[d.role].ts = Date.now();
          handleTilt(d.role, d.orientBeta, d.orientGamma);
        } else if(d.beta!==undefined && d.gamma!==undefined){
          // fallback to gyroscope rotation rates — integrate roughly into tilt-like signal
          // integrate using timestamp deltas for better stability
          const now = Date.now();
          if(!rotState[d.role]) rotState[d.role] = {b:0,g:0,ts:now};
          const state = rotState[d.role];
          const dt = Math.min(0.1, (now - state.ts)/1000) || 0.02; // seconds
          state.ts = now;
          // d.beta/d.gamma are rotation rates (deg/s) — integrate to approximate tilt
          state.b += (d.beta || 0) * dt;
          state.g += (d.gamma || 0) * dt;
          // decay to avoid unbounded drift
          state.b *= 0.995; state.g *= 0.995;
          // expose an estimated orientation for debug
          lastDeviceOrientation = { beta: state.b, gamma: state.g };
          handleTilt(d.role, state.b, state.g);
        }
    }catch(e){}
  };
  ws.onclose = ()=>{ info.textContent='Disconnected'; setTimeout(()=>location.reload(),2000); };
}).catch(e=>{ info.textContent='No backend /api/token'; });

// init
initMaze();
// set canvas/cell sizes to fill available space and initialize player pixel positions
resizeCanvasToDisplay();
players.blue.px = (0+0.5)*cell.w; players.blue.py = (ROWS-1+0.5)*cell.h;
players.red.px = (COLS-1+0.5)*cell.w; players.red.py = (0+0.5)*cell.h;

// player count selector handling
const playerCount = document.getElementById('playerCount');
const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const orangeScoreContainer = document.getElementById('orangeScoreContainer');
const purpleScoreContainer = document.getElementById('purpleScoreContainer');
const cyanScoreContainer = document.getElementById('cyanScoreContainer');
const magentaScoreContainer = document.getElementById('magentaScoreContainer');
function updateActiveRoles(){
  const n = parseInt(playerCount.value, 10) || 2;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, Math.max(2, Math.min(8, n)));
  yellowScoreContainer.style.display = (n >= 3) ? '' : 'none';
  greenScoreContainer.style.display = (n >= 4) ? '' : 'none';
  orangeScoreContainer.style.display = (n >= 5) ? '' : 'none';
  purpleScoreContainer.style.display = (n >= 6) ? '' : 'none';
  cyanScoreContainer.style.display = (n >= 7) ? '' : 'none';
  magentaScoreContainer.style.display = (n >= 8) ? '' : 'none';
  // reset positions for new roles
  resetRound();
}
playerCount.addEventListener('change', updateActiveRoles);
// apply initial value
updateActiveRoles();

let lastTs = performance.now();
function frame(now){
  const dt = Math.min(40, now - lastTs) / 1000; // seconds, clamp
  lastTs = now;
  // update debug overlay
  debugEl.textContent = `orient:${orientationAvailable? 'yes':'no'}\nlast β:${(lastDeviceOrientation && lastDeviceOrientation.beta)? lastDeviceOrientation.beta.toFixed(2): 'n/a'} γ:${(lastDeviceOrientation && lastDeviceOrientation.gamma)? lastDeviceOrientation.gamma.toFixed(2): 'n/a'}\ncalib β:${(calibration && calibration.beta)?calibration.beta.toFixed(2):'0'} γ:${(calibration && calibration.gamma)?calibration.gamma.toFixed(2):'0'}`;
  // integrate velocities -> positions
  for(const role of activeRoles){
    const p = players[role];
    // predict new position and resolve collisions per-axis so the player can slide along walls
    let nx = p.px + p.vx * dt;
    let ny = p.py;
    // collision: test X movement first
    const r = Math.min(cell.w,cell.h)/3;
    let collidedX = false;
    const minC_x = Math.max(0, Math.floor((nx - r)/cell.w));
    const maxC_x = Math.min(COLS-1, Math.floor((nx + r)/cell.w));
    const minR_x = Math.max(0, Math.floor((ny - r)/cell.h));
    const maxR_x = Math.min(ROWS-1, Math.floor((ny + r)/cell.h));
    for(let rr=minR_x; rr<=maxR_x; rr++){
      for(let cc=minC_x; cc<=maxC_x; cc++){
        if(maze[rr][cc]===1){
          if(circleRectCollide(nx, ny, r, cc*cell.w, rr*cell.h, cell.w, cell.h)){
            collidedX = true;
            break;
          }
        }
      }
      if(collidedX) break;
    }
    if(collidedX){
      // block X movement (slide along wall) and zero X velocity component
      nx = p.px;
      p.vx = 0;
    }

    // now test Y movement at potentially updated X
    ny = p.py + p.vy * dt;
    let collidedY = false;
    const minC_y = Math.max(0, Math.floor((nx - r)/cell.w));
    const maxC_y = Math.min(COLS-1, Math.floor((nx + r)/cell.w));
    const minR_y = Math.max(0, Math.floor((ny - r)/cell.h));
    const maxR_y = Math.min(ROWS-1, Math.floor((ny + r)/cell.h));
    for(let rr=minR_y; rr<=maxR_y; rr++){
      for(let cc=minC_y; cc<=maxC_y; cc++){
        if(maze[rr][cc]===1){
          if(circleRectCollide(nx, ny, r, cc*cell.w, rr*cell.h, cell.w, cell.h)){
            collidedY = true;
            break;
          }
        }
      }
      if(collidedY) break;
    }
    if(collidedY){
      // block Y movement and zero Y velocity component
      ny = p.py;
      p.vy = 0;
    }

    // apply resolved positions
    p.px = nx;
    p.py = ny;
    // apply friction so player gradually stops when no tilt
    const FRICTION = 0.92; // per-frame damping (0..1)
    p.vx *= Math.pow(FRICTION, dt*60);
    p.vy *= Math.pow(FRICTION, dt*60);
    // ensure players stay within canvas bounds (considering radius)
    const margin = r + 1;
    p.px = clamp(p.px, margin, canvas.width - margin);
    p.py = clamp(p.py, margin, canvas.height - margin);
    checkGoal(role);
  }
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>