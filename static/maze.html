<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Maze Runner</title>
<style>
  html,body{height:100%;margin:0;padding:0;overflow:hidden}
  body{font-family:'Segoe UI',Arial,Helvetica,sans-serif;background:#000;color:#fff;display:flex;flex-direction:column;height:100vh;margin:0;box-sizing:border-box;overflow:hidden}
  canvas{display:block;width:100%;height:100%;background:radial-gradient(ellipse at center, #1a0a2e 0%, #0f051d 50%, #000000 100%);position:absolute;top:0;left:0}
  h1{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:999;margin:0;font-size:32px;font-weight:700;text-shadow:0 4px 12px rgba(0,0,0,0.8);display:none}
  #scores{position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:10001;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4);display:none;align-items:center;gap:10px;flex-wrap:wrap}
  #scores span{font-weight:600;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  #calibBtn{position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:1000;background:rgba(0,0,0,0.6);padding:10px 18px;border-radius:12px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.2);color:#fff;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  #calibBtn:hover{background:rgba(255,255,255,0.25);transform:translateX(-50%) translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
</style>
</head>
<body>
  <h1>Maze Runner</h1>
  <div id="scores">
    <span>Blue: <span id="sBlue">0</span></span> — <span>Red: <span id="sRed">0</span></span>
      <span id="yellowScoreContainer" style="display:none"> — Yellow: <span id="sYellow">0</span></span>
      <span id="greenScoreContainer" style="display:none"> — Green: <span id="sGreen">0</span></span>
      <span id="orangeScoreContainer" style="display:none"> — Orange: <span id="sOrange">0</span></span>
      <span id="purpleScoreContainer" style="display:none"> — Purple: <span id="sPurple">0</span></span>
      <span id="cyanScoreContainer" style="display:none"> — Cyan: <span id="sCyan">0</span></span>
      <span id="magentaScoreContainer" style="display:none"> — Magenta: <span id="sMagenta">0</span></span>
  </div>
  <button id="calibBtn">Calibrate</button>
  <canvas id="c" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
// note: #info element removed from DOM to avoid duplicate status; appendLog will query it if present
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellowEl = document.getElementById('sYellow');
const sGreenEl = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

// calibration button is now inline in scores
const calibBtn = document.getElementById('calibBtn');
// sensitivity and deadzone are now fixed constants (no sliders)
const DEFAULT_SENS_X = 1.0;
const DEFAULT_SENS_Y = 1.0;
const DEFAULT_DEADZONE = 1.0;
// forward/back tilt mapping: currently non-inverted (tilting device forward increases canvas Y)

let calibration = {beta:0, gamma:0, has:true};
let useOrientation = true; // prefer orientation angles when present
let orientationAvailable = false;

// removed slider listeners: using default constants
calibBtn.addEventListener('click', ()=>{
  // capture current orientation as neutral
  if(lastDeviceOrientation){
    calibration.beta = lastDeviceOrientation.beta || 0;
    calibration.gamma = lastDeviceOrientation.gamma || 0;
    calibration.has = true;
    try{ localStorage.setItem('gyro_maze_calib', JSON.stringify(calibration)); }catch(e){}
    appendLog('Calibrated');
  } else {
    appendLog('No orientation available to calibrate');
  }
});
// reset button removed — calibration can be overwritten by re-calibrating

// Maze grid
const COLS = 15, ROWS = 15;
let cell = {w: 0, h: 0};
// multiplier to scale how fast dots move (1 = default). Change this value in code to tune speed.
const SPEED_MULTIPLIER = 2; // <- set desired multiplier here
let MAX_SPEED = 0;

function resizeCanvasToDisplay(){
  // fullscreen canvas
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cell.w = canvas.width / COLS;
  cell.h = canvas.height / ROWS;
  MAX_SPEED = Math.min(cell.w, cell.h) * 6 * SPEED_MULTIPLIER;
  // update player pixel positions from grid coords if players exist
  if(typeof players !== 'undefined' && players){
    for(const k of Object.keys(players)){
      const p = players[k];
      if(p && typeof p.x === 'number' && typeof p.y === 'number'){
        p.px = (p.x + 0.5) * cell.w;
        p.py = (p.y + 0.5) * cell.h;
      }
    }
  }
}
window.addEventListener('resize', resizeCanvasToDisplay);
let maze = [];

// Players positions (grid coords)
let players = {
  blue: {x:0,y:ROWS-1, px:0, py:0, vx:0, vy:0},
  red:  {x:COLS-1,y:0, px:0, py:0, vx:0, vy:0}
};
let scores = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};
// optional players (created when playerCount increases)
players.yellow = {x: Math.floor(COLS/2), y: ROWS-1, px:0, py:0, vx:0, vy:0};
players.green  = {x: Math.floor(COLS/2), y: 0, px:0, py:0, vx:0, vy:0};
players.orange = {x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2), px:0, py:0, vx:0, vy:0};
players.purple = {x: Math.floor(COLS/2)+1, y: Math.floor(ROWS/2), px:0, py:0, vx:0, vy:0};
players.cyan = {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)-1, px:0, py:0, vx:0, vy:0};
players.magenta = {x: Math.floor(COLS/2), y: Math.floor(ROWS/2)+1, px:0, py:0, vx:0, vy:0};

// Prevent multiple score triggers while a win overlay is showing
let roundPending = false;

// color palette for overlay (match player colors)
const ROLE_COLORS = {
  blue: '#4ea1ff', red: '#ff6b6b', yellow: '#ffd86b', green: '#8fe58f',
  orange: '#ffae42', purple: '#b388ff', cyan: '#4deeea', magenta: '#ff6bd6'
};

// create a full-screen overlay element to show the winner between rounds
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 9998;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '48px';
winOverlay.style.fontWeight = '700';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);

function showWinOverlay(role){
  if(roundPending) return;
  roundPending = true;
  const color = ROLE_COLORS[role] || '#000';
  winOverlay.style.background = color;
  // ensure readable text: use dark text for light backgrounds and white for dark
  const hex = color.replace('#','');
  const r = parseInt(hex.substring(0,2),16), g = parseInt(hex.substring(2,4),16), b = parseInt(hex.substring(4,6),16);
  const lum = 0.2126*r + 0.7152*g + 0.0722*b;
  winOverlay.style.color = (lum > 170) ? '#001' : '#fff';
  winOverlay.textContent = `${role.charAt(0).toUpperCase() + role.slice(1)} scored!`;
  winOverlay.style.display = 'flex';
  // Show scores HUD on splash
  const scoresDiv = document.getElementById('scores');
  if(scoresDiv) scoresDiv.style.display = 'flex';
  // hide after a short delay and start next round
  setTimeout(()=>{
    winOverlay.style.display = 'none';
    if(scoresDiv) scoresDiv.style.display = 'none';
    roundPending = false;
    resetRound();
  }, 2200);
}

const playerCountEl = document.createElement('select');
// we'll use the DOM select already added in HTML; wire it below
let activeRoles = ['blue','red'];

// store last orientation received from WS messages
let lastDeviceOrientation = null;
// rotationRate integration state per role with timestamp
const rotState = {};

// try load calibration from localStorage
try{ const stored = localStorage.getItem('gyro_maze_calib'); if(stored){ calibration = JSON.parse(stored); appendLog('Loaded calibration'); } }catch(e){}

function initMaze(){
  // simple randomized maze generator (depth-first)
  maze = Array(ROWS).fill(0).map(()=>Array(COLS).fill(1));
  const stack = [];
  function carve(x,y){
    maze[y][x] = 0;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]].sort(()=>Math.random()-0.5);
    for(const [dx,dy] of dirs){
      const nx = x + dx*2, ny = y + dy*2;
      if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && maze[ny][nx]===1){
        maze[y+dy][x+dx]=0;
        carve(nx,ny);
      }
    }
  }
  carve(0, ROWS-1);
  // Ensure goal cells are open and reachable from the primary start.
  // Helper: nearest open cell (reuse local logic)
  function nearestOpenCellLocal(tx, ty) {
    let minDist = Infinity, best = {x:tx, y:ty};
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (maze[y][x] === 0) {
          const d = Math.abs(x-tx) + Math.abs(y-ty);
          if (d < minDist) { minDist = d; best = {x, y}; }
        }
      }
    }
    return best;
  }
  // local wrapper uses global corridor carving function (defined below)
  function carvePath(ax,ay,bx,by){ carveCorridor(ax,ay,bx,by,1); }
  // BFS from primary start to mark reachable open cells
  const startCell = nearestOpenCellLocal(0, ROWS-1);
  const visited = Array(ROWS).fill(0).map(()=>Array(COLS).fill(false));
  const qq = [startCell];
  if(maze[startCell.y][startCell.x]===0) visited[startCell.y][startCell.x]=true;
  while(qq.length){
    const cur = qq.shift();
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx = cur.x + dx, ny = cur.y + dy;
      if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !visited[ny][nx] && maze[ny][nx]===0){ visited[ny][nx]=true; qq.push({x:nx,y:ny}); }
    }
  }
  // All potential goal coords we want reachable
  const midX = Math.floor(COLS/2), midY = Math.floor(ROWS/2);
  const goals = [ [COLS-1,0], [0,ROWS-1], [0,0], [COLS-1,ROWS-1], [midX,0], [midX,ROWS-1], [0,midY], [COLS-1,midY] ];
  for(const [gx,gy] of goals){
    // ensure the goal cell itself is open
    if(gx>=0 && gx<COLS && gy>=0 && gy<ROWS) maze[gy][gx]=0;
    // if not visited (not reachable from start), carve connector from nearest visited cell
    if(!(gx>=0 && gx<COLS && gy>=0 && gy<ROWS) || !visited[gy][gx]){
      // find nearest visited cell
      let minD = Infinity, best = null;
      for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(visited[y][x]){
        const d = Math.abs(x-gx)+Math.abs(y-gy);
        if(d < minD){ minD = d; best = {x,y}; }
      }
      if(best){
        carvePath(best.x, best.y, gx, gy);
        // mark newly carved cells as visited for subsequent goals
        const q2 = [ {x:best.x, y:best.y} ]; visited[best.y][best.x]=true;
        while(q2.length){
          const cur = q2.shift();
          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dx,dy] of dirs){
            const nx = cur.x + dx, ny = cur.y + dy;
            if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !visited[ny][nx] && maze[ny][nx]===0){ visited[ny][nx]=true; q2.push({x:nx,y:ny}); }
          }
        }
      }
    }
  }
}

// carve a Manhattan corridor between two grid cells with optional thickness
function carveCorridor(ax,ay,bx,by,thickness){
  const tx = ax, ty = ay, gx = bx, gy = by;
  let x = tx, y = ty; maze[y][x]=0;
  const stepX = (gx>tx)?1:((gx<tx)?-1:0);
  const stepY = (gy>ty)?1:((gy<ty)?-1:0);
  while(x !== gx){ x += stepX; for(let oy = -thickness; oy<=thickness; oy++){ const yy = y+oy; if(yy>=0 && yy<ROWS) maze[yy][x]=0; } }
  while(y !== gy){ y += stepY; for(let ox = -thickness; ox<=thickness; ox++){ const xx = x+ox; if(xx>=0 && xx<COLS) maze[y][xx]=0; } }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw maze with enhanced walls
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      if(maze[r][c]===1){
        const grad = ctx.createLinearGradient(c*cell.w, r*cell.h, c*cell.w + cell.w, r*cell.h + cell.h);
        grad.addColorStop(0, '#2a2a3e');
        grad.addColorStop(1, '#1a1a2e');
        ctx.fillStyle = grad;
        ctx.fillRect(c*cell.w, r*cell.h, cell.w, cell.h);
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(c*cell.w, r*cell.h, cell.w, cell.h);
      }
    }
  }
  // draw goal squares with glow effect
  const goalColors = {
    blue: '#3b82f6', red: '#ef4444', yellow: '#fbbf24', green: '#10b981',
    orange: '#f97316', purple: '#a855f7', cyan: '#06b6d4', magenta: '#ec4899'
  };
  function drawGoal(x, y, color) {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = color;
    ctx.fillRect(x*cell.w - 4, y*cell.h - 4, cell.w + 8, cell.h + 8);
    ctx.globalAlpha = 1;
    const grad = ctx.createRadialGradient((x+0.5)*cell.w, (y+0.5)*cell.h, 0, (x+0.5)*cell.w, (y+0.5)*cell.h, Math.min(cell.w, cell.h)*0.7);
    grad.addColorStop(0, color);
    grad.addColorStop(1, color + '80');
    ctx.fillStyle = grad;
    ctx.fillRect(x*cell.w, y*cell.h, cell.w, cell.h);
  }
  drawGoal(COLS-1, 0, goalColors.blue);
  drawGoal(0, ROWS-1, goalColors.red);
  if(activeRoles.includes('yellow')) drawGoal(0, 0, goalColors.yellow);
  if(activeRoles.includes('green')) drawGoal(COLS-1, ROWS-1, goalColors.green);
  if(activeRoles.includes('orange')) drawGoal(Math.floor(COLS/2), 0, goalColors.orange);
  if(activeRoles.includes('purple')) drawGoal(Math.floor(COLS/2), ROWS-1, goalColors.purple);
  if(activeRoles.includes('cyan')) drawGoal(0, Math.floor(ROWS/2), goalColors.cyan);
  if(activeRoles.includes('magenta')) drawGoal(COLS-1, Math.floor(ROWS/2), goalColors.magenta);

  // draw players with enhanced graphics
  function drawPlayer(p, color) {
    const rad = Math.min(cell.w,cell.h)/3;
    ctx.globalAlpha = 0.2;
    ctx.beginPath();
    const glow = ctx.createRadialGradient(p.px, p.py, 0, p.px, p.py, rad * 2);
    glow.addColorStop(0, color);
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glow;
    ctx.arc(p.px, p.py, rad * 2, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.beginPath();
    const grad = ctx.createRadialGradient(p.px - rad*0.3, p.py - rad*0.3, 0, p.px, p.py, rad);
    grad.addColorStop(0, color + 'dd');
    grad.addColorStop(0.7, color);
    grad.addColorStop(1, color);
    ctx.fillStyle = grad;
    ctx.arc(p.px, p.py, rad, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.stroke();
  }
  drawPlayer(players.blue, goalColors.blue);
  drawPlayer(players.red, goalColors.red);
  if(activeRoles.includes('yellow')) drawPlayer(players.yellow, goalColors.yellow);
  if(activeRoles.includes('green')) drawPlayer(players.green, goalColors.green);
  if(activeRoles.includes('orange')) drawPlayer(players.orange, goalColors.orange);
  if(activeRoles.includes('purple')) drawPlayer(players.purple, goalColors.purple);
  if(activeRoles.includes('cyan')) drawPlayer(players.cyan, goalColors.cyan);
  if(activeRoles.includes('magenta')) drawPlayer(players.magenta, goalColors.magenta);
}

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

// Continuous movement: map beta/gamma to target velocities and integrate per-frame
const V_SMOOTH = 0.15; // velocity smoothing

function handleTilt(role, beta, gamma){
  const p = players[role];
  // more intuitive mapping:
  // prefer orientation angles if present. beta: front/back tilt, gamma: left/right tilt.
  // apply calibration, deadzone, sensitivity and non-linear scaling for control.
  const sensX = DEFAULT_SENS_X;
  const sensY = DEFAULT_SENS_Y;
  const dead = DEFAULT_DEADZONE;
  let b = beta, g = gamma;
  if(calibration.has){ b = b - calibration.beta; g = g - calibration.gamma; }
  // forward/back mapping: invert beta so up/down are swapped
  b = -b;
  // apply deadzone
  function applyDeadzone(v){ return Math.abs(v) < dead ? 0 : (v > 0 ? v - dead : v + dead); }
  b = applyDeadzone(b); g = applyDeadzone(g);
  // normalize and apply sensitivity
  // use 35deg as comfortable full-tilt reference
  const REF = 35;
  // per-axis sensitivity and use tanh for smooth limiting
  const rawX = Math.max(-1, Math.min(1, (g / REF) * sensX));
  const rawY = Math.max(-1, Math.min(1, (b / REF) * sensY));
  const tanh = (x) => Math.tanh(x * 1.2); // slight gain before tanh
  const nx = tanh(rawX);
  const ny = tanh(rawY);
  const vxTarget = nx * MAX_SPEED;
  const vyTarget = ny * MAX_SPEED;
  p.vx = p.vx * (1 - V_SMOOTH) + vxTarget * V_SMOOTH;
  p.vy = p.vy * (1 - V_SMOOTH) + vyTarget * V_SMOOTH;
}

// circle-rect collision test
function circleRectCollide(cx,cy,r, rx,ry,rw,rh){
  const nearestX = Math.max(rx, Math.min(cx, rx+rw));
  const nearestY = Math.max(ry, Math.min(cy, ry+rh));
  const dx = cx - nearestX; const dy = cy - nearestY;
  return (dx*dx + dy*dy) < (r*r);
}

function checkGoal(role){
  const p = players[role];
  const cx = Math.floor(p.px / cell.w), cy = Math.floor(p.py / cell.h);
  if(role==='blue' && cx===COLS-1 && cy===0){ scores.blue++; sBlue.textContent = scores.blue; appendLog('Blue scored!'); showWinOverlay('blue'); }
  if(role==='red' && cx===0 && cy===ROWS-1){ scores.red++; sRed.textContent = scores.red; appendLog('Red scored!'); showWinOverlay('red'); }
  if(role==='yellow' && activeRoles.includes('yellow') && cx===0 && cy===0){ scores.yellow++; sYellowEl.textContent = scores.yellow; appendLog('Yellow scored!'); showWinOverlay('yellow'); }
  if(role==='green' && activeRoles.includes('green') && cx===COLS-1 && cy===ROWS-1){ scores.green++; sGreenEl.textContent = scores.green; appendLog('Green scored!'); showWinOverlay('green'); }
  if(role==='orange' && activeRoles.includes('orange') && cx===Math.floor(COLS/2) && cy===0){ scores.orange++; sOrange.textContent = scores.orange; appendLog('Orange scored!'); showWinOverlay('orange'); }
  if(role==='purple' && activeRoles.includes('purple') && cx===Math.floor(COLS/2) && cy===ROWS-1){ scores.purple++; sPurple.textContent = scores.purple; appendLog('Purple scored!'); showWinOverlay('purple'); }
  if(role==='cyan' && activeRoles.includes('cyan') && cx===0 && cy===Math.floor(ROWS/2)){ scores.cyan++; sCyan.textContent = scores.cyan; appendLog('Cyan scored!'); showWinOverlay('cyan'); }
  if(role==='magenta' && activeRoles.includes('magenta') && cx===COLS-1 && cy===Math.floor(ROWS/2)){ scores.magenta++; sMagenta.textContent = scores.magenta; appendLog('Magenta scored!'); showWinOverlay('magenta'); }
}

function appendLog(msg){
  // Query the element at runtime so the code remains robust if #info is re-added.
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log('[maze] ' + msg);
  }catch(e){ console.log('[maze][appendLog] ', msg); }
}

function resetRound(){
  initMaze();
  // Helper to find nearest open cell to a target
  function nearestOpenCell(tx, ty) {
    let minDist = Infinity, best = {x:tx, y:ty};
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (maze[y][x] === 0) {
          const d = Math.abs(x-tx) + Math.abs(y-ty);
          if (d < minDist) { minDist = d; best = {x, y}; }
        }
      }
    }
    return best;
  }
  // Helper to find nearest open cell to a target that is reachable from a goal cell
  function reachableNearestOpenCell(tx, ty, gx, gy){
    // ensure goal is an open cell (or find nearest open cell to goal)
    let goal = {x: gx, y: gy};
    if(!(gx>=0 && gx<COLS && gy>=0 && gy<ROWS) || maze[gy][gx]===1){
      goal = nearestOpenCell(gx, gy);
    }
    // BFS from goal to mark reachable open cells
    const visited = Array(ROWS).fill(0).map(()=>Array(COLS).fill(false));
    const q = [goal];
    visited[goal.y][goal.x] = true;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const cur = q.shift();
      for(const [dx,dy] of dirs){
        const nx = cur.x + dx, ny = cur.y + dy;
        if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !visited[ny][nx] && maze[ny][nx]===0){
          visited[ny][nx]=true; q.push({x:nx,y:ny});
        }
      }
    }
    // find nearest visited open cell to target
    let minDist = Infinity, best = null;
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(visited[y][x]){
          const d = Math.abs(x-tx) + Math.abs(y-ty);
          if(d < minDist){ minDist = d; best = {x,y}; }
        }
      }
    }
    // fallback to plain nearest open cell
    if(!best) return nearestOpenCell(tx,ty);
    return best;
  }
  // place players at nearest open cell to their intended start that is reachable from their goal
  let pos;
  pos = reachableNearestOpenCell(0, ROWS-1, COLS-1, 0); players.blue = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0};
  pos = reachableNearestOpenCell(COLS-1, 0, 0, ROWS-1); players.red = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0};
  if(activeRoles.includes('yellow')){ pos = reachableNearestOpenCell(COLS-1, ROWS-1, 0, 0); players.yellow = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('green')){ pos = reachableNearestOpenCell(0, 0, COLS-1, ROWS-1); players.green = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('orange')){ pos = reachableNearestOpenCell(Math.floor(COLS/2), ROWS-1, Math.floor(COLS/2), 0); players.orange = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('purple')){ pos = reachableNearestOpenCell(Math.floor(COLS/2), 0, Math.floor(COLS/2), ROWS-1); players.purple = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('cyan')){ pos = reachableNearestOpenCell(COLS-1, Math.floor(ROWS/2), 0, Math.floor(ROWS/2)); players.cyan = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0}; }
  if(activeRoles.includes('magenta')){ pos = reachableNearestOpenCell(0, Math.floor(ROWS/2), COLS-1, Math.floor(ROWS/2)); players.magenta = {x:pos.x, y:pos.y, px: (pos.x+0.5)*cell.w, py: (pos.y+0.5)*cell.h, vx:0, vy:0}; }
  draw();

  // Ensure each player's start can actually reach their goal. If not, carve a direct connector.
  function pathExists(sx,sy,gx,gy){
    if(!(sx>=0 && sx<COLS && sy>=0 && sy<ROWS) || !(gx>=0 && gx<COLS && gy>=0 && gy<ROWS)) return false;
    if(maze[sy][sx]===1 || maze[gy][gx]===1) return false;
    const vis = Array(ROWS).fill(0).map(()=>Array(COLS).fill(false));
    const q = [{x:sx,y:sy}]; vis[sy][sx]=true;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    while(q.length){
      const cur = q.shift();
      if(cur.x===gx && cur.y===gy) return true;
      for(const [dx,dy] of dirs){
        const nx = cur.x+dx, ny = cur.y+dy;
        if(nx>=0 && nx<COLS && ny>=0 && ny<ROWS && !vis[ny][nx] && maze[ny][nx]===0){ vis[ny][nx]=true; q.push({x:nx,y:ny}); }
      }
    }
    return false;
  }
  // mapping of goals
  const midX2 = Math.floor(COLS/2), midY2 = Math.floor(ROWS/2);
  const goalMap = {
    blue: {x:COLS-1,y:0}, red:{x:0,y:ROWS-1}, yellow:{x:0,y:0}, green:{x:COLS-1,y:ROWS-1},
    orange:{x:midX2,y:0}, purple:{x:midX2,y:ROWS-1}, cyan:{x:0,y:midY2}, magenta:{x:COLS-1,y:midY2}
  };
  for(const role of Object.keys(players)){
    if(!activeRoles.includes(role)) continue;
    const p = players[role];
    const g = goalMap[role];
    if(!g) continue;
    if(!pathExists(p.x,p.y,g.x,g.y)){
      // carve a connector between the player's start and the goal to guarantee reachability
      carveCorridor(p.x,p.y,g.x,g.y,1);
      // update pixel positions after carving
      p.px = (p.x + 0.5) * cell.w;
      p.py = (p.y + 0.5) * cell.h;
    }
  }
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
// ROOM_ID is now only declared once below
const ROOM_ID = getRoomId();
// unified room badge: create if missing and expose helper to update status
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){
    rb = document.createElement('div'); rb.id = 'roomBadge';
    rb.style.cssText = 'position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000';
    document.body.appendChild(rb);
  }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

let ws=null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  // Add room id to ws URL
  let wsUrl;
  if(data.ws_url){
    wsUrl = data.ws_url.includes('?') ? `${data.ws_url}&token=${encodeURIComponent(token)}&room=${ROOM_ID}` : `${data.ws_url}?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  } else {
    wsUrl = `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  }
  ws = new WebSocket(wsUrl);
  try{ ws.binaryType = 'arraybuffer'; }catch(e){}

  ws.onopen = ()=>{
  console.log('[maze] ws open', wsUrl);
  appendLog(`Connected, Room ID: ${ROOM_ID}`);
  if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room: ${ROOM_ID}`);
  };

  ws.onmessage = async (ev)=>{
    try{
      let payloadText = '';
      if(ev.data instanceof ArrayBuffer){
        payloadText = new TextDecoder().decode(ev.data);
      } else if(typeof Blob !== 'undefined' && ev.data instanceof Blob){
        try{ payloadText = await ev.data.text(); }catch(e){
          payloadText = await new Promise((resolve, reject)=>{
            const fr = new FileReader(); fr.onload = ()=>resolve(fr.result); fr.onerror = reject; fr.readAsText(ev.data);
          });
        }
      } else {
        payloadText = ev.data;
      }

      const d = JSON.parse(payloadText);
      if(!d) return;
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || playerMsg.role==null) continue;
          if(playerMsg.room && String(playerMsg.room).toUpperCase() !== ROOM_ID) continue;
          if(!activeRoles.includes(playerMsg.role)) continue;
          if(!players[playerMsg.role]){
            if(playerMsg.role === 'orange'){
              players.orange = { x: Math.floor(COLS/2), y: ROWS-1, px: (Math.floor(COLS/2)+0.5)*cell.w, py: ((ROWS-1)+0.5)*cell.h, vx:0, vy:0 };
            } else if(playerMsg.role === 'purple'){
              players.purple = { x: Math.floor(COLS/2), y: 0, px: (Math.floor(COLS/2)+0.5)*cell.w, py: (0+0.5)*cell.h, vx:0, vy:0 };
            } else if(playerMsg.role === 'cyan'){
              players.cyan = { x: COLS-1, y: Math.floor(ROWS/2), px: ((COLS-1)+0.5)*cell.w, py: (Math.floor(ROWS/2)+0.5)*cell.h, vx:0, vy:0 };
            } else if(playerMsg.role === 'magenta'){
              players.magenta = { x: 0, y: Math.floor(ROWS/2), px: (0+0.5)*cell.w, py: (Math.floor(ROWS/2)+0.5)*cell.h, vx:0, vy:0 };
            } else {
              const cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
              players[playerMsg.role] = { x: cx, y: cy, px: (cx+0.5)*cell.w, py: (cy+0.5)*cell.h, vx:0, vy:0 };
            }
          }
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined && playerMsg.orientBeta!==null){
            orientationAvailable = true;
            lastDeviceOrientation = { beta: playerMsg.orientBeta, gamma: playerMsg.orientGamma, alpha: playerMsg.orientAlpha };
            if(!rotState[playerMsg.role]) rotState[playerMsg.role] = {b:0,g:0,ts:Date.now()};
            rotState[playerMsg.role].ts = Date.now();
            handleTilt(playerMsg.role, playerMsg.orientBeta, playerMsg.orientGamma);
          } else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            const now = Date.now();
            if(!rotState[playerMsg.role]) rotState[playerMsg.role] = {b:0,g:0,ts:now};
            const state = rotState[playerMsg.role];
            const dt = Math.min(0.1, (now - state.ts)/1000) || 0.02;
            state.ts = now;
            state.b += (playerMsg.beta || 0) * dt;
            state.g += (playerMsg.gamma || 0) * dt;
            state.b *= 0.995; state.g *= 0.995;
            lastDeviceOrientation = { beta: state.b, gamma: state.g };
            handleTilt(playerMsg.role, state.b, state.g);
          }
        }
      }
    }catch(err){
      console.error('[maze] Failed to handle ws message', err, ev.data);
    }
  };

  ws.onerror = (err)=>{ console.error('[maze] websocket error', err); appendLog('WebSocket error'); if(window.__setRoomBadge) window.__setRoomBadge('WebSocket error'); };
  ws.onclose = (ev)=>{ console.warn('[maze] websocket closed', ev); appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); };
}).catch(e=>{ appendLog('No backend /api/token'); });

// init
initMaze();
// set canvas/cell sizes to fill available space and initialize player pixel positions
resizeCanvasToDisplay();
players.blue.px = (0+0.5)*cell.w; players.blue.py = (ROWS-1+0.5)*cell.h;
players.red.px = (COLS-1+0.5)*cell.w; players.red.py = (0+0.5)*cell.h;

// Player count from URL (no local selector)
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const count = parseInt(params.get('players'), 10);
  if (count >= 2 && count <= 8) return count;
  return 2;
}
const playerCount = getPlayerCountFromUrl();

const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const orangeScoreContainer = document.getElementById('orangeScoreContainer');
const purpleScoreContainer = document.getElementById('purpleScoreContainer');
const cyanScoreContainer = document.getElementById('cyanScoreContainer');
const magentaScoreContainer = document.getElementById('magentaScoreContainer');
function updateActiveRoles(){
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, Math.max(2, Math.min(8, n)));
  yellowScoreContainer.style.display = (n >= 3) ? '' : 'none';
  greenScoreContainer.style.display = (n >= 4) ? '' : 'none';
  orangeScoreContainer.style.display = (n >= 5) ? '' : 'none';
  purpleScoreContainer.style.display = (n >= 6) ? '' : 'none';
  cyanScoreContainer.style.display = (n >= 7) ? '' : 'none';
  magentaScoreContainer.style.display = (n >= 8) ? '' : 'none';
  // Set score colors in HUD
  const roleColors = {
    blue: '#4ea1ff', red: '#ff6b6b', yellow: '#ffd86b', green: '#8fe58f',
    orange: '#ffae42', purple: '#b388ff', cyan: '#4deeea', magenta: '#ff6bd6'
  };
  const ids = {
    blue: sBlue, red: sRed, yellow: sYellowEl, green: sGreenEl,
    orange: sOrange, purple: sPurple, cyan: sCyan, magenta: sMagenta
  };
  for(const role of Object.keys(ids)){
    const el = ids[role];
    if(el && el.parentElement) el.parentElement.style.color = roleColors[role];
  }
  // reset positions for new roles
  resetRound();
}
// apply initial value
updateActiveRoles();

let lastTs = performance.now();
function frame(now){
  const dt = Math.min(40, now - lastTs) / 1000; // seconds, clamp
  lastTs = now;
  // integrate velocities -> positions
  for(const role of activeRoles){
    const p = players[role];
    // predict new position and resolve collisions per-axis so the player can slide along walls
    let nx = p.px + p.vx * dt;
    let ny = p.py;
    // collision: test X movement first
    const r = Math.min(cell.w,cell.h)/3;
    let collidedX = false;
    const minC_x = Math.max(0, Math.floor((nx - r)/cell.w));
    const maxC_x = Math.min(COLS-1, Math.floor((nx + r)/cell.w));
    const minR_x = Math.max(0, Math.floor((ny - r)/cell.h));
    const maxR_x = Math.min(ROWS-1, Math.floor((ny + r)/cell.h));
    for(let rr=minR_x; rr<=maxR_x; rr++){
      for(let cc=minC_x; cc<=maxC_x; cc++){
        if(maze[rr][cc]===1){
          if(circleRectCollide(nx, ny, r, cc*cell.w, rr*cell.h, cell.w, cell.h)){
            collidedX = true;
            break;
          }
        }
      }
      if(collidedX) break;
    }
    if(collidedX){
      // block X movement (slide along wall) and zero X velocity component
      nx = p.px;
      p.vx = 0;
    }

    // now test Y movement at potentially updated X
    ny = p.py + p.vy * dt;
    let collidedY = false;
    const minC_y = Math.max(0, Math.floor((nx - r)/cell.w));
    const maxC_y = Math.min(COLS-1, Math.floor((nx + r)/cell.w));
    const minR_y = Math.max(0, Math.floor((ny - r)/cell.h));
    const maxR_y = Math.min(ROWS-1, Math.floor((ny + r)/cell.h));
    for(let rr=minR_y; rr<=maxR_y; rr++){
      for(let cc=minC_y; cc<=maxC_y; cc++){
        if(maze[rr][cc]===1){
          if(circleRectCollide(nx, ny, r, cc*cell.w, rr*cell.h, cell.w, cell.h)){
            collidedY = true;
            break;
          }
        }
      }
      if(collidedY) break;
    }
    if(collidedY){
      // block Y movement and zero Y velocity component
      ny = p.py;
      p.vy = 0;
    }

    // apply resolved positions
    p.px = nx;
    p.py = ny;
    // apply friction so player gradually stops when no tilt
    const FRICTION = 0.92; // per-frame damping (0..1)
    p.vx *= Math.pow(FRICTION, dt*60);
    p.vy *= Math.pow(FRICTION, dt*60);
    // ensure players stay within canvas bounds (considering radius)
    const margin = r + 1;
    p.px = clamp(p.px, margin, canvas.width - margin);
    p.py = clamp(p.py, margin, canvas.height - margin);
    checkGoal(role);
  }
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>