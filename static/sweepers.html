<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Asteroid Sweepers</title>
<style>
  html,body{height:100%;margin:0;padding:0}
  body {
    font-family:'Segoe UI',Arial,Helvetica,sans-serif;
    background:#000;
    color:#eee;
    overflow:hidden;
  }
  canvas {
    position:fixed;
    top:0; left:0;
    width:100%; height:100%;
    background:radial-gradient(ellipse at center, #0f1a2e 0%, #060b18 50%, #000000 100%);
  }
  h1{display:none}
  /* Glass HUD */
  .hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;align-items:center;z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4)}
  .role{padding:8px 14px;border-radius:10px;background:rgba(255,255,255,0.08);font-weight:600;font-size:14px;transition:all 0.3s ease;border:1px solid rgba(255,255,255,0.1);text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  .role:hover{background:rgba(255,255,255,0.12);transform:translateY(-2px)}
  button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
</style>
</head>
<body>
  <h1>Asteroid Sweepers</h1>

  <div class="hud">
    <div class="role" id="blueRole">Blue <span id="sBlue">0</span></div>
    <div class="role" id="redRole">Red <span id="sRed">0</span></div>
    <div class="role" id="yellowRole" style="display:none">Yellow <span id="sYellow">0</span></div>
    <div class="role" id="greenRole" style="display:none">Green <span id="sGreen">0</span></div>
    <div class="role" id="orangeRole" style="display:none">Orange <span id="sOrange">0</span></div>
    <div class="role" id="purpleRole" style="display:none">Purple <span id="sPurple">0</span></div>
    <div class="role" id="cyanRole" style="display:none">Cyan <span id="sCyan">0</span></div>
    <div class="role" id="magentaRole" style="display:none">Magenta <span id="sMagenta">0</span></div>
    <button id="restart">Restart</button>
  </div>

  <canvas id="c" width="800" height="600"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// runtime-safe logger: attempts to write to #info if present, otherwise falls back to console
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();
function applyPlayerCountFromMeta(newCount){
  const clamped = Math.max(2, Math.min(8, parseInt(newCount || playerCount, 10)));
  if(Number.isNaN(clamped) || clamped === playerCount) return;
  playerCount = clamped;
  const params = new URLSearchParams(window.location.search);
  params.set('players', String(playerCount));
  const qs = params.toString();
  window.history.replaceState({}, '', `${window.location.pathname}?${qs}`);
  resetGame('Player count updated');
}
const roleBadges = {
  blue: document.getElementById('blueRole'),
  red: document.getElementById('redRole'),
  yellow: document.getElementById('yellowRole'),
  green: document.getElementById('greenRole'),
  orange: document.getElementById('orangeRole'),
  purple: document.getElementById('purpleRole'),
  cyan: document.getElementById('cyanRole'),
  magenta: document.getElementById('magentaRole')
};
const scoreSpans = {
  blue: document.getElementById('sBlue'),
  red: document.getElementById('sRed'),
  yellow: document.getElementById('sYellow'),
  green: document.getElementById('sGreen'),
  orange: document.getElementById('sOrange'),
  purple: document.getElementById('sPurple'),
  cyan: document.getElementById('sCyan'),
  magenta: document.getElementById('sMagenta')
};

const colorPalette = [
  '#4ea1ff', '#ff6b6b', '#ffd86b', '#8fe58f',
  '#ffa46b', '#b388ff', '#4deeea', '#ff6bd6'
];
const colorNames = ['Blue','Red','Yellow','Green','Orange','Purple','Cyan','Magenta'];

let ws = null;
let gameActive = true;
// Create splash overlay for winner
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 9998;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '48px';
winOverlay.style.fontWeight = '700';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);
let activeRoles = [];
let players = {};
let scores = {};
let asteroids = [];
let ARENA_RADIUS = 270;
let ARENA_CENTER = {x: canvas.width/2, y: canvas.height/2};

function resetGame(reason){
  gameActive = true;
  initPlayers();
  winOverlay.style.display = 'none';
  appendLog(reason || '');
}

// --- Initialize players and asteroids ---
function initPlayers() {
  const n = playerCount;
  activeRoles = Array.from({length: n}, (_, i) => colorNames[i].toLowerCase());
  players = {};
  scores = {};
  const angleStep = (2 * Math.PI) / n;
  for (let i = 0; i < n; i++) {
    const angle = i * angleStep;
    const spawnR = ARENA_RADIUS * 0.74;
    players[activeRoles[i]] = {
      x: ARENA_CENTER.x + Math.cos(angle) * spawnR,
      y: ARENA_CENTER.y + Math.sin(angle) * spawnR,
      vx: 0, vy: 0,
      color: colorPalette[i],
      baseAngle: angle
    };
    scores[activeRoles[i]] = 0;
  }
  initAsteroids();
  updateScoreDisplay();
}

// Restart button logic
  document.getElementById('restart').addEventListener('click', () => {
  resetGame('Restarted');
});

function initAsteroids() {
  asteroids = [];
  // Scale asteroid count with player count (3 per player)
  const asteroidCount = Math.max(3, activeRoles.length * 3);
  for (let i = 0; i < asteroidCount; i++) {
    const angle = Math.random() * 2 * Math.PI;
    const dist = Math.random() * ARENA_RADIUS * 0.6;
    asteroids.push({
      x: ARENA_CENTER.x + Math.cos(angle) * dist,
      y: ARENA_CENTER.y + Math.sin(angle) * dist,
      vx: (Math.random()-0.5)*24, // Lower initial velocity
      vy: (Math.random()-0.5)*24,
      r: 12 + Math.random()*8
    });
  }
}

function updateScoreDisplay() {
  for(const role of colorNames.map(n=>n.toLowerCase())){
    const badge = roleBadges[role];
    const span = scoreSpans[role];
    const idxActive = activeRoles.indexOf(role);
    const paletteIdx = colorNames.findIndex(n=>n.toLowerCase()===role);
    const visible = idxActive !== -1;
    if(badge){
      badge.style.display = visible ? '' : 'none';
      badge.style.color = colorPalette[paletteIdx] || '#fff';
    }
    if(span){
      span.textContent = scores[role] ?? 0;
      span.style.color = colorPalette[paletteIdx] || '#fff';
    }
  }
}

// --- Movement & game logic ---
function handleTilt(role, beta, gamma) {
  const p = players[role];
  if (!p) return;
  const tiltX = gamma / 35;
  // Reverse up/down tilt
  const tiltY = -beta / 35;
  const THRUST = 260; // Increased thrust for faster movement
  p.vx += tiltX * THRUST * 0.02;
  p.vy += tiltY * THRUST * 0.02;
}

function update(dt) {
  if (!gameActive) return;
  // Move players
  for (const r of activeRoles) {
    const p = players[r];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vx *= 0.97;
    p.vy *= 0.97;

    // Boundary circle
    const dx = p.x - ARENA_CENTER.x;
    const dy = p.y - ARENA_CENTER.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > ARENA_RADIUS - 10) {
      const nx = dx / dist, ny = dy / dist;
      p.x = ARENA_CENTER.x + nx * (ARENA_RADIUS - 10);
      p.y = ARENA_CENTER.y + ny * (ARENA_RADIUS - 10);
      const dot = p.vx*nx + p.vy*ny;
      p.vx -= 1.5*dot*nx;
      p.vy -= 1.5*dot*ny;
    }
  }

  // Move asteroids
  for (let i = asteroids.length - 1; i >= 0; i--) {
    const a = asteroids[i];
    a.x += a.vx * dt;
    a.y += a.vy * dt;

    // Bounce from arena boundary
    const dx = a.x - ARENA_CENTER.x;
    const dy = a.y - ARENA_CENTER.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > ARENA_RADIUS - a.r) {
      const nx = dx / dist, ny = dy / dist;
      a.x = ARENA_CENTER.x + nx * (ARENA_RADIUS - a.r);
      a.y = ARENA_CENTER.y + ny * (ARENA_RADIUS - a.r);
      const dot = a.vx*nx + a.vy*ny;
      a.vx -= 1.5*dot*nx;
      a.vy -= 1.5*dot*ny;
    }

    // Collide with players
    for (const r of activeRoles) {
      const p = players[r];
      const pdx = a.x - p.x, pdy = a.y - p.y;
      const d2 = pdx*pdx + pdy*pdy;
      const minDist = a.r + 10;
      if (d2 < minDist*minDist) {
        const d = Math.sqrt(d2) || 1;
        const nx = pdx / d, ny = pdy / d;
        const overlap = minDist - d;
        a.x += nx * overlap * 0.5;
        a.y += ny * overlap * 0.5;
        a.vx += nx * 120 * dt;
        a.vy += ny * 120 * dt;
        p.vx -= nx * 80 * dt;
        p.vy -= ny * 80 * dt;
      }
    }

    // Check if asteroid is near a player's base
    let taken = false;
    for (const r of activeRoles) {
      const p = players[r];
      const bx = ARENA_CENTER.x + Math.cos(p.baseAngle) * (ARENA_RADIUS - 40);
      const by = ARENA_CENTER.y + Math.sin(p.baseAngle) * (ARENA_RADIUS - 40);
      const dx = a.x - bx, dy = a.y - by;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < 30) {
        scores[r]++;
        updateScoreDisplay();
        // Remove asteroid from game
        asteroids.splice(i, 1);
        taken = true;
        break;
      }
    }
    // If asteroid was taken, skip further checks for this asteroid
    if (taken) continue;
  }
  // End game if all asteroids are taken
  if (asteroids.length === 0 && gameActive) {
    gameActive = false;
    // Find winner(s)
    let maxScore = -1, winners = [];
    for (const r of activeRoles) {
      if (scores[r] > maxScore) { maxScore = scores[r]; winners = [r]; }
      else if (scores[r] === maxScore) { winners.push(r); }
    }
    if (winners.length === 1) {
      const idx = activeRoles.indexOf(winners[0]);
      winOverlay.style.background = colorPalette[idx] || '#fff';
      winOverlay.textContent = `${colorNames[idx]} wins!`;
    } else {
      winOverlay.style.background = '#fff';
      winOverlay.textContent = `Tie: ${winners.map(r=>colorNames[activeRoles.indexOf(r)]).join(', ')}!`;
    }
    winOverlay.style.display = 'flex';
    appendLog(winOverlay.textContent);
    setTimeout(()=>{ winOverlay.style.display = 'none'; }, 3000);
  }
}

// --- Draw ---
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw arena boundary
  ctx.strokeStyle = 'rgba(255,255,255,0.18)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(ARENA_CENTER.x,ARENA_CENTER.y,ARENA_RADIUS,0,Math.PI*2);
  ctx.stroke();

  // Draw bases
  for (const r of activeRoles) {
    const p = players[r];
    const bx = ARENA_CENTER.x + Math.cos(p.baseAngle) * (ARENA_RADIUS - 40);
    const by = ARENA_CENTER.y + Math.sin(p.baseAngle) * (ARENA_RADIUS - 40);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(bx, by, 20, 0, Math.PI*2);
    ctx.fill();
  }

  // Draw asteroids
  for (const a of asteroids) {
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.arc(a.x,a.y,a.r,0,Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#aaa';
    ctx.stroke();
  }

  // Draw players
  for (const r of activeRoles) {
    const p = players[r];
    ctx.beginPath();
    ctx.arc(p.x,p.y,10,0,Math.PI*2);
    ctx.fillStyle = p.color;
    ctx.fill();
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

// --- Main loop ---
let last = performance.now();
function loop(now) {
  const dt = Math.min(40, now-last)/1000;
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// fullscreen sizing
function resizeCanvasToDisplay(){
  const oldCenter = {...ARENA_CENTER};
  const oldRadius = ARENA_RADIUS;
  const w = window.innerWidth;
  const h = window.innerHeight;
  const size = Math.min(w,h);
  canvas.width = w;
  canvas.height = h;
  ARENA_CENTER = {x: w/2, y: h/2};
  ARENA_RADIUS = Math.max(200, size * 0.42);
  const scale = ARENA_RADIUS / oldRadius;
  // reposition players relative to new center
  for(const role of Object.keys(players)){
    const p = players[role];
    const ang = Math.atan2(p.y - oldCenter.y, p.x - oldCenter.x);
    const dist = Math.hypot(p.x - oldCenter.x, p.y - oldCenter.y) * scale;
    p.x = ARENA_CENTER.x + Math.cos(ang) * dist;
    p.y = ARENA_CENTER.y + Math.sin(ang) * dist;
  }
  // reposition asteroids
  for(const a of asteroids){
    const ang = Math.atan2(a.y - oldCenter.y, a.x - oldCenter.x);
    const dist = Math.hypot(a.x - oldCenter.x, a.y - oldCenter.y) * scale;
    a.x = ARENA_CENTER.x + Math.cos(ang) * dist;
    a.y = ARENA_CENTER.y + Math.sin(ang) * dist;
  }
}
window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if (!room || room.length !== 3) {
    room = 'DEF'; // fallback
  }
  return room.toUpperCase();
}
const ROOM_ID = getRoomId();

// unified room badge helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// --- WebSocket hookup ---
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token=data.token;
  const proto=(location.protocol==='https:')?'wss':'ws';
  let wsUrl=data.ws_url ?
    (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)) :
    `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  // Add room id to wsUrl
  wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
  ws=new WebSocket(wsUrl);
  ws.onopen=()=>{
    appendLog(`Connected, Room ID: ${ROOM_ID}`);
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected â€” Room: ${ROOM_ID}`);
    ws.send(JSON.stringify({type:'request-meta', room:ROOM_ID}));
    ws.send(JSON.stringify({type:'room-meta', room:ROOM_ID, meta:{playerCount}}));
  };
  ws.onmessage=ev=>{
    try{
      const d=JSON.parse(ev.data);
      if(!d) return;
      if(d.type==='room-meta' && (!d.room || String(d.room).toUpperCase()===ROOM_ID)){
        if(d.meta && d.meta.playerCount!==undefined) applyPlayerCountFromMeta(d.meta.playerCount);
        return;
      }
      if(d.type==='request-meta' && (!d.room || String(d.room).toUpperCase()===ROOM_ID)){
        ws.send(JSON.stringify({type:'room-meta', room:ROOM_ID, meta:{playerCount}}));
        return;
      }
      if(d.type==='batch' && d.meta && d.meta.playerCount!==undefined){
        applyPlayerCountFromMeta(d.meta.playerCount);
      }
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg||!playerMsg.role) continue;
          if (playerMsg.room && playerMsg.room.toUpperCase() !== ROOM_ID) continue;
          let role = playerMsg.role;
          const codeMap = {
            b: 'blue', r: 'red', y: 'yellow', g: 'green', o: 'orange', p: 'purple', c: 'cyan', m: 'magenta',
            blue: 'blue', red: 'red', yellow: 'yellow', green: 'green', orange: 'orange', purple: 'purple', cyan: 'cyan', magenta: 'magenta'
          };
          if (codeMap[role] !== undefined) {
            role = codeMap[role];
          }
          if(!activeRoles.includes(role)) continue;
          if(playerMsg.orientBeta!==undefined&&playerMsg.orientGamma!==undefined){
            handleTilt(role,playerMsg.orientBeta,playerMsg.orientGamma);
          } else if(playerMsg.beta!==undefined&&playerMsg.gamma!==undefined){
            handleTilt(role,playerMsg.beta,playerMsg.gamma);
          }
        }
      }
    }catch(e){}
  };
  ws.onclose=()=>{appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000);};
}).catch(e=>{appendLog('No backend /api/token');});

// init
initPlayers();
</script>
</body>
</html>
