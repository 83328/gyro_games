<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Turtle Race</title>
<style>
  html,body{height:100%;margin:0;padding:0;overflow:hidden}
  body {font-family:'Segoe UI',Arial,Helvetica,sans-serif;background:#000;color:#fff;display:flex;flex-direction:column;align-items:center;padding:0;box-sizing:border-box;overflow:hidden;height:100vh}
  canvas {display:block;width:100%;height:100%;background:radial-gradient(ellipse at center, #1a0a2e 0%, #0f051d 50%, #000000 100%);position:absolute;top:0;left:0;padding-top:70px;box-sizing:border-box}
  #info {display:none}
  h1{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:999;margin:0;font-size:32px;font-weight:700;text-shadow:0 4px 12px rgba(0,0,0,0.8);display:none}
  #scores {position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4);display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  #scores span{font-weight:600;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  #scores button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  #scores button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
</style>
</head>
<body>
  <h1>Turtle Race</h1>
  
  <div id="scores">
    <span id="blueScoreContainer">Blue: <span id="sBlue">0</span></span> — <span id="redScoreContainer">Red: <span id="sRed">0</span></span>
  <span id="yellowScoreContainer" style="display:none"> — <span id="lblYellow">Yellow</span>: <span id="sYellow">0</span></span>
  <span id="greenScoreContainer" style="display:none"> — <span id="lblGreen">Green</span>: <span id="sGreen">0</span></span>
  <span id="orangeScoreContainer" style="display:none"> — <span id="lblOrange">Orange</span>: <span id="sOrange">0</span></span>
  <span id="purpleScoreContainer" style="display:none"> — <span id="lblPurple">Purple</span>: <span id="sPurple">0</span></span>
  <span id="cyanScoreContainer" style="display:none"> — <span id="lblCyan">Cyan</span>: <span id="sCyan">0</span></span>
  <span id="magentaScoreContainer" style="display:none"> — <span id="lblMagenta">Magenta</span>: <span id="sMagenta">0</span></span>
    <button id="fs" style="margin-left:12px;padding:.3rem .6rem;border-radius:6px;border:none;background:#1f6feb;color:white">Fullscreen</button>
  </div>
  <canvas id="c"></canvas>
  <div id="msg" style="position:fixed;left:0;right:0;top:0;bottom:0;display:flex;align-items:center;justify-content:center;pointer-events:none;">
    <div id="msgInner" style="background:rgba(0,0,0,0.6);padding:18px 28px;border-radius:10px;color:#fff;font-size:40px;text-align:center;min-width:220px;">
      <div id="msgMain">3</div>
      <div id="msgSub" style="font-size:14px;opacity:0.9;margin-top:8px">Connecting...</div>
    </div>
  </div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// Define track first before using in resizeCanvas
const track = {length: 0};

// Fullscreen canvas setup
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  track.length = canvas.width - 120;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const colors = {blue:'#3b82f6', red:'#ef4444', yellow:'#fbbf24', green:'#10b981', orange:'#f97316', purple:'#a855f7', cyan:'#06b6d4', magenta:'#ec4899'};

// runtime-safe logger
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if (!room || room.length !== 3) {
    room = 'DEF';
  }
  return room.toUpperCase();
}
const ROOM_ID = getRoomId();

// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();

const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const orangeScoreContainer = document.getElementById('orangeScoreContainer');
const purpleScoreContainer = document.getElementById('purpleScoreContainer');
const cyanScoreContainer = document.getElementById('cyanScoreContainer');
const magentaScoreContainer = document.getElementById('magentaScoreContainer');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

let ws=null;
let activeRoles = ['blue','red'];
let scores = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};
let players = {};
let raceRunning = false;
let countdown = 3; // seconds before race start
let countdownTimer = null;

// initialize players
function initPlayers(){
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, Math.max(2, Math.min(8, n)));
  // show/hide score containers
  yellowScoreContainer.style.display = (n >= 3) ? '' : 'none';
  greenScoreContainer.style.display = (n >= 4) ? '' : 'none';
  orangeScoreContainer.style.display = (n >= 5) ? '' : 'none';
  purpleScoreContainer.style.display = (n >= 6) ? '' : 'none';
  cyanScoreContainer.style.display = (n >= 7) ? '' : 'none';
  magentaScoreContainer.style.display = (n >= 8) ? '' : 'none';
  players={};
  const topPadding = 70;
  const usableHeight = canvas.height - topPadding;
  const laneHeight = usableHeight / activeRoles.length;
  let i=0;
  for(const role of activeRoles){
    players[role]={x:80,y:topPadding + laneHeight*(i+0.5),speed:0,power:0};
    i++;
  }
  // Set score colors in HUD
  const ids = {
    blue: sBlue, red: sRed, yellow: sYellow, green: sGreen,
    orange: sOrange, purple: sPurple, cyan: sCyan, magenta: sMagenta
  };
  for(const role of Object.keys(ids)){
    const el = ids[role];
    if(el) el.style.color = colors[role];
  }
  // Also color the label text and ensure containers are visible/hidden
  const lbls = {
    blue: document.getElementById('blueScoreContainer'),
    red: document.getElementById('redScoreContainer'),
    yellow: document.getElementById('yellowScoreContainer'),
    green: document.getElementById('greenScoreContainer'),
    orange: document.getElementById('orangeScoreContainer'),
    purple: document.getElementById('purpleScoreContainer'),
    cyan: document.getElementById('cyanScoreContainer'),
    magenta: document.getElementById('magentaScoreContainer')
  };
  for(const role of Object.keys(lbls)){
    const container = lbls[role];
    if(!container) continue;
    if(activeRoles.includes(role)){
      container.style.display = '';
      container.style.color = colors[role];
    } else {
      container.style.display = 'none';
    }
  }
  startCountdown();
}
initPlayers();

// Update player count from room meta and reinitialize
function applyPlayerCountFromMeta(n){
  const pc = parseInt(n, 10);
  if (!(pc >= 2 && pc <= 8)) return;
  if (pc === playerCount) return;
  playerCount = pc;
  try {
    const u = new URL(window.location);
    u.searchParams.set('players', playerCount);
    window.history.replaceState({}, '', u);
  } catch(e){}
  resetRace();
}

// show winner splash
function showWinnerSplash(role){
  const msg = document.getElementById('msg');
  const msgMain = document.getElementById('msgMain');
  const msgSub = document.getElementById('msgSub');
  const msgInner = document.getElementById('msgInner');
  msg.style.display = 'flex';
  msg.style.background = colors[role] || '#4ea1ff';
  msgInner.style.background = 'transparent';
  msgInner.style.boxShadow = 'none';
  msgMain.textContent = `${role.toUpperCase()} WINS!`;
  msgSub.textContent = `Score: ${scores[role]}`;
  setTimeout(()=>{ msg.style.display = 'none'; msg.style.background = ''; msgInner.style.background = 'rgba(0,0,0,0.6)'; msgInner.style.boxShadow = ''; }, 2500);
}

// countdown logic
function startCountdown(){
  countdown = 3;
  raceRunning = false;
  // show centered countdown overlay
  const msg = document.getElementById('msg');
  const msgMain = document.getElementById('msgMain');
  const msgSub = document.getElementById('msgSub');
  const msgInner = document.getElementById('msgInner');
  msgInner.style.background = 'rgba(0,0,0,0.6)';
  msg.style.display = 'flex';
  msgMain.textContent = countdown;
  msgSub.textContent = (document.getElementById('info') ? document.getElementById('info').textContent : `Room ${ROOM_ID}`);
  clearInterval(countdownTimer);
  countdownTimer = setInterval(()=>{
    countdown--;
    if(countdown>0){
      msgMain.textContent = countdown;
    } else {
      clearInterval(countdownTimer);
      msgMain.textContent = 'Go!';
      // hide after short delay so players see "Go!"
      setTimeout(()=>{ document.getElementById('msg').style.display = 'none'; }, 800);
      raceRunning = true;
    }
  },1000);
}

// draw track and riders
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // lanes with alternating colors
  const n=activeRoles.length;
  const topPadding = 70;
  const usableHeight = canvas.height - topPadding;
  const laneH=usableHeight/n;
  for(let i=0;i<n;i++){
    const grad = ctx.createLinearGradient(0, i*laneH, 0, (i+1)*laneH);
    if(i%2===0){
      grad.addColorStop(0, '#1a1a2e');
      grad.addColorStop(1, '#16162a');
    } else {
      grad.addColorStop(0, '#16162a');
      grad.addColorStop(1, '#121226');
    }
    ctx.fillStyle = grad;
    ctx.fillRect(0, topPadding + i*laneH, canvas.width, laneH);
    // lane divider
    if(i > 0) {
      ctx.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, topPadding + i*laneH);
      ctx.lineTo(canvas.width, topPadding + i*laneH);
      ctx.stroke();
    }
  }

  // finish line with glow
  ctx.shadowColor = 'rgba(255,255,255,0.5)';
  ctx.shadowBlur = 15;
  ctx.strokeStyle='#fff';
  ctx.lineWidth=4;
  ctx.setLineDash([10,8]);
  ctx.beginPath();
  ctx.moveTo(track.length+50,topPadding);
  ctx.lineTo(track.length+50,canvas.height);
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.shadowBlur = 0;

  // riders with enhanced graphics
  for(const role of activeRoles){
    const p = players[role];
    const rad = 20;
    // glow
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, rad * 2.5);
    glow.addColorStop(0, colors[role]);
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glow;
    ctx.arc(p.x, p.y, rad * 2.5, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // main circle with gradient
    ctx.beginPath();
    const grad = ctx.createRadialGradient(p.x - rad*0.3, p.y - rad*0.3, rad*0.1, p.x, p.y, rad);
    grad.addColorStop(0, colors[role] + 'ee');
    grad.addColorStop(0.7, colors[role]);
    grad.addColorStop(1, colors[role]);
    ctx.fillStyle = grad;
    ctx.arc(p.x, p.y, rad, 0, Math.PI*2);
    ctx.fill();
    
    // highlight
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    const highlight = ctx.createRadialGradient(p.x - rad*0.3, p.y - rad*0.3, 0, p.x - rad*0.3, p.y - rad*0.3, rad*0.5);
    highlight.addColorStop(0, 'rgba(255,255,255,0.9)');
    highlight.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = highlight;
    ctx.arc(p.x - rad*0.25, p.y - rad*0.25, rad*0.4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // outline
    ctx.lineWidth = 2.5;
    ctx.strokeStyle='rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(p.x, p.y, rad, 0, Math.PI*2);
    ctx.stroke();
  }
}

// handle gyroscope input
// Code-only speed multiplier (no UI) to globally scale turtle responsiveness/speed
const SPEED_MULTIPLIER = 1.5; // increase to make turtles move faster
function handleInput(role, beta, gamma){
  const p = players[role]; if(!p || !raceRunning) return;
  const intensity = (Math.abs(beta) + Math.abs(gamma)) * 0.05 * SPEED_MULTIPLIER; // adjusted multiplier
  p.power += intensity;
}

// physics + race logic
function step(dt){
  if(!raceRunning) return;
  for(const role of activeRoles){
    const p = players[role];
  // convert power into forward speed
  p.speed += p.power * 0.6 * SPEED_MULTIPLIER;
  p.power *= 0.3; // dissipate pedaling effort
  p.speed *= Math.pow(0.92, dt*60);
  p.x += p.speed * dt * 0.1 * SPEED_MULTIPLIER;
    
    // check finish line
    if(p.x >= track.length+40){
    raceRunning=false;
    scores[role]++;
  // refresh all score displays so newly visible ones show correct values
  sBlue.textContent = scores.blue;
  sRed.textContent = scores.red;
  sYellow.textContent = scores.yellow;
  sGreen.textContent = scores.green;
  if(typeof sOrange !== 'undefined') sOrange.textContent = scores.orange;
  if(typeof sPurple !== 'undefined') sPurple.textContent = scores.purple;
  if(typeof sCyan !== 'undefined') sCyan.textContent = scores.cyan;
  if(typeof sMagenta !== 'undefined') sMagenta.textContent = scores.magenta;
  appendLog(`${role} wins the race!`);
  showWinnerSplash(role);
      setTimeout(()=>resetRace(),3000);
    }
  }
}

// reset race
function resetRace(){
  initPlayers();
}

(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// Fullscreen button
const fsBtn = document.getElementById('fs');
if(fsBtn){
  fsBtn.addEventListener('click', ()=>{
    const elem = document.documentElement;
    if(!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement){
      if(elem.requestFullscreen) elem.requestFullscreen();
      else if(elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
      else if(elem.mozRequestFullScreen) elem.mozRequestFullScreen();
      else if(elem.msRequestFullscreen) elem.msRequestFullscreen();
    } else {
      if(document.exitFullscreen) document.exitFullscreen();
      else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
      else if(document.mozCancelFullScreen) document.mozCancelFullScreen();
      else if(document.msExitFullscreen) document.msExitFullscreen();
    }
  });
}

// WebSocket setup
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  let wsUrl = data.ws_url ? (data.ws_url.includes('?') ? data.ws_url + '&token=' + encodeURIComponent(token) : data.ws_url + '?token=' + encodeURIComponent(token)) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  // Add room id to wsUrl
  wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{ appendLog(`Connected, Room ID: ${ROOM_ID}`); const ms = document.getElementById('msgSub'); if(ms) ms.textContent = `Connected — Room ${ROOM_ID}`; if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room: ${ROOM_ID}`); 
    // Discover and announce room meta
    try { ws.send(JSON.stringify({ type: 'request-meta', t: Date.now() })); } catch(e){}
    try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
    startCountdown(); };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data); 
      if(!d) return;
      // Room metadata updates
      if (d.type === 'room-meta' && d.playerCount !== undefined) {
        applyPlayerCountFromMeta(d.playerCount);
        return;
      }
      if (d.type === 'request-meta') {
        try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
        return;
      }
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || !playerMsg.role) continue;
          if (playerMsg.room && playerMsg.room.toUpperCase() !== ROOM_ID) continue;
          if(!activeRoles.includes(playerMsg.role)) continue;
          if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){ handleInput(playerMsg.role, playerMsg.beta, playerMsg.gamma); }
          else if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined){ handleInput(playerMsg.role, playerMsg.orientBeta, playerMsg.orientGamma); }
        }
      }
    }catch(e){}
  };
  ws.onclose = ()=>{ appendLog('Disconnected'); const ms = document.getElementById('msgSub'); if(ms) ms.textContent = 'Disconnected'; if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000); };
}).catch(e=>{ appendLog('No backend /api/token'); });

let last=performance.now();
function frame(now){
  const dt=Math.min(40,now-last)/1000; last=now;
  step(dt);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
