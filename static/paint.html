<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Paint</title>
<style>
  html,body{height:100%;margin:0;padding:0;overflow:hidden}
  body {font-family:'Segoe UI',Arial,Helvetica,sans-serif;background:#000;color:#fff;display:flex;flex-direction:column;align-items:center;padding:0;box-sizing:border-box;overflow:hidden;height:100vh}
  canvas {display:block;width:100%;height:100%;background:radial-gradient(ellipse at center, #1a0a2e 0%, #0f051d 50%, #000000 100%);position:absolute;top:0;left:0;box-sizing:border-box}
  h1{position:fixed;top:20px;left:50%;transform:translateX(-50%);z-index:999;margin:0;font-size:32px;font-weight:700;text-shadow:0 4px 12px rgba(0,0,0,0.8);display:none}
  #info {display:none}
  #scores {position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4);display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  #scores .role{font-weight:600;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5);padding:4px 8px;border-radius:8px;background:rgba(255,255,255,0.05)}
  #scores button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  #scores button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
  #countdownBadge{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:10px 16px;border-radius:12px;font-size:20px;font-weight:800;z-index:10000;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1)}
  #roomBadge{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1)}
</style>
</head>
<body>
  <h1>Paint</h1>
  
  <div id="scores">
  <span id="blueScoreContainer" class="role">Blue <span id="sBlue">0</span></span>
  <span id="redScoreContainer" class="role">Red <span id="sRed">0</span></span>
    <span id="yellowScoreContainer" class="role" style="display:none">Yellow <span id="sYellow">0</span></span>
    <span id="greenScoreContainer" class="role" style="display:none">Green <span id="sGreen">0</span></span>
    <span id="orangeScoreContainer" class="role" style="display:none">Orange <span id="sOrange">0</span></span>
    <span id="purpleScoreContainer" class="role" style="display:none">Purple <span id="sPurple">0</span></span>
    <span id="cyanScoreContainer" class="role" style="display:none">Cyan <span id="sCyan">0</span></span>
    <span id="magentaScoreContainer" class="role" style="display:none">Magenta <span id="sMagenta">0</span></span>
  </div>
  <canvas id="c"></canvas>
  <div id="roomBadge">Room: ---</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// runtime-safe logger: attempts to write to #info if present, otherwise falls back to console
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();
const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const orangeScoreContainer = document.getElementById('orangeScoreContainer');
const purpleScoreContainer = document.getElementById('purpleScoreContainer');
const cyanScoreContainer = document.getElementById('cyanScoreContainer');
const magentaScoreContainer = document.getElementById('magentaScoreContainer');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

const colors = {
  blue: '#4ea1ff',
  red: '#ff6b6b',
  yellow: '#ffd86b',
  green: '#8fe58f',
  orange: '#ffae42',
  purple: '#b388ff',
  cyan: '#4deeea',
  magenta: '#ff6bd6'
};
let ws = null;
let activeRoles = ['blue','red'];
let scores = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};
let players = {};
// Freeform painting config (no grid)
let brushSize = 120; // recalculated in resizeCanvas
let scoresArea = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};

// Fullscreen canvas setup
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  // dynamic brush size based on canvas size (10x thicker)
  brushSize = Math.max(60, Math.min(canvas.width, canvas.height) * 0.012 * 10);
  // Clamp players to new bounds
  if (players && Object.keys(players).length > 0) {
    for (const role of activeRoles) {
      const p = players[role];
      if (!p) continue;
      p.x = Math.max(0, Math.min(canvas.width, p.x));
      p.y = Math.max(0, Math.min(canvas.height, p.y));
      p.prevX = p.x; p.prevY = p.y;
    }
  }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Freeform: no field grid to initialize

function initPlayers() {
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, Math.max(2, Math.min(8, n)));
  yellowScoreContainer.style.display = (n >= 3) ? '' : 'none';
  greenScoreContainer.style.display = (n >= 4) ? '' : 'none';
  orangeScoreContainer.style.display = (n >= 5) ? '' : 'none';
  purpleScoreContainer.style.display = (n >= 6) ? '' : 'none';
  cyanScoreContainer.style.display = (n >= 7) ? '' : 'none';
  magentaScoreContainer.style.display = (n >= 8) ? '' : 'none';
  players = {};
  // spawn positions: random across full canvas
  for (let i=0;i<activeRoles.length;i++) {
    const role = activeRoles[i];
    const x = Math.random()*canvas.width;
    const y = Math.random()*canvas.height;
    players[role] = { x, y, prevX: x, prevY: y, vx: 0, vy: 0 };
  }
  scores = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};
  scoresArea = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};
  sBlue.textContent = 0;
  sRed.textContent = 0;
  sYellow.textContent = 0;
  sGreen.textContent = 0;
  if(sOrange) sOrange.textContent = 0;
  if(sPurple) sPurple.textContent = 0;
  if(sCyan) sCyan.textContent = 0;
  if(sMagenta) sMagenta.textContent = 0;
}
initPlayers();

// Update player count from room meta and reinitialize
function applyPlayerCountFromMeta(n){
  const pc = parseInt(n, 10);
  if (!(pc >= 2 && pc <= 8)) return;
  if (pc === playerCount) return;
  playerCount = pc;
  try {
    const u = new URL(window.location);
    u.searchParams.set('players', playerCount);
    window.history.replaceState({}, '', u);
  } catch(e){}
  initPlayers();
}

function handleTilt(role, beta, gamma) {
  if(!roundActive) return;
  const p = players[role]; if(!p) return;
  // fluid motion from tilt (reverse Y to match earlier control feel)
  const speedFactor = 0.25; // pixels per degree
  let dx = gamma * speedFactor;
  let dy = -beta * speedFactor;
  const maxSpeed = 20;
  dx = Math.max(-maxSpeed, Math.min(maxSpeed, dx));
  dy = Math.max(-maxSpeed, Math.min(maxSpeed, dy));
  const newX = Math.max(0, Math.min(canvas.width, p.x + dx));
  const newY = Math.max(0, Math.min(canvas.height, p.y + dy));
  const dist = Math.hypot(newX - p.x, newY - p.y);
  if (dist > 0.5) {
    // draw rounded stroke
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.strokeStyle = colors[role];
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.shadowColor = colors[role];
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.moveTo(p.prevX, p.prevY);
    ctx.lineTo(newX, newY);
    ctx.stroke();
    ctx.restore();
    // accumulate painted area approximation
    scoresArea[role] = (scoresArea[role] || 0) + dist * brushSize;
    // update position
    p.prevX = newX; p.prevY = newY;
    p.x = newX; p.y = newY;
  }
}

function update(dt) {
  // no per-frame painting; strokes are drawn on movement
}

function draw() {
  // No continuous redraw; strokes persist. HUD overlays handle themselves.
}

function tallyScores() {
  const totalArea = activeRoles.reduce((sum, r)=> sum + (scoresArea[r] || 0), 0) || 1;
  for (const role of activeRoles) {
    const scoreSpan = { blue: sBlue, red: sRed, yellow: sYellow, green: sGreen, orange: sOrange, purple: sPurple, cyan: sCyan, magenta: sMagenta }[role];
    const pct = Math.round(((scoresArea[role] || 0) / totalArea) * 100);
    if (scoreSpan) {
      scoreSpan.textContent = `${pct}%`;
      scoreSpan.style.color = colors[role] || '';
      scoreSpan.style.fontWeight = '700';
    }
    const containerId = role + 'ScoreContainer';
    const container = document.getElementById(containerId);
    if (container) { container.style.display = ''; container.style.color = colors[role]; }
  }
  const allRoles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  for (const role of allRoles) {
    if (!activeRoles.includes(role)) {
      const containerId = role + 'ScoreContainer';
      const container = document.getElementById(containerId);
      if (container) container.style.display = 'none';
    }
  }
}

function loop(now) {
  const dt = 1/60;
  update(dt);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
setInterval(tallyScores, 1000); // update scores every second

// --- Timer and overlay logic ---
let roundTime = 35; // seconds
let timeLeft = roundTime;
let timerInterval = null;
let roundActive = true;
let intermissionInterval = null; // countdown before auto-restart

// Create overlay for winner
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 9998;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '48px';
winOverlay.style.fontWeight = '700';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);

// prominent countdown badge (top-right, styled in CSS)
const countdownBadge = document.createElement('div');
countdownBadge.id = 'countdownBadge';
countdownBadge.style.display = 'none';
document.body.appendChild(countdownBadge);

function showWinOverlay(role) {
  winOverlay.style.background = colors[role] || '#fff';
  winOverlay.textContent = `${role.charAt(0).toUpperCase()+role.slice(1)} wins!`;
  winOverlay.style.display = 'flex';
  setTimeout(()=>{ winOverlay.style.display = 'none'; }, 6000);
}

function startRoundTimer() {
  // Cancel any pending intermission countdown
  if (intermissionInterval) { clearInterval(intermissionInterval); intermissionInterval = null; }
  timeLeft = roundTime;
  roundActive = true;
  if(timerInterval) clearInterval(timerInterval);
  // show prominent countdown badge
  if(countdownBadge) {
    countdownBadge.style.display = '';
    countdownBadge.textContent = `${timeLeft}s`;
  }
  timerInterval = setInterval(()=>{
    timeLeft--;
    // update both small log and prominent badge
    appendLog(`Time left: ${timeLeft}s`);
    if(countdownBadge) countdownBadge.textContent = `${timeLeft}s`;
    if(timeLeft <= 0) {
      clearInterval(timerInterval);
      endRound();
    }
  }, 1000);
  appendLog(`Time left: ${timeLeft}s`);
}

function endRound() {
  roundActive = false;
  tallyScores();
  // Find winner(s) by painted area
  let maxScore = -1, winners = [];
  for(const r of activeRoles) {
    const val = scoresArea[r] || 0;
    if(val > maxScore) { maxScore = val; winners = [r]; }
    else if(val === maxScore) { winners.push(r); }
  }
    if(winners.length === 1) {
    showWinOverlay(winners[0]);
    appendLog(`${winners[0].charAt(0).toUpperCase()+winners[0].slice(1)} wins!`);
  } else {
    winOverlay.style.background = '#fff';
    winOverlay.textContent = `Tie: ${winners.map(r=>r.charAt(0).toUpperCase()+r.slice(1)).join(', ')}!`;
    winOverlay.style.display = 'flex';
    appendLog(`Tie: ${winners.map(r=>r.charAt(0).toUpperCase()+r.slice(1)).join(', ')}`);
    setTimeout(()=>{ winOverlay.style.display = 'none'; }, 6000);
  }
  // Immediately clear the board visuals/state so a new game starts cleanly
  ctx.clearRect(0,0,canvas.width,canvas.height);
  scoresArea = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};

  // Start a 5-second intermission countdown, then auto-restart a new round
  if (intermissionInterval) { clearInterval(intermissionInterval); intermissionInterval = null; }
  let restartIn = 5;
  if (countdownBadge) {
    countdownBadge.style.display = '';
    countdownBadge.textContent = `Next round in ${restartIn}s`;
  }
  intermissionInterval = setInterval(() => {
    restartIn--;
    if (countdownBadge) countdownBadge.textContent = `Next round in ${restartIn}s`;
    if (restartIn <= 0) {
      clearInterval(intermissionInterval);
      intermissionInterval = null;
      // Fully reset players and start the new round
      initPlayers();
      winOverlay.style.display = 'none';
      startRoundTimer();
    }
  }, 1000);
}

// Manual restart removed; rounds auto-restart after intermission

// Fullscreen button removed

// Start timer on load
startRoundTimer();

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
const ROOM_ID = getRoomId();
// show room badge immediately
const roomBadge = document.getElementById('roomBadge'); if(roomBadge) roomBadge.textContent = `Room ID: ${ROOM_ID}`;

// WebSocket hookup
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  const wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token)+'&room='+ROOM_ID:data.ws_url+'?token='+encodeURIComponent(token)+'&room='+ROOM_ID) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=> {
    appendLog(`Connected, Room ID: ${ROOM_ID}`);
    const rb = document.getElementById('roomBadge'); if(rb) rb.textContent = `Connected — Room ID: ${ROOM_ID}`;
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room ID: ${ROOM_ID}`);
    // Discover and announce room meta
    try { ws.send(JSON.stringify({ type: 'request-meta', t: Date.now() })); } catch(e){}
    try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
  };
  ws.onmessage = ev => {
    try {
      const d = JSON.parse(ev.data);
      if (!d) return;
      if (d.type === 'room-meta' && d.playerCount !== undefined) {
        applyPlayerCountFromMeta(d.playerCount);
        return;
      }
      if (d.type === 'request-meta') {
        try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
        return;
      }
      
      // Handle batch messages (aggregated state from server)
      if (d.type === 'batch' && Array.isArray(d.players)) {
        for (const playerMsg of d.players) {
          if (!playerMsg || !playerMsg.role) continue;
          // Only process messages for this room
          if(playerMsg.room && String(playerMsg.room).toUpperCase() !== ROOM_ID) continue;
          if (!activeRoles.includes(playerMsg.role)) continue;
          
          if (playerMsg.orientBeta !== undefined && playerMsg.orientGamma !== undefined) {
            handleTilt(playerMsg.role, playerMsg.orientBeta, playerMsg.orientGamma);
          } else if (playerMsg.beta !== undefined && playerMsg.gamma !== undefined) {
            handleTilt(playerMsg.role, playerMsg.beta, playerMsg.gamma);
          }
        }
        return;
      }
      
      // Handle legacy single-player messages (backward compatibility)
      if (!d.role) return;
      // Only process messages for this room
      if(d.room && String(d.room).toUpperCase() !== ROOM_ID) return;
      // Normalize short role codes to full names
      if (typeof d.role === 'string' && d.role.length === 1) {
        d.role = (
          d.role === 'b' ? 'blue' :
          d.role === 'r' ? 'red' :
          d.role === 'y' ? 'yellow' :
          d.role === 'g' ? 'green' :
          d.role === 'o' ? 'orange' :
          d.role === 'p' ? 'purple' :
          d.role === 'c' ? 'cyan' :
          d.role === 'm' ? 'magenta' :
          d.role
        );
      }
      if (!activeRoles.includes(d.role)) return;
      if (d.orientBeta!==undefined && d.orientGamma!==undefined) {
        handleTilt(d.role, d.orientBeta, d.orientGamma);
      } else if (d.beta!==undefined && d.gamma!==undefined) {
        handleTilt(d.role, d.beta, d.gamma);
      }
    } catch(e){}
  };
  ws.onclose = ()=>{ appendLog('Disconnected'); const rb = document.getElementById('roomBadge'); if(rb) rb.textContent = 'Disconnected'; if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000); };
}).catch(e=>{ appendLog('No backend /api/token'); });

</script>
</body>
</html>
