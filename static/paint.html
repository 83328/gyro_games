<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Paint</title>
<style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background: #0a0a0a;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
  }
  canvas {
    background: #111;
    border: 2px solid #333;
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0,0,0,0.4);
  }
  h1 { margin-top: 36px; }
  #info { margin: 8px; font-size: 1.2em; }
  #scores { margin: 8px; }
</style>
</head>
<body>
  <h1>Paint</h1>
  
  <div id="scores">
  <span id="blueScoreContainer" class="role">Blue <span id="sBlue">0</span></span>
  <span id="redScoreContainer" class="role">Red <span id="sRed">0</span></span>
    <span id="yellowScoreContainer" class="role" style="display:none">Yellow <span id="sYellow">0</span></span>
    <span id="greenScoreContainer" class="role" style="display:none">Green <span id="sGreen">0</span></span>
    <span id="orangeScoreContainer" class="role" style="display:none">Orange <span id="sOrange">0</span></span>
    <span id="purpleScoreContainer" class="role" style="display:none">Purple <span id="sPurple">0</span></span>
    <span id="cyanScoreContainer" class="role" style="display:none">Cyan <span id="sCyan">0</span></span>
    <span id="magentaScoreContainer" class="role" style="display:none">Magenta <span id="sMagenta">0</span></span>
    <button id="restart" style="margin-left:6px">Restart</button>
    <button id="fs" style="margin-left:6px;padding:.3rem .6rem;border-radius:6px;border:none;background:#1f6feb;color:white">Fullscreen</button>
  </div>
  <canvas id="c" width="600" height="600"></canvas>
  <div id="roomBadge" style="position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700">Room: ---</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// runtime-safe logger: attempts to write to #info if present, otherwise falls back to console
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();
const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const orangeScoreContainer = document.getElementById('orangeScoreContainer');
const purpleScoreContainer = document.getElementById('purpleScoreContainer');
const cyanScoreContainer = document.getElementById('cyanScoreContainer');
const magentaScoreContainer = document.getElementById('magentaScoreContainer');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

const colors = {
  blue: '#4ea1ff',
  red: '#ff6b6b',
  yellow: '#ffd86b',
  green: '#8fe58f',
  orange: '#ffae42',
  purple: '#b388ff',
  cyan: '#4deeea',
  magenta: '#ff6bd6'
};
let ws = null;
let activeRoles = ['blue','red'];
let scores = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};
let players = {};
let paintField;
const GRID_SIZE = 10;
let PIX_SIZE = Math.floor(canvas.width / GRID_SIZE);
let FIELD_COLS = GRID_SIZE;
let FIELD_ROWS = GRID_SIZE;

// Initialize empty field
function initField() {
  PIX_SIZE = Math.floor(canvas.width / GRID_SIZE);
  FIELD_COLS = GRID_SIZE;
  FIELD_ROWS = GRID_SIZE;
  paintField = Array(FIELD_ROWS).fill(0).map(() => Array(FIELD_COLS).fill(''));
}

function initPlayers() {
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, Math.max(2, Math.min(8, n)));
  yellowScoreContainer.style.display = (n >= 3) ? '' : 'none';
  greenScoreContainer.style.display = (n >= 4) ? '' : 'none';
  orangeScoreContainer.style.display = (n >= 5) ? '' : 'none';
  purpleScoreContainer.style.display = (n >= 6) ? '' : 'none';
  cyanScoreContainer.style.display = (n >= 7) ? '' : 'none';
  magentaScoreContainer.style.display = (n >= 8) ? '' : 'none';
  players = {};
  // spawn positions: spread out in grid
  for (let i=0;i<activeRoles.length;i++) {
    const role = activeRoles[i];
    // place each player in a different grid cell
    const col = i % GRID_SIZE;
    const row = Math.floor(i / GRID_SIZE);
    players[role] = {
      gridX: col,
      gridY: row,
      x: col * PIX_SIZE + PIX_SIZE/2,
      y: row * PIX_SIZE + PIX_SIZE/2,
      vx: 0, vy: 0,
      lastMoveTime: 0
    };
  }
  initField();
  scores = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};
  sBlue.textContent = 0;
  sRed.textContent = 0;
  sYellow.textContent = 0;
  sGreen.textContent = 0;
  if(sOrange) sOrange.textContent = 0;
  if(sPurple) sPurple.textContent = 0;
  if(sCyan) sCyan.textContent = 0;
  if(sMagenta) sMagenta.textContent = 0;
}
initPlayers();

// Update player count from room meta and reinitialize
function applyPlayerCountFromMeta(n){
  const pc = parseInt(n, 10);
  if (!(pc >= 2 && pc <= 8)) return;
  if (pc === playerCount) return;
  playerCount = pc;
  try {
    const u = new URL(window.location);
    u.searchParams.set('players', playerCount);
    window.history.replaceState({}, '', u);
  } catch(e){}
  initPlayers();
}

function handleTilt(role, beta, gamma) {
  const p = players[role]; if(!p) return;
  
  // Movement cooldown to prevent too rapid movement (200ms between moves)
  const now = Date.now();
  if (now - p.lastMoveTime < 200) return;
  
  // pixelated movement: move one cell per tilt
  // Increased threshold from 5 to 15 degrees for more precise control
  let dx = 0, dy = 0;
  if (Math.abs(gamma) > Math.abs(beta)) {
    dx = gamma > 15 ? 1 : gamma < -15 ? -1 : 0;
  }
  // REVERSE up/down controls: tilting up moves marker down, tilting down moves marker up
  if (Math.abs(beta) > Math.abs(gamma)) {
    dy = beta > 15 ? -1 : beta < -15 ? 1 : 0;
  }
  
  // Only update lastMoveTime if actually moving
  if (dx !== 0 || dy !== 0) {
    // move in grid
    let newX = Math.max(0, Math.min(GRID_SIZE-1, p.gridX + dx));
    let newY = Math.max(0, Math.min(GRID_SIZE-1, p.gridY + dy));
    if (newX !== p.gridX || newY !== p.gridY) {
      p.gridX = newX;
      p.gridY = newY;
      p.x = p.gridX * PIX_SIZE + PIX_SIZE/2;
      p.y = p.gridY * PIX_SIZE + PIX_SIZE/2;
      p.lastMoveTime = now;
    }
  }
}

function update(dt) {
  if(!roundActive) return;
  // paint the cell for each player
  for (const role of activeRoles) {
    const p = players[role];
    if(p.gridX>=0 && p.gridX<FIELD_COLS && p.gridY>=0 && p.gridY<FIELD_ROWS){
      // Gradual fill: store fill progress per cell per player
      if(!paintField[p.gridY][p.gridX] || typeof paintField[p.gridY][p.gridX] === 'string') {
        // Start gradual fill
        paintField[p.gridY][p.gridX] = {owner: role, progress: 0, entryDir: p.entryDir || {dx:0,dy:0}};
      } else if(paintField[p.gridY][p.gridX].owner === role && paintField[p.gridY][p.gridX].progress < 1) {
        // Continue filling
        paintField[p.gridY][p.gridX].progress = Math.min(1, paintField[p.gridY][p.gridX].progress + 0.5);
      } else if(paintField[p.gridY][p.gridX].owner !== role) {
        // Overwrite with new owner, start gradual fill
        paintField[p.gridY][p.gridX] = {owner: role, progress: 0, entryDir: p.entryDir || {dx:0,dy:0}};
      }
    }
  }
}

function draw() {
  // clear entire canvas each frame so restart/overlay doesn't leave artifacts
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw field
  for (let r=0; r<FIELD_ROWS; r++) {
    for (let c=0; c<FIELD_COLS; c++) {
      const cell = paintField[r][c];
      if (cell) {
        let owner, progress, entryDir;
        if(typeof cell === 'string') {
          owner = cell; progress = 1; entryDir = {dx:0,dy:0};
        } else {
          owner = cell.owner; progress = cell.progress; entryDir = cell.entryDir || {dx:0,dy:0};
        }
        ctx.fillStyle = colors[owner];
        // Gradual fill: fill from entry side
        let x = c*PIX_SIZE, y = r*PIX_SIZE;
        let w = PIX_SIZE, h = PIX_SIZE;
  if(progress < 1) {
          if(entryDir.dx === 1) { // entered from left
            ctx.fillRect(x, y, w*progress, h);
          } else if(entryDir.dx === -1) { // entered from right
            ctx.fillRect(x+w-w*progress, y, w*progress, h);
          } else if(entryDir.dy === 1) { // entered from top
            ctx.fillRect(x, y, w, h*progress);
          } else if(entryDir.dy === -1) { // entered from bottom
            ctx.fillRect(x, y+h-h*progress, w, h*progress);
          } else {
            ctx.fillRect(x, y, w*progress, h); // default left to right
          }
        } else {
          // draw a filled rect without stroke to avoid white outlines
          ctx.fillRect(x, y, w, h);
        }
      }
    }
  }
  // draw players as square brushes, always on top
  for (const role of activeRoles) {
    const p = players[role];
    ctx.save();
    // draw player as filled square and a subtle outer stroke only on the player, clipped to the player's rect
    ctx.fillStyle = colors[role];
    ctx.fillRect(p.x-PIX_SIZE/2, p.y-PIX_SIZE/2, PIX_SIZE, PIX_SIZE);
    // subtle outline for player only
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.strokeRect(p.x-PIX_SIZE/2+1, p.y-PIX_SIZE/2+1, PIX_SIZE-2, PIX_SIZE-2);
    ctx.restore();
  }
}

function tallyScores() {
  const count = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};
  for (let r=0; r<FIELD_ROWS; r++) {
    for (let c=0; c<FIELD_COLS; c++) {
      const cell = paintField[r][c];
      let owner = null;
      if (typeof cell === 'string') {
        owner = cell;
      } else if (cell && typeof cell === 'object' && cell.owner) {
        owner = cell.owner;
      }
      if (owner && count[owner] !== undefined) count[owner]++;
    }
  }
  scores = count;
  // Show scores as percentage of total cells, styled in player color
  const total = Math.max(1, FIELD_COLS * FIELD_ROWS);
  for (const role of activeRoles) {
    const scoreSpan = {
      blue: sBlue,
      red: sRed,
      yellow: sYellow,
      green: sGreen,
      orange: sOrange,
      purple: sPurple,
      cyan: sCyan,
      magenta: sMagenta
    }[role];
    const pct = Math.round(((scores[role] || 0) / total) * 100);
    if (scoreSpan) {
      scoreSpan.textContent = `${pct}%`;
      scoreSpan.style.color = colors[role] || '';
      scoreSpan.style.fontWeight = '700';
    }
    // Show score container for all active roles and set color on container as well
    const containerId = role + 'ScoreContainer';
    const container = document.getElementById(containerId);
    if (container) {
      container.style.display = '';
      container.style.color = colors[role];
    }
  }
  // Hide unused score containers
  const allRoles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  for (const role of allRoles) {
    if (!activeRoles.includes(role)) {
      const containerId = role + 'ScoreContainer';
      const container = document.getElementById(containerId);
      if (container) container.style.display = 'none';
    }
  }
}

function loop(now) {
  const dt = 1/60;
  update(dt);
  tallyScores(); // update scores after every update
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
// setInterval(tallyScores, 2000); // update scores every 2s (no longer needed)

// --- Timer and overlay logic ---
let roundTime = 35; // seconds
let timeLeft = roundTime;
let timerInterval = null;
let roundActive = true;
let intermissionInterval = null; // countdown before auto-restart

// Create overlay for winner
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 9998;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '48px';
winOverlay.style.fontWeight = '700';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);

// prominent countdown badge (top-center)
const countdownBadge = document.createElement('div');
countdownBadge.id = 'countdownBadge';
countdownBadge.style.position = 'fixed';
countdownBadge.style.left = '50%';
countdownBadge.style.top = '12px';
countdownBadge.style.transform = 'translateX(-50%)';
countdownBadge.style.background = 'rgba(0,0,0,0.8)';
countdownBadge.style.color = '#fff';
countdownBadge.style.padding = '10px 16px';
countdownBadge.style.borderRadius = '12px';
countdownBadge.style.fontSize = '20px';
countdownBadge.style.fontWeight = '800';
countdownBadge.style.zIndex = 10000;
countdownBadge.style.display = 'none';
document.body.appendChild(countdownBadge);

function showWinOverlay(role) {
  winOverlay.style.background = colors[role] || '#fff';
  winOverlay.textContent = `${role.charAt(0).toUpperCase()+role.slice(1)} wins!`;
  winOverlay.style.display = 'flex';
  setTimeout(()=>{ winOverlay.style.display = 'none'; }, 6000);
}

function startRoundTimer() {
  // Cancel any pending intermission countdown
  if (intermissionInterval) { clearInterval(intermissionInterval); intermissionInterval = null; }
  timeLeft = roundTime;
  roundActive = true;
  if(timerInterval) clearInterval(timerInterval);
  // show prominent countdown badge
  if(countdownBadge) {
    countdownBadge.style.display = '';
    countdownBadge.textContent = `${timeLeft}s`;
  }
  timerInterval = setInterval(()=>{
    timeLeft--;
    // update both small log and prominent badge
    appendLog(`Time left: ${timeLeft}s`);
    if(countdownBadge) countdownBadge.textContent = `${timeLeft}s`;
    if(timeLeft <= 0) {
      clearInterval(timerInterval);
      endRound();
    }
  }, 1000);
  appendLog(`Time left: ${timeLeft}s`);
}

function endRound() {
  roundActive = false;
  tallyScores();
  // Find winner(s)
  let maxScore = -1, winners = [];
  for(const r of activeRoles) {
    if(scores[r] > maxScore) { maxScore = scores[r]; winners = [r]; }
    else if(scores[r] === maxScore) { winners.push(r); }
  }
    if(winners.length === 1) {
    showWinOverlay(winners[0]);
    appendLog(`${winners[0].charAt(0).toUpperCase()+winners[0].slice(1)} wins!`);
  } else {
    winOverlay.style.background = '#fff';
    winOverlay.textContent = `Tie: ${winners.map(r=>r.charAt(0).toUpperCase()+r.slice(1)).join(', ')}!`;
    winOverlay.style.display = 'flex';
    appendLog(`Tie: ${winners.map(r=>r.charAt(0).toUpperCase()+r.slice(1)).join(', ')}`);
    setTimeout(()=>{ winOverlay.style.display = 'none'; }, 6000);
  }
  // Immediately clear the board visuals/state so a new game starts cleanly
  initField();
  draw();

  // Start a 5-second intermission countdown, then auto-restart a new round
  if (intermissionInterval) { clearInterval(intermissionInterval); intermissionInterval = null; }
  let restartIn = 5;
  if (countdownBadge) {
    countdownBadge.style.display = '';
    countdownBadge.textContent = `Next round in ${restartIn}s`;
  }
  intermissionInterval = setInterval(() => {
    restartIn--;
    if (countdownBadge) countdownBadge.textContent = `Next round in ${restartIn}s`;
    if (restartIn <= 0) {
      clearInterval(intermissionInterval);
      intermissionInterval = null;
      // Fully reset players/field and start the new round
      initPlayers();
      winOverlay.style.display = 'none';
      startRoundTimer();
      draw();
    }
  }, 1000);
}

// Restart button logic
document.getElementById('restart').addEventListener('click', ()=>{
  // Cancel any pending intermission countdown
  if (intermissionInterval) { clearInterval(intermissionInterval); intermissionInterval = null; }
  initPlayers();
  // initPlayers already calls initField
  roundActive = true;
  startRoundTimer();
  winOverlay.style.display = 'none';
  draw(); // force redraw to clear field immediately
});

// Fullscreen button logic
document.getElementById('fs').addEventListener('click', ()=>{
  if(!document.fullscreenElement){
    document.documentElement.requestFullscreen?.();
  } else {
    document.exitFullscreen?.();
  }
});

// Start timer on load
startRoundTimer();

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
const ROOM_ID = getRoomId();
// show room badge immediately
const roomBadge = document.getElementById('roomBadge'); if(roomBadge) roomBadge.textContent = `Room ID: ${ROOM_ID}`;

// WebSocket hookup
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  const wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token)+'&room='+ROOM_ID:data.ws_url+'?token='+encodeURIComponent(token)+'&room='+ROOM_ID) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=> {
    appendLog(`Connected, Room ID: ${ROOM_ID}`);
    const rb = document.getElementById('roomBadge'); if(rb) rb.textContent = `Connected — Room ID: ${ROOM_ID}`;
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room ID: ${ROOM_ID}`);
    // Discover and announce room meta
    try { ws.send(JSON.stringify({ type: 'request-meta', t: Date.now() })); } catch(e){}
    try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
  };
  ws.onmessage = ev => {
    try {
      const d = JSON.parse(ev.data);
      if (!d) return;
      if (d.type === 'room-meta' && d.playerCount !== undefined) {
        applyPlayerCountFromMeta(d.playerCount);
        return;
      }
      if (d.type === 'request-meta') {
        try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
        return;
      }
      
      // Handle batch messages (aggregated state from server)
      if (d.type === 'batch' && Array.isArray(d.players)) {
        for (const playerMsg of d.players) {
          if (!playerMsg || !playerMsg.role) continue;
          // Only process messages for this room
          if(playerMsg.room && String(playerMsg.room).toUpperCase() !== ROOM_ID) continue;
          if (!activeRoles.includes(playerMsg.role)) continue;
          
          if (playerMsg.orientBeta !== undefined && playerMsg.orientGamma !== undefined) {
            handleTilt(playerMsg.role, playerMsg.orientBeta, playerMsg.orientGamma);
          } else if (playerMsg.beta !== undefined && playerMsg.gamma !== undefined) {
            handleTilt(playerMsg.role, playerMsg.beta, playerMsg.gamma);
          }
        }
        return;
      }
      
      // Handle legacy single-player messages (backward compatibility)
      if (!d.role) return;
      // Only process messages for this room
      if(d.room && String(d.room).toUpperCase() !== ROOM_ID) return;
      // Normalize short role codes to full names
      if (typeof d.role === 'string' && d.role.length === 1) {
        d.role = (
          d.role === 'b' ? 'blue' :
          d.role === 'r' ? 'red' :
          d.role === 'y' ? 'yellow' :
          d.role === 'g' ? 'green' :
          d.role === 'o' ? 'orange' :
          d.role === 'p' ? 'purple' :
          d.role === 'c' ? 'cyan' :
          d.role === 'm' ? 'magenta' :
          d.role
        );
      }
      if (!activeRoles.includes(d.role)) return;
      if (d.orientBeta!==undefined && d.orientGamma!==undefined) {
        handleTilt(d.role, d.orientBeta, d.orientGamma);
      } else if (d.beta!==undefined && d.gamma!==undefined) {
        handleTilt(d.role, d.beta, d.gamma);
      }
    } catch(e){}
  };
  ws.onclose = ()=>{ appendLog('Disconnected'); const rb = document.getElementById('roomBadge'); if(rb) rb.textContent = 'Disconnected'; if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000); };
}).catch(e=>{ appendLog('No backend /api/token'); });

</script>
</body>
</html>
