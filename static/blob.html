<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blob Eaters</title>
  <style>
    body{font-family:'Segoe UI',Arial,Helvetica,sans-serif;margin:0;padding:0;overflow:hidden;background:#000;color:#fff;display:flex;flex-direction:column;height:100vh}
    canvas{display:block;width:100%;height:100%;background:radial-gradient(ellipse at center, #1a0a2e 0%, #0f051d 50%, #000000 100%);position:absolute;top:0;left:0}
    .hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;align-items:center;z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4)}
    .role{padding:8px 14px;border-radius:10px;background:rgba(255,255,255,0.08);font-weight:600;font-size:14px;transition:all 0.3s ease;border:1px solid rgba(255,255,255,0.1);text-shadow:0 2px 4px rgba(0,0,0,0.5)}
    .role:hover{background:rgba(255,255,255,0.12);transform:translateY(-2px)}
    button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
    button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
    h2{position:fixed;top:70px;left:50%;transform:translateX(-50%);z-index:999;margin:0;font-size:28px;font-weight:700;text-shadow:0 4px 12px rgba(0,0,0,0.8);display:none}
  </style>
</head>
<body>
  <h2 style="margin:12px 0 0 0">Blob Eaters</h2>
  <div class="hud">
    <div class="role">Blue <span id="sBlueSize">0</span>%</div>
    <div class="role">Red <span id="sRedSize">0</span>%</div>
    <div class="role">Yellow <span id="sYellowSize">0</span>%</div>
    <div class="role">Green <span id="sGreenSize">0</span>%</div>
    <div class="role">Orange <span id="sOrangeSize">0</span>%</div>
    <div class="role">Purple <span id="sPurpleSize">0</span>%</div>
    <div class="role">Cyan <span id="sCyanSize">0</span>%</div>
    <div class="role">Magenta <span id="sMagentaSize">0</span>%</div>
    <button id="calib" style="margin-left:8px">Calibrate</button>
    <button id="restart" style="margin-left:6px">Restart</button>
    
  </div>
  <canvas id="c" width="900" height="600"></canvas>
<script>
const CANVAS = document.getElementById('c');
const ctx = CANVAS.getContext('2d');
const restartBtn = document.getElementById('restart');

// Game constants
const ROLES = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
const COLORS = {blue:'#3b82f6', red:'#ef4444', yellow:'#fbbf24', green:'#10b981', orange:'#f97316', purple:'#a855f7', cyan:'#06b6d4', magenta:'#ec4899'};
const COLORS_LIGHT = {blue:'#60a5fa', red:'#f87171', yellow:'#fcd34d', green:'#34d399', orange:'#fb923c', purple:'#c084fc', cyan:'#22d3ee', magenta:'#f472b6'};
let WIDTH = CANVAS.width, HEIGHT = CANVAS.height;

function resizeCanvasToDisplay(){
  // fullscreen canvas
  CANVAS.width = window.innerWidth;
  CANVAS.height = window.innerHeight;
  WIDTH = CANVAS.width; HEIGHT = CANVAS.height;
}
window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

// convert between area and radius
function areaToR(a){ return Math.sqrt(a / Math.PI); }
function rToArea(r){ return Math.PI * r * r; }

// player state
const players = {};
for(const r of ROLES){ const area = rToArea(18); players[r] = {x:Math.random()*WIDTH, y:Math.random()*HEIGHT, vx:0, vy:0, area: area, displayArea: area, lastInput:0, rad: areaToR(area), wanderT: Math.random()*3}; }

// neutral blobs (not player controlled)
const NEUTRAL_COUNT = 10;
const neutrals = [];
function initNeutrals(){
  neutrals.length = 0;
  for(let i=0;i<NEUTRAL_COUNT;i++){
    const baseR = 6 + Math.random()*12; // radius
    const a = rToArea(baseR);
    neutrals.push({x:Math.random()*WIDTH, y:Math.random()*HEIGHT, vx:(Math.random()-0.5)*40, vy:(Math.random()-0.5)*40, area: a, displayArea: a, wanderT: Math.random()*3, rad: areaToR(a)});
  }
}
initNeutrals();

// inputs from websocket per role (initialize for all roles)
const inputs = {blue:null, red:null, yellow:null, green:null, orange:null, purple:null, cyan:null, magenta:null};
// per-role calibration offsets (persisted to localStorage)
let calibrations = {};

function loadCalibrations(){
  try{ const raw = localStorage.getItem('blob_calibrations'); if(raw) calibrations = JSON.parse(raw); }catch(e){ console.warn('loadCalibrations', e); }
}
function saveCalibrations(){
  try{ localStorage.setItem('blob_calibrations', JSON.stringify(calibrations)); }catch(e){ console.warn('saveCalibrations', e); }
}

// spawn positions spread out
function resetGame(){
  // initial sizes per role (radius-based values mapped to area)
  const initSizes = { blue:20, red:20, yellow:18, green:16, orange:16, purple:16, cyan:16, magenta:16 };
  // place players in a 4x2 grid for predictable spread
  const cols = 4;
  for(let i=0;i<ROLES.length;i++){
    const r = ROLES[i];
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = Math.max(20, (col + 0.5) * WIDTH / cols);
    const y = Math.max(20, (row + 0.5) * HEIGHT / 2);
    const a = rToArea(initSizes[r] || 16);
    if(!players[r]) players[r] = { x, y, vx:0, vy:0, area: a, displayArea: a, lastInput:0, rad: areaToR(a) };
  players[r].x = x; players[r].y = y; players[r].vx = 0; players[r].vy = 0; players[r].area = a; players[r].displayArea = a; players[r].lastInput = 0; players[r].rad = areaToR(a); players[r].wanderT = Math.random()*3;
  }
  initNeutrals();
}
resetGame();

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
const ROOM_ID = getRoomId();

// create unified room badge and helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// websocket hookup
let ws = null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  const wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token)+'&room='+ROOM_ID:data.ws_url+'?token='+encodeURIComponent(token)+'&room='+ROOM_ID) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{ const msg = `Connected — Room: ${ROOM_ID}`; if(window.__setRoomBadge) window.__setRoomBadge(msg); else console.log(msg); };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if(!d) return;
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || !playerMsg.role) continue;
          // Only process messages for this room
          if(playerMsg.room && String(playerMsg.room).toUpperCase() !== ROOM_ID) continue;
          if(!inputs[playerMsg.role]) inputs[playerMsg.role] = {rawBeta:0, rawGamma:0, ts:0};
          
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined && playerMsg.orientBeta!==null){
            inputs[playerMsg.role].rawBeta = playerMsg.orientBeta;
            inputs[playerMsg.role].rawGamma = playerMsg.orientGamma;
            inputs[playerMsg.role].ts = Date.now();
          } else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            inputs[playerMsg.role].rawBeta = (inputs[playerMsg.role].rawBeta || 0) + (playerMsg.beta||0)*0.02;
            inputs[playerMsg.role].rawGamma = (inputs[playerMsg.role].rawGamma || 0) + (playerMsg.gamma||0)*0.02;
            inputs[playerMsg.role].ts = Date.now();
          }
        }
      }
    }catch(e){}
  };
  ws.onclose = ()=>{ const msg = 'Disconnected'; if(window.__setRoomBadge) window.__setRoomBadge(msg); else console.log(msg); };
}).catch(e=>{ const msg = 'No backend'; if(window.__setRoomBadge) window.__setRoomBadge(msg); else console.log(msg); });

// keyboard fallback for testing
window.addEventListener('keydown', (ev)=>{
  // WASD control blue
  if(ev.key==='w') inputs.blue = inputs.blue || {}; inputs.blue.rawBeta = -20; inputs.blue.ts = Date.now();
  if(ev.key==='s') inputs.blue.rawBeta = 20; inputs.blue.ts = Date.now();
  if(ev.key==='a') inputs.blue.rawGamma = -20; inputs.blue.ts = Date.now();
  if(ev.key==='d') inputs.blue.rawGamma = 20; inputs.blue.ts = Date.now();
});

// AI constants
const INPUT_TIMEOUT = 1200; // ms before AI takes over
const MAX_SPEED = 160; // px/s when large this is scaled

function aiStep(role, dt){
  // simple behavior: pick nearest other blob as target
  const me = players[role];
  let nearest = null, nd = 1e9;
  for(const r of ROLES){ if(r===role) continue; const p = players[r]; const d = (p.x-me.x)*(p.x-me.x)+(p.y-me.y)*(p.y-me.y); if(d<nd){ nd=d; nearest=r; }}
  if(!nearest) return {beta:0,gamma:0};
  const target = players[nearest];
  const dx = target.x - me.x, dy = target.y - me.y; const dist = Math.hypot(dx,dy)||1;
  // if target is smaller, seek; else flee
  const seek = (me.area > target.area*1.05);
  const desiredV = Math.min(MAX_SPEED, 80 + 0.5*(Math.sqrt(me.area))); // scale a bit
  const vx = (dx/dist) * (seek? desiredV : -desiredV);
  const vy = (dy/dist) * (seek? desiredV : -desiredV);
  return {vx, vy};
}

function mapInputToVelocity(role){
  // map inputs rawBeta/rawGamma to velocity vector
  const inp = inputs[role];
  if(!inp) return {vx:0, vy:0};
  // apply calibration offsets when available
  const cal = calibrations[role] || {};
  const beta = (inp.rawBeta || 0) - (cal.beta || 0);
  const gamma = (inp.rawGamma || 0) - (cal.gamma || 0);
  // beta: forward/back -> y, gamma: left/right -> x. Use simple scaling
  const REF = 35;
  const nx = Math.max(-1, Math.min(1, (gamma/REF)));
  // invert vertical mapping: tilt forward produces negative beta on some devices,
  // flip sign here to invert up/down controls as requested
  const ny = Math.max(-1, Math.min(1, -(beta/REF)));
  const speed = 140; // base
  return {vx: nx * speed, vy: ny * speed};
}

function step(dt){
  // dt in seconds
  // update each role
  for(const r of ROLES){
    const p = players[r];
    const now = Date.now();
    const hasInput = inputs[r] && (now - inputs[r].ts) < INPUT_TIMEOUT;
    if(hasInput){
      const targ = mapInputToVelocity(r);
      // smooth toward target
      p.vx += (targ.vx - p.vx) * Math.min(1, dt*6);
      p.vy += (targ.vy - p.vy) * Math.min(1, dt*6);
    } else {
      // No active input: if this player has no input object (never connected), behave like a neutral (wander).
      if(!inputs[r]){
        p.wanderT -= dt;
        if(p.wanderT <= 0){ p.wanderT = 1 + Math.random()*3; p.vx += (Math.random()-0.5)*80; p.vy += (Math.random()-0.5)*80; }
      } else {
        // AI: when client existed but input timed out, run AI targeting behavior
        const ai = aiStep(r, dt);
        p.vx += (ai.vx - p.vx) * Math.min(1, dt*2);
        p.vy += (ai.vy - p.vy) * Math.min(1, dt*2);
      }
    }
    // move
    p.x += p.vx * dt; p.y += p.vy * dt;
    // keep inside bounds with bounce
  const rad = p.rad || areaToR(p.area);
    if(p.x - rad < 0){ p.x = rad; p.vx *= -0.6; }
    if(p.x + rad > WIDTH){ p.x = WIDTH - rad; p.vx *= -0.6; }
    if(p.y - rad < 0){ p.y = rad; p.vy *= -0.6; }
    if(p.y + rad > HEIGHT){ p.y = HEIGHT - rad; p.vy *= -0.6; }
    // small anti-stuck nudge: if the blob slowed to near-zero and is touching an edge, push it inward
    const pSpeed = Math.hypot(p.vx, p.vy);
    if(pSpeed < 6){
      const nudge = 24 + Math.random()*36;
      if(p.x - rad <= 1) p.vx = Math.abs(p.vx) + nudge;
      if(p.x + rad >= WIDTH - 1) p.vx = - (Math.abs(p.vx) + nudge);
      if(p.y - rad <= 1) p.vy = Math.abs(p.vy) + nudge;
      if(p.y + rad >= HEIGHT - 1) p.vy = - (Math.abs(p.vy) + nudge);
    }
    // smooth displayed area for animation
    p.displayArea += (p.area - p.displayArea) * Math.min(1, dt*6);
  }
  // update HUD percentages for players (0-100 normalized by displayed area)
  try{
    const total = ROLES.reduce((s,r)=>s + (players[r].displayArea||0), 0) || 1;
    const ids = {
      blue:'sBlueSize', red:'sRedSize', yellow:'sYellowSize', green:'sGreenSize',
      orange:'sOrangeSize', purple:'sPurpleSize', cyan:'sCyanSize', magenta:'sMagentaSize'
    };
    for(const r of ROLES){ const pct = Math.round((players[r].displayArea/total)*100); const el = document.getElementById(ids[r]); if(el) el.textContent = String(pct); }
  }catch(e){ /* ignore HUD errors */ }
  // update neutrals
  for(const n of neutrals){
    // wander
    n.wanderT -= dt;
    if(n.wanderT <= 0){ n.wanderT = 1 + Math.random()*3; n.vx += (Math.random()-0.5)*80; n.vy += (Math.random()-0.5)*80; }
    n.x += n.vx * dt; n.y += n.vy * dt;
  const rad = n.rad || areaToR(n.area);
    if(n.x - rad < 0){ n.x = rad; n.vx *= -0.6; }
    if(n.x + rad > WIDTH){ n.x = WIDTH - rad; n.vx *= -0.6; }
    if(n.y - rad < 0){ n.y = rad; n.vy *= -0.6; }
    if(n.y + rad > HEIGHT){ n.y = HEIGHT - rad; n.vy *= -0.6; }
    // prevent neutrals from sticking to edges/corners: if velocity is very small after bounce and position is near boundary, give a randomized inward nudge
    const nSpeed = Math.hypot(n.vx, n.vy);
    if(nSpeed < 8){
      const nudge = 20 + Math.random()*40;
      if(n.x - rad <= 1) n.vx = Math.abs(n.vx) + nudge;
      if(n.x + rad >= WIDTH - 1) n.vx = - (Math.abs(n.vx) + nudge);
      if(n.y - rad <= 1) n.vy = Math.abs(n.vy) + nudge;
      if(n.y + rad >= HEIGHT - 1) n.vy = - (Math.abs(n.vy) + nudge);
    }
    n.displayArea += (n.area - n.displayArea) * Math.min(1, dt*4);
  }
  // collisions and eating
  // global, create once
  const _all = [];
  _all.length = 0;
  for(const r of ROLES) _all.push(players[r]);
  for(let i=0;i<neutrals.length;i++) _all.push(neutrals[i]);

  for(let i=0;i<_all.length;i++){
    for(let j=i+1;j<_all.length;j++){
      const A = _all[i], B = _all[j];
      const dx = B.x - A.x, dy = B.y - A.y;
      const rA = A.rad || Math.sqrt(A.area/Math.PI);
      const rB = B.rad || Math.sqrt(B.area/Math.PI);
      const rsum = rA + rB;
      const rsum2 = rsum*rsum;
      const d2 = dx*dx + dy*dy;
      if(d2 < rsum2){
        const d = Math.sqrt(d2 || 0.0001);
        // overlap: compute transfer and stronger physical push/impulse
        const overlap = (rA + rB - d) || 0.001;
        // safe normal
        let nx = 1, ny = 0;
        if(d > 0){ nx = dx / d; ny = dy / d; } else { // perfect overlap, pick random direction
          nx = Math.random()*2-1; ny = Math.random()*2-1; const L = Math.hypot(nx,ny)||1; nx/=L; ny/=L;
        }
        // masses ~ area (clamped)
        const massA = Math.max(1, A.area);
        const massB = Math.max(1, B.area);
        // positional push multiplier: stronger separation
        const pushMultiplier = 1.2;
        const push = overlap * pushMultiplier;
        // velocity impulse factor (tunable)
        const impulseFactor = 2.0;
        const impulse = overlap * impulseFactor;

        if(A.area > B.area * 1.02){
          const transfer = Math.min(B.area*0.35, A.area*0.12);
          A.area += transfer; A.rad = Math.sqrt(A.area/Math.PI);
          B.area = Math.max(8, B.area - transfer); B.rad = Math.sqrt(B.area/Math.PI);
          // separate more strongly
          A.x -= nx * push; A.y -= ny * push; B.x += nx * push; B.y += ny * push;
          // apply velocity impulse so the larger blob pushes the smaller
          A.vx -= nx * impulse * (massB/(massA+massB)); A.vy -= ny * impulse * (massB/(massA+massB));
          B.vx += nx * impulse * (massA/(massA+massB)); B.vy += ny * impulse * (massA/(massA+massB));
        } else if(B.area > A.area * 1.02){
          const transfer = Math.min(A.area*0.35, B.area*0.12);
          B.area += transfer; B.rad = Math.sqrt(B.area/Math.PI);
          A.area = Math.max(8, A.area - transfer); A.rad = Math.sqrt(A.area/Math.PI);
          A.x -= nx * push; A.y -= ny * push; B.x += nx * push; B.y += ny * push;
          A.vx -= nx * impulse * (massB/(massA+massB)); A.vy -= ny * impulse * (massB/(massA+massB));
          B.vx += nx * impulse * (massA/(massA+massB)); B.vy += ny * impulse * (massA/(massA+massB));
        } else {
          // similar sizes -> stronger bounce
          const relx = (B.vx - A.vx), rely = (B.vy - A.vy);
          const sep = (relx*nx + rely*ny);
          const bounceFactor = 0.6;
          A.vx -= nx * sep * bounceFactor; A.vy -= ny * sep * bounceFactor;
          B.vx += nx * sep * bounceFactor; B.vy += ny * sep * bounceFactor;
          // also separate positions a bit more
          A.x -= nx * push * 0.5; A.y -= ny * push * 0.5; B.x += nx * push * 0.5; B.y += ny * push * 0.5;
        }
      }
    }
  }
}

function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  // compute total displayed area of players + neutrals for percentage calculation
  const totalDisplay = ROLES.reduce((s, rr) => s + (players[rr].displayArea || 0), 0) + neutrals.reduce((s, n) => s + (n.displayArea || 0), 0) || 1;

  // draw players with enhanced graphics
  for(const r of ROLES){
    const p = players[r]; const rad = areaToR(p.displayArea);
    
    // outer glow (multi-layer for smoother effect)
    ctx.globalAlpha = 0.15;
    ctx.beginPath();
    const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, rad * 2.2);
    glow.addColorStop(0, COLORS_LIGHT[r]);
    glow.addColorStop(0.5, COLORS[r]);
    glow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = glow;
    ctx.arc(p.x, p.y, rad * 2.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // main blob with gradient
    ctx.beginPath();
    const grad = ctx.createRadialGradient(p.x - rad * 0.3, p.y - rad * 0.3, rad * 0.1, p.x, p.y, rad);
    grad.addColorStop(0, COLORS_LIGHT[r]);
    grad.addColorStop(0.7, COLORS[r]);
    grad.addColorStop(1, COLORS[r]);
    ctx.fillStyle = grad;
    ctx.arc(p.x, p.y, rad, 0, Math.PI * 2);
    ctx.fill();
    
    // glossy highlight
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    const highlight = ctx.createRadialGradient(p.x - rad * 0.35, p.y - rad * 0.35, 0, p.x - rad * 0.35, p.y - rad * 0.35, rad * 0.5);
    highlight.addColorStop(0, 'rgba(255,255,255,0.9)');
    highlight.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = highlight;
    ctx.arc(p.x - rad * 0.25, p.y - rad * 0.25, rad * 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // subtle outline
    ctx.beginPath();
    ctx.arc(p.x, p.y, rad, 0, Math.PI * 2);
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.stroke();
    
    // centered percentage label
    const pct = Math.round((p.displayArea / totalDisplay) * 100);
    const sizeText = String(pct);
    if(rad > 12){
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.font = `bold ${Math.max(12, Math.min(24, Math.round(rad * 0.5)))}px 'Segoe UI', Arial`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur = 4;
      ctx.fillText(sizeText, p.x, p.y);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'start'; ctx.textBaseline = 'alphabetic';
    }
  }
  
  // draw neutrals with enhanced graphics
  for(const n of neutrals){
    const rad = areaToR(n.displayArea);
    
    // soft glow
    ctx.globalAlpha = 0.1;
    ctx.beginPath();
    const nGlow = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, rad * 1.8);
    nGlow.addColorStop(0, '#fff');
    nGlow.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = nGlow;
    ctx.arc(n.x, n.y, rad * 1.8, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // main neutral blob with gradient
    ctx.beginPath();
    const nGrad = ctx.createRadialGradient(n.x - rad * 0.3, n.y - rad * 0.3, rad * 0.1, n.x, n.y, rad);
    nGrad.addColorStop(0, '#f3f4f6');
    nGrad.addColorStop(0.7, '#d1d5db');
    nGrad.addColorStop(1, '#9ca3af');
    ctx.fillStyle = nGrad;
    ctx.arc(n.x, n.y, rad, 0, Math.PI * 2);
    ctx.fill();
    
    // highlight
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    const nHighlight = ctx.createRadialGradient(n.x - rad * 0.35, n.y - rad * 0.35, 0, n.x - rad * 0.35, n.y - rad * 0.35, rad * 0.4);
    nHighlight.addColorStop(0, 'rgba(255,255,255,1)');
    nHighlight.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = nHighlight;
    ctx.arc(n.x - rad * 0.25, n.y - rad * 0.25, rad * 0.35, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // outline
    ctx.beginPath();
    ctx.arc(n.x, n.y, rad, 0, Math.PI * 2);
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.stroke();
    
    // neutral percentage label
    const npct = Math.round((n.displayArea / totalDisplay) * 100);
    if(rad > 12){
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.font = `bold ${Math.max(10, Math.min(16, Math.round(rad * 0.45)))}px 'Segoe UI', Arial`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,0.3)';
      ctx.shadowBlur = 3;
      ctx.fillText(String(npct), n.x, n.y);
      ctx.shadowBlur = 0;
      ctx.textAlign = 'start'; ctx.textBaseline = 'alphabetic';
    }
  }
}

let last = performance.now();
const HUD_IDS = { blue:'sBlueSize', red:'sRedSize', yellow:'sYellowSize', green:'sGreenSize', orange:'sOrangeSize', purple:'sPurpleSize', cyan:'sCyanSize', magenta:'sMagentaSize' };
const hudEls = {};
for(const r of ROLES) hudEls[r] = document.getElementById(HUD_IDS[r]);
let hudTimer = 0;
// Winner splash state and overlay
let splashActive = false;
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 10001;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '52px';
winOverlay.style.fontWeight = '800';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);

function showWinnerSplash(role){
  if(splashActive) return;
  splashActive = true;
  const color = COLORS[role] || '#000';
  winOverlay.style.background = color;
  // pick readable text color based on luminance
  let hex = (color.replace('#',''));
  let r=0,g=0,b=0;
  try{ r = parseInt(hex.substring(0,2),16); g = parseInt(hex.substring(2,4),16); b = parseInt(hex.substring(4,6),16); }catch(e){}
  const lum = 0.2126*r + 0.7152*g + 0.0722*b;
  winOverlay.style.color = (lum > 170) ? '#001' : '#fff';
  winOverlay.textContent = `${role.charAt(0).toUpperCase() + role.slice(1)} wins!`;
  winOverlay.style.display = 'flex';
  // After 3s hide and restart
  setTimeout(()=>{
    winOverlay.style.display = 'none';
    splashActive = false;
    resetGame();
  }, 3000);
}
function frame(now){
  const dt = Math.min(60, now - last)/1000; last = now;
  // If a winner splash is active, pause game updates but keep drawing so overlay shows
  if(!splashActive) step(dt);
  draw();
  hudTimer += dt;
  if(hudTimer > 0.25){ updateHudSizes(); hudTimer = 0; }
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// calibration button
const calibBtn = document.getElementById('calib');
calibBtn.addEventListener('click', ()=>{
  // capture current raw inputs as zero for each role that has input
  for(const r of ROLES){
    const inp = inputs[r];
    if(inp){
      calibrations[r] = { beta: inp.rawBeta || 0, gamma: inp.rawGamma || 0 };
    }
  }
  saveCalibrations();
  const msg1 = 'Calibrated'; if(window.__setRoomBadge) window.__setRoomBadge(msg1); else console.log(msg1);
  setTimeout(()=>{ const msg2 = `Connected — Room: ${ROOM_ID}`; if(window.__setRoomBadge) window.__setRoomBadge(msg2); else console.log(msg2); }, 1200);
});

restartBtn.addEventListener('click', ()=>{ resetGame(); console.log('Restarted'); });

function updateHudSizes(){
  try{
    const total = ROLES.reduce((s,r)=>s + (players[r].displayArea||0), 0) || 1;
    for(const r of ROLES){
      const pct = Math.round((players[r].displayArea/total)*100);
      const el = hudEls[r];
      if(el) {
        el.textContent = String(pct);
        // Set color of parent .role div
        if(el.parentElement) el.parentElement.style.color = COLORS[r];
        // trigger winner splash if threshold exceeded
        if(pct > 90 && !splashActive){ showWinnerSplash(r); }//winner size needed
      }
    }
  }catch(e){}
}

// ensure HUD updates immediately after initial reset and on manual restart
updateHudSizes();

// load any persisted calibrations
loadCalibrations();

function makeSpatialHash(cellSize){
  return {
    cellSize,
    map: new Map(),
    clear(){ this.map.clear(); },
    key(x,y){ return `${x},${y}`; },
    add(obj){
      const cx = Math.floor(obj.x / this.cellSize);
      const cy = Math.floor(obj.y / this.cellSize);
      const k = `${cx},${cy}`;
      if(!this.map.has(k)) this.map.set(k, []);
      this.map.get(k).push(obj);
    },
    queryNeighbors(obj){
      const cx = Math.floor(obj.x / this.cellSize);
      const cy = Math.floor(obj.y / this.cellSize);
      let neighbors = [];
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          const k = `${cx+dx},${cy+dy}`;
          if(this.map.has(k)) neighbors = neighbors.concat(this.map.get(k));
        }
      }
      return neighbors;
    }
  };
}
// Use: build hash each frame, then for each object check only neighbors
</script>
</body>
</html>
