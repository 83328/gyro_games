<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Blob Eaters</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:0;display:flex;flex-direction:column;align-items:center;background:#0b0b12;color:#eef}
    canvas{background:linear-gradient(#022,#001);border:2px solid #224;margin:12px}
    .hud{display:flex;gap:12px;align-items:center}
    .role{padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.03)}
  </style>
</head>
<body>
  <h2 style="margin:12px 0 0 0">Blob Eaters</h2>
  <div class="hud">
    <div class="role">Blue <span id="sBlueSize">0</span>%</div>
    <div class="role">Red <span id="sRedSize">0</span>%</div>
    <div class="role">Yellow <span id="sYellowSize">0</span>%</div>
    <div class="role">Green <span id="sGreenSize">0</span>%</div>
    <div class="role">Orange <span id="sOrangeSize">0</span>%</div>
    <div class="role">Purple <span id="sPurpleSize">0</span>%</div>
    <div class="role">Cyan <span id="sCyanSize">0</span>%</div>
    <div class="role">Magenta <span id="sMagentaSize">0</span>%</div>
    <button id="calib" style="margin-left:8px">Calibrate</button>
    <button id="restart" style="margin-left:6px">Restart</button>
    <div id="status" style="margin-left:8px">Connecting...</div>
  </div>
  <canvas id="c" width="900" height="600"></canvas>
<script>
const CANVAS = document.getElementById('c');
const ctx = CANVAS.getContext('2d');
const statusEl = document.getElementById('status');
const restartBtn = document.getElementById('restart');

// Game constants
const ROLES = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
const COLORS = {blue:'#4ea1ff', red:'#ff6b6b', yellow:'#ffd86b', green:'#8fe58f', orange:'#ff9f4d', purple:'#b58cff', cyan:'#4de6e6', magenta:'#ff6bff'};
let WIDTH = CANVAS.width, HEIGHT = CANVAS.height;

function resizeCanvasToDisplay(){
  // fit canvas to available space but keep aspect ratio approx 16:9
  const pad = 24;
  const w = Math.min(window.innerWidth - pad, 1400);
  const h = Math.min(window.innerHeight - pad - 120, 1000);
  CANVAS.width = Math.max(400, Math.floor(w));
  CANVAS.height = Math.max(300, Math.floor(h));
  WIDTH = CANVAS.width; HEIGHT = CANVAS.height;
}
window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

// convert between area and radius
function areaToR(a){ return Math.sqrt(a / Math.PI); }
function rToArea(r){ return Math.PI * r * r; }

// player state
const players = {};
for(const r of ROLES){ players[r] = {x:Math.random()*WIDTH, y:Math.random()*HEIGHT, vx:0, vy:0, area: rToArea(18), displayArea: rToArea(18), lastInput:0}; }

// neutral blobs (not player controlled)
const NEUTRAL_COUNT = 10;
const neutrals = [];
function initNeutrals(){
  neutrals.length = 0;
  for(let i=0;i<NEUTRAL_COUNT;i++){
    const baseR = 6 + Math.random()*12; // radius
    const a = rToArea(baseR);
    neutrals.push({x:Math.random()*WIDTH, y:Math.random()*HEIGHT, vx:(Math.random()-0.5)*40, vy:(Math.random()-0.5)*40, area: a, displayArea: a, wanderT: Math.random()*3});
  }
}
initNeutrals();

// inputs from websocket per role (initialize for all roles)
const inputs = {blue:null, red:null, yellow:null, green:null, orange:null, purple:null, cyan:null, magenta:null};
// per-role calibration offsets (persisted to localStorage)
let calibrations = {};

function loadCalibrations(){
  try{ const raw = localStorage.getItem('blob_calibrations'); if(raw) calibrations = JSON.parse(raw); }catch(e){ console.warn('loadCalibrations', e); }
}
function saveCalibrations(){
  try{ localStorage.setItem('blob_calibrations', JSON.stringify(calibrations)); }catch(e){ console.warn('saveCalibrations', e); }
}

// spawn positions spread out
function resetGame(){
  // initial sizes per role (radius-based values mapped to area)
  const initSizes = { blue:20, red:20, yellow:18, green:16, orange:16, purple:16, cyan:16, magenta:16 };
  // place players in a 4x2 grid for predictable spread
  const cols = 4;
  for(let i=0;i<ROLES.length;i++){
    const r = ROLES[i];
    const col = i % cols;
    const row = Math.floor(i / cols);
    const x = Math.max(20, (col + 0.5) * WIDTH / cols);
    const y = Math.max(20, (row + 0.5) * HEIGHT / 2);
    if(!players[r]) players[r] = { x, y, vx:0, vy:0, area: rToArea(initSizes[r] || 16), displayArea: rToArea(initSizes[r] || 16), lastInput:0 };
    players[r].x = x; players[r].y = y; players[r].vx = 0; players[r].vy = 0; players[r].area = rToArea(initSizes[r] || 16); players[r].displayArea = players[r].area; players[r].lastInput = 0;
  }
  initNeutrals();
}
resetGame();

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
const ROOM_ID = getRoomId();

// websocket hookup
let ws = null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  const wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token)+'&room='+ROOM_ID:data.ws_url+'?token='+encodeURIComponent(token)+'&room='+ROOM_ID) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{ statusEl.textContent = 'Connected'; };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if(!d || !d.role) return;
      // Only process messages for this room
      if(d.room && String(d.room).toUpperCase() !== ROOM_ID) return;
      // normalize short role codes (b/r/y/g/o/p/c/m -> blue/red/yellow/green/orange/purple/cyan/magenta)
      if(typeof d.role === 'string' && d.role.length===1){
        d.role = (
          d.role === 'b' ? 'blue' :
          d.role === 'r' ? 'red' :
          d.role === 'y' ? 'yellow' :
          d.role === 'g' ? 'green' :
          d.role === 'o' ? 'orange' :
          d.role === 'p' ? 'purple' :
          d.role === 'c' ? 'cyan' :
          d.role === 'm' ? 'magenta' : d.role
        );
      }
      // store orientation if provided, else integrate beta/gamma
      const t = Date.now();
      if(!inputs[d.role]) inputs[d.role] = {rawBeta:0, rawGamma:0, ts:0};
      if(d.orientBeta!==undefined && d.orientGamma!==undefined && d.orientBeta!==null){
        inputs[d.role].rawBeta = d.orientBeta; inputs[d.role].rawGamma = d.orientGamma; inputs[d.role].ts = t;
      } else if(d.beta!==undefined && d.gamma!==undefined){
        // integrate small amount
        inputs[d.role].rawBeta = (inputs[d.role].rawBeta || 0) + (d.beta||0)*0.02;
        inputs[d.role].rawGamma = (inputs[d.role].rawGamma || 0) + (d.gamma||0)*0.02;
        inputs[d.role].ts = t;
      }
    }catch(e){}
  };
  ws.onclose = ()=>{ statusEl.textContent = 'Disconnected'; };
}).catch(e=>{ statusEl.textContent = 'No backend'; });

// keyboard fallback for testing
window.addEventListener('keydown', (ev)=>{
  // WASD control blue
  if(ev.key==='w') inputs.blue = inputs.blue || {}; inputs.blue.rawBeta = -20; inputs.blue.ts = Date.now();
  if(ev.key==='s') inputs.blue.rawBeta = 20; inputs.blue.ts = Date.now();
  if(ev.key==='a') inputs.blue.rawGamma = -20; inputs.blue.ts = Date.now();
  if(ev.key==='d') inputs.blue.rawGamma = 20; inputs.blue.ts = Date.now();
});

// AI constants
const INPUT_TIMEOUT = 1200; // ms before AI takes over
const MAX_SPEED = 160; // px/s when large this is scaled

function aiStep(role, dt){
  // simple behavior: pick nearest other blob as target
  const me = players[role];
  let nearest = null, nd = 1e9;
  for(const r of ROLES){ if(r===role) continue; const p = players[r]; const d = (p.x-me.x)*(p.x-me.x)+(p.y-me.y)*(p.y-me.y); if(d<nd){ nd=d; nearest=r; }}
  if(!nearest) return {beta:0,gamma:0};
  const target = players[nearest];
  const dx = target.x - me.x, dy = target.y - me.y; const dist = Math.hypot(dx,dy)||1;
  // if target is smaller, seek; else flee
  const seek = (me.area > target.area*1.05);
  const desiredV = Math.min(MAX_SPEED, 80 + 0.5*(Math.sqrt(me.area))); // scale a bit
  const vx = (dx/dist) * (seek? desiredV : -desiredV);
  const vy = (dy/dist) * (seek? desiredV : -desiredV);
  return {vx, vy};
}

function mapInputToVelocity(role){
  // map inputs rawBeta/rawGamma to velocity vector
  const inp = inputs[role];
  if(!inp) return {vx:0, vy:0};
  // apply calibration offsets when available
  const cal = calibrations[role] || {};
  const beta = (inp.rawBeta || 0) - (cal.beta || 0);
  const gamma = (inp.rawGamma || 0) - (cal.gamma || 0);
  // beta: forward/back -> y, gamma: left/right -> x. Use simple scaling
  const REF = 35;
  const nx = Math.max(-1, Math.min(1, (gamma/REF)));
  // invert vertical mapping: tilt forward produces negative beta on some devices,
  // flip sign here to invert up/down controls as requested
  const ny = Math.max(-1, Math.min(1, -(beta/REF)));
  const speed = 140; // base
  return {vx: nx * speed, vy: ny * speed};
}

function step(dt){
  // dt in seconds
  // update each role
  for(const r of ROLES){
    const p = players[r];
    const now = Date.now();
    const hasInput = inputs[r] && (now - inputs[r].ts) < INPUT_TIMEOUT;
    if(hasInput){
      const targ = mapInputToVelocity(r);
      // smooth toward target
      p.vx += (targ.vx - p.vx) * Math.min(1, dt*6);
      p.vy += (targ.vy - p.vy) * Math.min(1, dt*6);
    } else {
      // AI
      const ai = aiStep(r, dt);
      p.vx += (ai.vx - p.vx) * Math.min(1, dt*2);
      p.vy += (ai.vy - p.vy) * Math.min(1, dt*2);
    }
    // move
    p.x += p.vx * dt; p.y += p.vy * dt;
    // keep inside bounds with bounce
    const rad = areaToR(p.area);
    if(p.x - rad < 0){ p.x = rad; p.vx *= -0.6; }
    if(p.x + rad > WIDTH){ p.x = WIDTH - rad; p.vx *= -0.6; }
    if(p.y - rad < 0){ p.y = rad; p.vy *= -0.6; }
    if(p.y + rad > HEIGHT){ p.y = HEIGHT - rad; p.vy *= -0.6; }
    // small anti-stuck nudge: if the blob slowed to near-zero and is touching an edge, push it inward
    const pSpeed = Math.hypot(p.vx, p.vy);
    if(pSpeed < 6){
      const nudge = 24 + Math.random()*36;
      if(p.x - rad <= 1) p.vx = Math.abs(p.vx) + nudge;
      if(p.x + rad >= WIDTH - 1) p.vx = - (Math.abs(p.vx) + nudge);
      if(p.y - rad <= 1) p.vy = Math.abs(p.vy) + nudge;
      if(p.y + rad >= HEIGHT - 1) p.vy = - (Math.abs(p.vy) + nudge);
    }
    // smooth displayed area for animation
    p.displayArea += (p.area - p.displayArea) * Math.min(1, dt*6);
  }
  // update HUD percentages for players (0-100 normalized by displayed area)
  try{
    const total = ROLES.reduce((s,r)=>s + (players[r].displayArea||0), 0) || 1;
    const ids = {
      blue:'sBlueSize', red:'sRedSize', yellow:'sYellowSize', green:'sGreenSize',
      orange:'sOrangeSize', purple:'sPurpleSize', cyan:'sCyanSize', magenta:'sMagentaSize'
    };
    for(const r of ROLES){ const pct = Math.round((players[r].displayArea/total)*100); const el = document.getElementById(ids[r]); if(el) el.textContent = String(pct); }
  }catch(e){ /* ignore HUD errors */ }
  // update neutrals
  for(const n of neutrals){
    // wander
    n.wanderT -= dt;
    if(n.wanderT <= 0){ n.wanderT = 1 + Math.random()*3; n.vx += (Math.random()-0.5)*80; n.vy += (Math.random()-0.5)*80; }
    n.x += n.vx * dt; n.y += n.vy * dt;
    const rad = areaToR(n.area);
    if(n.x - rad < 0){ n.x = rad; n.vx *= -0.6; }
    if(n.x + rad > WIDTH){ n.x = WIDTH - rad; n.vx *= -0.6; }
    if(n.y - rad < 0){ n.y = rad; n.vy *= -0.6; }
    if(n.y + rad > HEIGHT){ n.y = HEIGHT - rad; n.vy *= -0.6; }
    // prevent neutrals from sticking to edges/corners: if velocity is very small after bounce and position is near boundary, give a randomized inward nudge
    const nSpeed = Math.hypot(n.vx, n.vy);
    if(nSpeed < 8){
      const nudge = 20 + Math.random()*40;
      if(n.x - rad <= 1) n.vx = Math.abs(n.vx) + nudge;
      if(n.x + rad >= WIDTH - 1) n.vx = - (Math.abs(n.vx) + nudge);
      if(n.y - rad <= 1) n.vy = Math.abs(n.vy) + nudge;
      if(n.y + rad >= HEIGHT - 1) n.vy = - (Math.abs(n.vy) + nudge);
    }
    n.displayArea += (n.area - n.displayArea) * Math.min(1, dt*4);
  }
  // collisions and eating
  // combine players and neutrals into an array for collision checks
  const all = ROLES.map(r=>({role:r, obj:players[r]})).concat(neutrals.map((n,i)=>({role:'neutral'+i, obj:n})));
  for(let i=0;i<all.length;i++){
    for(let j=i+1;j<all.length;j++){
      const A = all[i].obj, B = all[j].obj;
      const dx = B.x - A.x, dy = B.y - A.y; const d = Math.hypot(dx,dy);
      const rA = areaToR(A.area), rB = areaToR(B.area);
      if(d < rA + rB){
        // overlap: compute transfer and stronger physical push/impulse
        const overlap = (rA + rB - d) || 0.001;
        // safe normal
        let nx = 1, ny = 0;
        if(d > 0){ nx = dx / d; ny = dy / d; } else { // perfect overlap, pick random direction
          nx = Math.random()*2-1; ny = Math.random()*2-1; const L = Math.hypot(nx,ny)||1; nx/=L; ny/=L;
        }
        // masses ~ area (clamped)
        const massA = Math.max(1, A.area);
        const massB = Math.max(1, B.area);
        // positional push multiplier: stronger separation
        const pushMultiplier = 1.2;
        const push = overlap * pushMultiplier;
        // velocity impulse factor (tunable)
        const impulseFactor = 2.0;
        const impulse = overlap * impulseFactor;

        if(A.area > B.area * 1.02){
          const transfer = Math.min(B.area*0.35, A.area*0.12);
          A.area += transfer; B.area = Math.max(8, B.area - transfer);
          // separate more strongly
          A.x -= nx * push; A.y -= ny * push; B.x += nx * push; B.y += ny * push;
          // apply velocity impulse so the larger blob pushes the smaller
          A.vx -= nx * impulse * (massB/(massA+massB)); A.vy -= ny * impulse * (massB/(massA+massB));
          B.vx += nx * impulse * (massA/(massA+massB)); B.vy += ny * impulse * (massA/(massA+massB));
        } else if(B.area > A.area * 1.02){
          const transfer = Math.min(A.area*0.35, B.area*0.12);
          B.area += transfer; A.area = Math.max(8, A.area - transfer);
          A.x -= nx * push; A.y -= ny * push; B.x += nx * push; B.y += ny * push;
          A.vx -= nx * impulse * (massB/(massA+massB)); A.vy -= ny * impulse * (massB/(massA+massB));
          B.vx += nx * impulse * (massA/(massA+massB)); B.vy += ny * impulse * (massA/(massA+massB));
        } else {
          // similar sizes -> stronger bounce
          const relx = (B.vx - A.vx), rely = (B.vy - A.vy);
          const sep = (relx*nx + rely*ny);
          const bounceFactor = 0.6;
          A.vx -= nx * sep * bounceFactor; A.vy -= ny * sep * bounceFactor;
          B.vx += nx * sep * bounceFactor; B.vy += ny * sep * bounceFactor;
          // also separate positions a bit more
          A.x -= nx * push * 0.5; A.y -= ny * push * 0.5; B.x += nx * push * 0.5; B.y += ny * push * 0.5;
        }
      }
    }
  }
}

function draw(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  // draw players with size and label
  for(const r of ROLES){
    const p = players[r]; const rad = areaToR(p.displayArea);
    // glow
    ctx.beginPath(); ctx.fillStyle = COLORS[r]; ctx.globalAlpha = 0.08; ctx.arc(p.x,p.y,rad*1.6,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    // blob
    ctx.beginPath(); ctx.fillStyle = COLORS[r]; ctx.arc(p.x,p.y,rad,0,Math.PI*2); ctx.fill();
    // outline
    ctx.lineWidth = 2; ctx.strokeStyle = '#001'; ctx.stroke();
    // label
    ctx.fillStyle = '#001'; ctx.font = '12px monospace'; ctx.fillText(`${r} ${Math.round(p.area)}`, p.x - rad, p.y - rad - 6);
  }
  // draw neutrals
  for(const n of neutrals){ const rad = areaToR(n.displayArea); ctx.beginPath(); ctx.fillStyle = '#bdbdbd'; ctx.globalAlpha = 0.12; ctx.arc(n.x,n.y,rad*1.4,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; ctx.beginPath(); ctx.fillStyle = '#dcdcdc'; ctx.arc(n.x,n.y,rad,0,Math.PI*2); ctx.fill(); ctx.lineWidth=1; ctx.strokeStyle='#111'; ctx.stroke(); }
}

let last = performance.now();
function frame(now){
  const dt = Math.min(60, now - last)/1000; last = now;
  step(dt);
  draw();
  // refresh HUD sizes after draw
  updateHudSizes();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// calibration button
const calibBtn = document.getElementById('calib');
calibBtn.addEventListener('click', ()=>{
  // capture current raw inputs as zero for each role that has input
  for(const r of ROLES){
    const inp = inputs[r];
    if(inp){
      calibrations[r] = { beta: inp.rawBeta || 0, gamma: inp.rawGamma || 0 };
    }
  }
  saveCalibrations();
  statusEl.textContent = 'Calibrated';
  setTimeout(()=>{ statusEl.textContent = 'Connected' }, 1200);
});

restartBtn.addEventListener('click', ()=>{ resetGame(); statusEl.textContent='Restarted'; });

function updateHudSizes(){
  try{
    const total = ROLES.reduce((s,r)=>s + (players[r].displayArea||0), 0) || 1;
    const ids = {
      blue:'sBlueSize', red:'sRedSize', yellow:'sYellowSize', green:'sGreenSize',
      orange:'sOrangeSize', purple:'sPurpleSize', cyan:'sCyanSize', magenta:'sMagentaSize'
    };
    for(const r of ROLES){
      const pct = Math.round((players[r].displayArea/total)*100);
      const el = document.getElementById(ids[r]);
      if(el) {
        el.textContent = String(pct);
        // Set color of parent .role div
        if(el.parentElement) el.parentElement.style.color = COLORS[r];
      }
    }
  }catch(e){}
}

// ensure HUD updates immediately after initial reset and on manual restart
updateHudSizes();

// load any persisted calibrations
loadCalibrations();

</script>
</body>
</html>
