<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Gyro Sumo</title>
<style>
  html,body{height:100%;margin:0;padding:0}
  body {
    font-family:'Segoe UI',Arial,Helvetica,sans-serif;
    background:#000;
    color:#eee;
    overflow:hidden;
  }
  canvas {
    position:fixed;
    top:0; left:0;
    width:100%; height:100%;
    background:radial-gradient(ellipse at center, #1a0a2e 0%, #0f051d 50%, #000000 100%);
  }
  h1{position:fixed;top:70px;left:50%;transform:translateX(-50%);margin:0;z-index:999;font-size:24px;text-shadow:0 4px 12px rgba(0,0,0,0.8);display:none}
  /* Glass HUD */
  .hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;align-items:center;z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4)}
  .role{padding:8px 14px;border-radius:10px;background:rgba(255,255,255,0.08);font-weight:600;font-size:14px;transition:all 0.3s ease;border:1px solid rgba(255,255,255,0.1);text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  .role:hover{background:rgba(255,255,255,0.12);transform:translateY(-2px)}
  button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
</style>
</head>
<body>
  <h1>Gyro Sumo</h1>
  <div id="splash" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:9999;align-items:center;justify-content:center;background:#000;">
    <span id="splashText" style="font-size:4em;font-weight:bold;color:#fff;text-shadow:0 0 24px #000"></span>
  </div>
  
  <div class="hud">
    <div class="role" id="blueRole">Blue <span id="sBlue">0</span></div>
    <div class="role" id="redRole">Red <span id="sRed">0</span></div>
    <div class="role" id="yellowRole" style="display:none">Yellow <span id="sYellow">0</span></div>
    <div class="role" id="greenRole" style="display:none">Green <span id="sGreen">0</span></div>
    <div class="role" id="orangeRole" style="display:none">Orange <span id="sOrange">0</span></div>
    <div class="role" id="purpleRole" style="display:none">Purple <span id="sPurple">0</span></div>
    <div class="role" id="cyanRole" style="display:none">Cyan <span id="sCyan">0</span></div>
    <div class="role" id="magentaRole" style="display:none">Magenta <span id="sMagenta">0</span></div>
    <button id="calibBtn">Calibrate</button>
  </div>

  <canvas id="c" width="600" height="600"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// runtime-safe logger: attempts to write to #info if present, otherwise falls back to console
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
const playerCount = getPlayerCountFromUrl();
const calibBtn = document.getElementById('calibBtn');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');
const yellowBadge = document.getElementById('yellowRole');
const greenBadge = document.getElementById('greenRole');
const orangeBadge = document.getElementById('orangeRole');
const purpleBadge = document.getElementById('purpleRole');
const cyanBadge = document.getElementById('cyanRole');
const magentaBadge = document.getElementById('magentaRole');

let ws=null;
const players = {};
let activeRoles = ['blue','red'];
const scores = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};

const colors = {
  blue:'#4ea1ff', red:'#ff6b6b', yellow:'#ffd86b', green:'#8fe58f',
  orange:'#ffae42', purple:'#b388ff', cyan:'#4deeea', magenta:'#ff6bd6'
};
let arena = {x:300, y:300, radius:280};
const RADIUS = 26; // increased blob size
// Code-only global speed multiplier (no UI) to tune game speed/responsiveness
const SPEED_MULTIPLIER = 1.2; // tweak this to make sumo faster/slower
let MAX_SPEED = 220 * SPEED_MULTIPLIER;
const FRICTION = 0.92;
const PUSH_FORCE = 1.5;

function resizeCanvasToDisplay(){
  const size = Math.min(window.innerWidth, window.innerHeight);
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  arena.x = canvas.width/2; arena.y = canvas.height/2; arena.radius = size/2 - 20;
  MAX_SPEED = Math.max(120, arena.radius * 0.6);
  arena.minRadius = Math.max(48, size * 0.10);
  if(players){
    const startPositions = [
      {x:arena.x - arena.radius*0.55, y:arena.y},
      {x:arena.x + arena.radius*0.55, y:arena.y},
      {x:arena.x, y:arena.y - arena.radius*0.55},
      {x:arena.x, y:arena.y + arena.radius*0.55},
      {x:arena.x - arena.radius*0.38, y:arena.y - arena.radius*0.38},
      {x:arena.x + arena.radius*0.38, y:arena.y - arena.radius*0.38},
      {x:arena.x - arena.radius*0.38, y:arena.y + arena.radius*0.38},
      {x:arena.x + arena.radius*0.38, y:arena.y + arena.radius*0.38}
    ];
    let i=0; for(const role of activeRoles){ if(players[role]){ const pos = startPositions[i] || {x:arena.x, y:arena.y}; players[role].x = pos.x; players[role].y = pos.y; players[role].vx=0; players[role].vy=0; } i++; }
  }
}
window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

// calibration
let calibration = {beta:0, gamma:0, has:false};
let lastDeviceOrientation = null;
const rotState = {};

try{ const stored = localStorage.getItem('gyro_sumo_calib'); if(stored){ calibration = JSON.parse(stored); } }catch(e){}

// setup players
function initPlayers(){
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, Math.max(2, Math.min(8, n)));

  // toggle score containers
  if(yellowBadge) yellowBadge.style.display = (n >= 3) ? '' : 'none';
  if(greenBadge) greenBadge.style.display = (n >= 4) ? '' : 'none';
  if(orangeBadge) orangeBadge.style.display = (n >= 5) ? '' : 'none';
  if(purpleBadge) purpleBadge.style.display = (n >= 6) ? '' : 'none';
  if(cyanBadge) cyanBadge.style.display = (n >= 7) ? '' : 'none';
  if(magentaBadge) magentaBadge.style.display = (n >= 8) ? '' : 'none';

  const startPositions = [
    {x:arena.x - arena.radius*0.55, y:arena.y},
    {x:arena.x + arena.radius*0.55, y:arena.y},
    {x:arena.x, y:arena.y - arena.radius*0.55},
    {x:arena.x, y:arena.y + arena.radius*0.55},
    {x:arena.x - arena.radius*0.38, y:arena.y - arena.radius*0.38},
    {x:arena.x + arena.radius*0.38, y:arena.y - arena.radius*0.38},
    {x:arena.x - arena.radius*0.38, y:arena.y + arena.radius*0.38},
    {x:arena.x + arena.radius*0.38, y:arena.y + arena.radius*0.38}
  ];

  // remove players that are not active
  for(const k of Object.keys(players)){
    if(!activeRoles.includes(k)) delete players[k];
  }

  let i=0;
  for(const role of activeRoles){
    const pos = startPositions[i] || {x:arena.x, y:arena.y};
    players[role] = {x:pos.x, y:pos.y, vx:0, vy:0, alive:true};
    i++;
  }
}
initPlayers();

// calibration button
calibBtn.addEventListener('click', ()=>{
  if(lastDeviceOrientation){
    calibration.beta = lastDeviceOrientation.beta || 0;
    calibration.gamma = lastDeviceOrientation.gamma || 0;
    calibration.has = true;
    try{ localStorage.setItem('gyro_sumo_calib', JSON.stringify(calibration)); }catch(e){}
    appendLog('Calibrated!');
  } else {
    appendLog('No orientation available to calibrate.');
  }
});

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // arena background gradient
  const grad = ctx.createRadialGradient(arena.x, arena.y, arena.radius*0.2, arena.x, arena.y, arena.radius);
  grad.addColorStop(0, '#333');
  grad.addColorStop(1, '#111');
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(arena.x, arena.y, arena.radius, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle='#666'; ctx.lineWidth=4; ctx.stroke();

  // players
  for(const role of activeRoles){
    const p = players[role];
    if(!p.alive) continue;
    ctx.fillStyle = colors[role];
    ctx.beginPath();
    ctx.arc(p.x, p.y, RADIUS, 0, Math.PI*2);
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#fff';
    ctx.stroke();
  }
}

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

// tilt control
function handleTilt(role, beta, gamma){
  const p = players[role]; if(!p || !p.alive) return;
  // invert vertical axis so up/down are swapped
  let b = -(beta - (calibration.has ? calibration.beta : 0));
  let g = gamma - (calibration.has ? calibration.gamma : 0);
  const REF = 35;
  const nx = Math.tanh((g/REF)*1.2) * SPEED_MULTIPLIER;
  const ny = Math.tanh((b/REF)*1.2) * SPEED_MULTIPLIER;
  p.vx += nx * 8 * SPEED_MULTIPLIER;
  p.vy += ny * 8 * SPEED_MULTIPLIER;
}

// collisions between players
function collidePlayers(){
  const roles = activeRoles.filter(r=>players[r].alive);
  for(let i=0;i<roles.length;i++){
    for(let j=i+1;j<roles.length;j++){
      const a = players[roles[i]];
      const b = players[roles[j]];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const minDist = RADIUS*2;
      if(dist < minDist && dist>0){
        const overlap = (minDist - dist) / 2;
        const nx = dx / dist;
        const ny = dy / dist;
        // push both apart
        a.x -= nx * overlap;
        a.y -= ny * overlap;
        b.x += nx * overlap;
        b.y += ny * overlap;
        // bounce velocities
        const push = PUSH_FORCE;
        a.vx -= nx * push; a.vy -= ny * push;
        b.vx += nx * push; b.vy += ny * push;
      }
    }
  }
}

// check arena bounds (lose only when fully outside)
function checkArena(){
  for(const role of activeRoles){
    const p = players[role];
    if(!p.alive) continue;
    const dx = p.x - arena.x;
    const dy = p.y - arena.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist > arena.radius + RADIUS) { // fully out
      p.alive = false;
      appendLog(`${role} fell off!`);
    }
  }
}

// win detection
function checkWinner(){
  const alive = activeRoles.filter(r=>players[r].alive);
  if(alive.length === 1){
    const winner = alive[0];
    scores[winner]++;
    // refresh all visible score elements
    sBlue.textContent = scores.blue;
    sRed.textContent = scores.red;
    sYellow.textContent = scores.yellow;
    sGreen.textContent = scores.green;
    if(typeof sOrange !== 'undefined') sOrange.textContent = scores.orange;
    if(typeof sPurple !== 'undefined') sPurple.textContent = scores.purple;
    if(typeof sCyan !== 'undefined') sCyan.textContent = scores.cyan;
    if(typeof sMagenta !== 'undefined') sMagenta.textContent = scores.magenta;
    appendLog(`${winner} wins the round!`);
    showSplash(winner);
    setTimeout(()=>{ hideSplash(); resetRound(); }, 3000);
  }
  if(alive.length === 0){
    appendLog(`All fell off! Restarting...`);
    setTimeout(()=>{ resetRound(); }, 2000);
  }
}

// Splash screen logic
function showSplash(winner) {
  const splash = document.getElementById('splash');
  const splashText = document.getElementById('splashText');
  splash.style.display = 'flex';
  splash.style.background = colors[winner] || '#fff';
  splashText.textContent = `${winner.charAt(0).toUpperCase() + winner.slice(1)} Wins!`;
  splashText.style.color = (winner === 'yellow' || winner === 'orange') ? '#222' : '#fff';
}

function hideSplash() {
  const splash = document.getElementById('splash');
  splash.style.display = 'none';
}

// round reset
function resetRound(){
  const size = Math.min(canvas.width, canvas.height);
  arena.radius = Math.min(280, size/2 - 20);
  initPlayers();
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if (!room || room.length !== 3) {
    room = 'DEF'; // fallback
  }
  return room.toUpperCase();
}
const ROOM_ID = getRoomId();

// create unified room badge and helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// WebSocket setup (same API as maze)
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token=data.token;
  const proto=(location.protocol==='https:')?'wss':'ws';
  let wsUrl=data.ws_url?(data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)):`${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  // Add room id to wsUrl
  wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
  ws=new WebSocket(wsUrl);
  ws.onopen=()=>{appendLog(`Connected, Room ID: ${ROOM_ID}`); if(window.__setRoomBadge) window.__setRoomBadge(`Connected â€” Room: ${ROOM_ID}`);};
  ws.onmessage=(ev)=>{
    try{
      const d=JSON.parse(ev.data);
      if(!d) return;
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg||!playerMsg.role) continue;
          if (playerMsg.room && playerMsg.room.toUpperCase() !== ROOM_ID) continue;
          if(!activeRoles.includes(playerMsg.role)) continue;
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined){
            lastDeviceOrientation = {beta:playerMsg.orientBeta,gamma:playerMsg.orientGamma};
            handleTilt(playerMsg.role,playerMsg.orientBeta,playerMsg.orientGamma);
          }else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            const now=Date.now();
            if(!rotState[playerMsg.role])rotState[playerMsg.role]={b:0,g:0,ts:now};
            const st=rotState[playerMsg.role];
            const dt=Math.min(0.1,(now-st.ts)/1000); st.ts=now;
            st.b+=(playerMsg.beta||0)*dt; st.g+=(playerMsg.gamma||0)*dt;
            st.b*=0.995; st.g*=0.995;
            handleTilt(playerMsg.role,st.b,st.g);
          }
        }
      }
    }catch(e){}
  };
  ws.onclose=()=>{appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000);};
}).catch(e=>{appendLog('No backend /api/token');});

let last=performance.now();
function frame(now){
  const dt=Math.min(40,now-last)/1000; last=now;
  // shrink arena twice as fast (but not below responsive minimum)
  const minR = (arena && arena.minRadius) ? arena.minRadius : 120;
  arena.radius = Math.max(minR, arena.radius - dt*3.0 * SPEED_MULTIPLIER); // faster shrink scaled
  // physics
  for(const role of activeRoles){
    const p=players[role];
    if(!p.alive)continue;
    p.x += p.vx*dt * SPEED_MULTIPLIER;
    p.y += p.vy*dt * SPEED_MULTIPLIER;
    p.vx *= Math.pow(FRICTION, dt*60);
    p.vy *= Math.pow(FRICTION, dt*60);
    const speed=Math.sqrt(p.vx*p.vx+p.vy*p.vy);
    if(speed>MAX_SPEED){
      p.vx*=MAX_SPEED/speed;
      p.vy*=MAX_SPEED/speed;
    }
  }
  collidePlayers();
  checkArena();
  checkWinner();
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
