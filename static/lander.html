<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Lander 2 — Gyro Games</title>
  <style>
    html,body{height:100%}
    body{font-family:Arial,Helvetica,sans-serif;background:#050612;color:#e6eefc;display:flex;flex-direction:column;align-items:center;padding:12px 12px 0 12px;box-sizing:border-box;overflow:hidden}
  canvas{background:linear-gradient(#001, #002233);border:2px solid #223;margin:2px;max-width:100%;height:auto}
  #msg{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:6px;color:#cfe;font-weight:600;transition:all 0.2s}
  #msg.countdown {
    top: 50%;
    bottom: auto;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2.8em;
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 18px 32px;
    border-radius: 16px;
    z-index: 100;
  }
    .hud{display:flex;gap:12px;align-items:center}
    button{padding:.4rem .8rem;border-radius:6px;border:none;background:#1f6feb;color:white}
    .score{font-size:14px}
  </style>
</head>
<body>
  <h1 style="margin-bottom:4px">Moon Lander</h1>
  
  <div class="hud">
    <button id="restart">Restart</button>
    <button id="fs">Fullscreen</button>
    <!-- per-role score containers will be appended here -->
    <div id="scoresHolder" class="scores" style="display:flex;gap:12px;align-items:center;margin-left:12px"></div>
  </div>
  <canvas id="c" width="700" height="420"></canvas>
  <div id="msg" style="color:#cfe">Connecting...</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const msg = document.getElementById('msg');
// runtime-safe logger: attempts to write to #connectionStatus if present, otherwise falls back to console
function appendLog(txt){
  try{
    const el = document.getElementById('connectionStatus');
    if(el) el.textContent = txt;
    else console.log(txt);
  }catch(e){ console.log(txt); }
}
// score elements are created dynamically in #scoresHolder
const scoresHolder = document.getElementById('scoresHolder');
const restartBtn = document.getElementById('restart');

// Game settings — tuned to be easier to control
const GRAVITY = 10; // reduced gravity for easier hovering
const THRUST_POWER = 40; // thrust
const ROT_TORQUE = 1.4; // gentler rotation torque for smoother turning
const FUEL_CONSUMPTION = 5.0; // consumption
const INPUT_SMOOTH = 0.12; // smoothing factor for incoming beta/gamma
const AUTO_LEVEL_FACTOR = 1.6; // auto-level assist strength

// ground generation
let W = canvas.width, H = canvas.height;
let ground = [];
let pads = [];
// Resize canvas to fit available viewport while preserving aspect ratio
const TARGET_ASPECT = 700/420; // original aspect
function resizeCanvasToDisplay(){
  // reserve space for header and HUD
  const headerH = (document.querySelector('h1')?.offsetHeight || 40) + (document.querySelector('.hud')?.offsetHeight || 40) + 32;
  // Prefer visualViewport dimensions when available (handles fullscreen/mobile chrome UI)
  const vv = window.visualViewport;
  const availW = Math.max(320, (vv?.width || window.innerWidth) - 24);
  const availH = Math.max(240, ( (vv?.height || window.innerHeight) - headerH - 24));
  // fit to available area preserving aspect
  let newW = Math.min(availW, Math.floor(availH * TARGET_ASPECT));
  let newH = Math.floor(newW / TARGET_ASPECT);
  // if width would be too small for height, swap
  if(newH > availH){ newH = availH; newW = Math.floor(newH * TARGET_ASPECT); }
  canvas.width = Math.max(320, newW);
  canvas.height = Math.max(240, newH);
  W = canvas.width; H = canvas.height;
  // regenerate ground and reinitialize players/pads to match new size
  genGround();
  initPlayers();
}
// Debounced resize helper to avoid thrashing when visualViewport fires many events
let _resizeTimer = null;
function scheduleResize(){ if(_resizeTimer) clearTimeout(_resizeTimer); _resizeTimer = setTimeout(()=>{ resizeCanvasToDisplay(); _resizeTimer = null; }, 80); }

// Listen to visualViewport changes which occur on fullscreen and when mobile browser chrome hides/shows
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', scheduleResize);
  window.visualViewport.addEventListener('scroll', scheduleResize);
}
// Also listen to orientation change
window.addEventListener('orientationchange', scheduleResize);
function genGround(){
  ground = [];
  const segments = 14;
  for(let i=0;i<=segments;i++){
    const x = i*(W/segments);
    // More pronounced terrain: higher amplitude and randomness
    const y = H - 40 - Math.round(Math.sin(i*1.2)*38) - Math.random()*32;
    ground.push({x,y});
  }
}
function groundYAt(x){
  // linear interpolate between points
  for(let i=0;i<ground.length-1;i++){
    const a=ground[i], b=ground[i+1];
    if(x>=a.x && x<=b.x){
      const t=(x-a.x)/(b.x-a.x); return a.y*(1-t)+b.y*t;
    }
  }
  return H-20;
}

// players state (dynamic based on selected player count). Roles in order: blue, red, yellow, green, orange, purple, cyan, magenta
const ROLE_ORDER = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
const playerCount = getPlayerCountFromUrl();
let players = {};
let running = false; // whether physics/controls are active
let _countdownTimer = null;

function initPlayers(){
  const n = playerCount;
  pads = [];
  players = {};
  const padW = 60;
  // Create pad positions
  let padPositions = [];
  for(let i=0;i<n;i++){
    const px = Math.floor((i+1) * W / (n+1));
    let minY = Infinity;
    for(let dx = -padW/2; dx <= padW/2; dx += 2){
      const gx = Math.max(0, Math.min(W, px + dx));
      const gy = groundYAt(gx);
      if(gy < minY) minY = gy;
    }
    padPositions.push({ x: px, y: minY - 8 });
  }
  // Shuffle pad assignments
  let shuffledRoles = ROLE_ORDER.slice(0, n).sort(() => Math.random() - 0.5);
  for(let i=0;i<n;i++){
    pads.push({ x: padPositions[i].x, y: padPositions[i].y, w: padW, role: shuffledRoles[i] });
  }
  // Assign each player to a random starting position (not always above a pad)
  let usedX = [];
  const minX = 40, maxX = W - 40;
  for(let i=0;i<n;i++){
    const role = ROLE_ORDER[i];
    let x, tries = 0;
    do {
      x = Math.floor(Math.random() * (maxX - minX)) + minX;
      tries++;
    } while (usedX.some(px => Math.abs(px - x) < 40) && tries < 20);
    usedX.push(x);
    players[role] = { x: x, y: Math.max(60, H*0.12), vx:0, vy:0, angle:0, av:0, thrust:0, fuel:100, landed:false, crashed:false, score:0 };
  }
  // ...existing code...
  // rebuild the per-role score containers in the scoresHolder
  if(scoresHolder){
    // clear existing
    scoresHolder.innerHTML = '';
    const roleColors = {
      blue: '#4ea1ff', red: '#ff6b6b', yellow: '#ffd86b', green: '#8fe58f',
      orange: '#ff9f4d', purple: '#b58cff', cyan: '#4de6e6', magenta: '#ff6bff'
    };
    for(let i=0;i<n;i++){
      const role = ROLE_ORDER[i];
      const el = document.createElement('div');
      el.className = 'score';
      el.id = `${role}ScoreContainer`;
      el.style.color = roleColors[role] || '#fff';
      el.innerHTML = `${role.charAt(0).toUpperCase()+role.slice(1)}: <span id="${role}Score">0</span>`;
      scoresHolder.appendChild(el);
    }
  }
}


// input from websocket (per role): keep raw and smoothed values
const inputs = { blue: {rawBeta:0, rawGamma:0, beta:0, gamma:0}, red:{rawBeta:0, rawGamma:0, beta:0, gamma:0} };

function resetRound(){
  genGround();
  initPlayers();
  // clear any stale inputs for all roles
  for(const r of Object.keys(players)){
    if(inputs[r]){ inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; inputs[r].beta = 0; inputs[r].gamma = 0; }
  }
  // begin a new round with countdown
  startCountdown();
}

function startCountdown(){
  // show a 3..2..1 then enable running
  let count = 3;
  running = false;
  msg.classList.add('countdown');
  msg.textContent = `Starting in ${count}...`;
  if(_countdownTimer) clearInterval(_countdownTimer);
  _countdownTimer = setInterval(()=>{
    count -= 1;
    if(count > 0){ msg.textContent = `Starting in ${count}...`; }
    else {
      clearInterval(_countdownTimer);
      msg.textContent = 'Go!';
      setTimeout(() => { msg.classList.remove('countdown'); }, 700);
      _countdownTimer = null;
      beginRun();
    }
  }, 1000);
}

function beginRun(){
  // zero thrust and mark running true
  for(const r of Object.keys(players)){ if(players[r]) players[r].thrust = 0; }
  running = true;
}

// initial layout
resizeCanvasToDisplay();
initPlayers();
resetRound();

// respond to window size changes
window.addEventListener('resize', ()=>{ resizeCanvasToDisplay(); });

// fullscreen toggle
const fsBtn = document.getElementById('fs');
fsBtn.addEventListener('click', ()=>{
  if(!document.fullscreenElement){
    document.documentElement.requestFullscreen?.();
  } else {
    document.exitFullscreen?.();
  }
});

// adjust on fullscreen change
document.addEventListener('fullscreenchange', ()=>{ setTimeout(resizeCanvasToDisplay, 80); });

// draw
function drawGround(){
  ctx.fillStyle='#223'; ctx.beginPath(); ctx.moveTo(0,H);
  for(const p of ground) ctx.lineTo(p.x,p.y);
  ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
}

function drawPads(){
  for(const [i,p] of pads.entries()){
    // pad colored by role
    const color = p.role==='blue' ? '#4ea1ff' : p.role==='red' ? '#ff6b6b' : p.role==='yellow' ? '#ffd86b' : p.role==='green' ? '#8fe58f' : p.role==='orange' ? '#ff9f4d' : p.role==='purple' ? '#b58cff' : p.role==='cyan' ? '#4de6e6' : '#ff6bff';
    ctx.fillStyle = color;
    ctx.fillRect(p.x - p.w/2, p.y-6, p.w, 10);
    ctx.strokeStyle = '#fff'; ctx.strokeRect(p.x - p.w/2, p.y-6, p.w, 10);
  }
}

function drawLander(pl, color){
  // Check if lander is off screen
  if(pl.x < 0 || pl.x > W || pl.y < 0 || pl.y > H){
    // Draw triangle at edge and show coordinates
    let tx = Math.max(12, Math.min(W-12, pl.x));
    let ty = Math.max(12, Math.min(H-12, pl.y));
    let angle = 0;
    if(pl.x < 0) { tx = 12; angle = Math.PI; }
    if(pl.x > W) { tx = W-12; angle = 0; }
    if(pl.y < 0) { ty = 12; angle = Math.PI/2; }
    if(pl.y > H) { ty = H-12; angle = -Math.PI/2; }
    ctx.save(); ctx.translate(tx, ty); ctx.rotate(angle);
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.closePath(); ctx.fill();
    ctx.restore();
    // Show coordinates
    ctx.save();
    ctx.font = '13px monospace';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.fillText(`${pl.x.toFixed(0)},${pl.y.toFixed(0)}`, tx, ty+22);
    ctx.restore();
    return;
  }
  // Draw normal lander
  ctx.save(); ctx.translate(pl.x, pl.y); ctx.rotate(pl.angle);
  ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.closePath(); ctx.fill();
  // flame
  if(pl.thrust>0 && pl.fuel>0){ ctx.fillStyle='orange'; ctx.beginPath(); ctx.moveTo(-6,10); ctx.lineTo(0,10+Math.random()*8*pl.thrust); ctx.lineTo(6,10); ctx.closePath(); ctx.fill(); }
  ctx.restore();
}

function drawHUD(){
  // Draw fuel bars on top right
  const fw = 120, fh = 8;
  let fy = 8;
  for(const role of Object.keys(players)){
    const p = players[role];
    ctx.fillStyle='#333'; ctx.fillRect(W - fw - 10, fy, fw, fh);
    // color by role
    const color = role==='blue' ? '#4ea1ff' : role==='red' ? '#ff6b6b' : role==='yellow' ? '#ffd86b' : role==='green' ? '#8fe58f' : role==='orange' ? '#ff9f4d' : role==='purple' ? '#b58cff' : role==='cyan' ? '#4de6e6' : '#ff6bff';
    ctx.fillStyle = color; ctx.fillRect(W - fw - 10, fy, fw * (p.fuel/100), fh);
    fy += fh + 8;
  }
}

// physics and rules
function step(dt){
  // if countdown hasn't finished, don't apply physics so ships stay in place
  if(!running) return;

  for(const role of Object.keys(players)){
    const p = players[role];
    if(p.landed || p.crashed) { p.thrust = 0; continue; }
    // ensure inputs exist for this role
    if(!inputs[role]) inputs[role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    // smooth incoming raw inputs into working values
    inputs[role].beta = inputs[role].beta * (1 - INPUT_SMOOTH) + (inputs[role].rawBeta || 0) * INPUT_SMOOTH;
    inputs[role].gamma = inputs[role].gamma * (1 - INPUT_SMOOTH) + (inputs[role].rawGamma || 0) * INPUT_SMOOTH;
    const beta = inputs[role].beta || 0; const gamma = inputs[role].gamma || 0;
    // thrust mapping: positive beta -> thrust (tilt up increases thrust)
    let thrust = 0;
    if(running){ thrust = Math.max(0, Math.min(1, (beta)/35)); }
    // small deadzone
    if(Math.abs(thrust) < 0.03) thrust = 0;
    // rotation from gamma: left/right tilt -> angular acceleration sign
    const rotInput = Math.max(-1, Math.min(1, (gamma || 0)/30));

    // If off top, left, or right
    if(p.x < 0 || p.x > W || p.y < 0){
      if(thrust === 0){
        p.vy = Math.abs(p.vy) < 40 ? 40 : Math.abs(p.vy); // force downward velocity
        p.vx = 0; // stop horizontal drift
      }
      // If thrusting, allow movement as normal
    }

    // consume fuel
    if(thrust>0 && p.fuel>0){ p.fuel = Math.max(0, p.fuel - FUEL_CONSUMPTION * thrust * dt); }
    if(p.fuel<=0) thrust = 0;

    // thrust vector in ship's local -y direction
    const ax = Math.sin(p.angle) * (thrust) * THRUST_POWER;
    const ay = Math.cos(p.angle) * (-thrust) * THRUST_POWER;
    // apply gravity
    p.vx += ax * dt;
    p.vy += (ay + GRAVITY) * dt;
    // angular acceleration
    p.av += rotInput * ROT_TORQUE * dt;
    // auto-level assist nudges angular acceleration toward 0 when near upright
    p.av += (-p.angle) * AUTO_LEVEL_FACTOR * dt;
    p.angle += p.av * dt;
    // damping angular velocity slightly
    p.av *= 0.995;
    // position
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    p.thrust = thrust;

    // collision: use pad y if above pad, terrain otherwise
    const padIndex = pads.findIndex(pd => p.x >= pd.x - pd.w/2 && p.x <= pd.x + pd.w/2);
    let collisionY;
    if (padIndex !== -1) {
      // Pad top is pads[padIndex].y - 6
      collisionY = pads[padIndex].y - 16; // pad top minus lander height (10) and pad thickness (6)
    } else {
      // Terrain collision
      collisionY = groundYAt(p.x) - 14;
    }
    if (p.y >= collisionY) {
      const safeV = Math.abs(p.vy) < 40; // px/s
      const upright = Math.abs(p.angle) < 0.35; // ~20 deg
      if (padIndex !== -1 && safeV && upright) {
        // Landed on pad
        p.landed = true;
        p.x = pads[padIndex].x;
        p.y = pads[padIndex].y - 16;
        p.vx = 0; p.vy = 0; p.av = 0;
        p.score = (p.score || 0) + 1;
        // update DOM score if present
        const scoreEl = document.getElementById(`${role}Score`);
        if(scoreEl) scoreEl.textContent = p.score;
        msg.textContent = `${role} landed successfully!`;
      } else {
        // Crashed (either on pad or terrain)
        p.crashed = true;
        p.y = collisionY;
        p.vx = 0; p.vy = 0; p.av = 0;
        msg.textContent = `${role} crashed...`;
      }
    }
    // keep in bounds
    p.x = Math.max(10, Math.min(W-10, p.x));
    p.y = Math.max(10, Math.min(H-10, p.y));
  }
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if (!room || room.length !== 3) {
    room = 'DEF'; // fallback
  }
  return room.toUpperCase();
}
const ROOM_ID = getRoomId();
// create unified room badge and helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// websocket hookup reuse /api/token
let ws = null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  let wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  // Add room id to wsUrl
  wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{
    appendLog(`Connected, Room ID: ${ROOM_ID}`);
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room: ${ROOM_ID}`);
  };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if(!d) return;
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || playerMsg.role==null) continue;
          if(playerMsg.room && playerMsg.room.toUpperCase() !== ROOM_ID) continue;
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined && playerMsg.orientBeta!==null){
            if(!inputs[playerMsg.role]) inputs[playerMsg.role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
            inputs[playerMsg.role].rawBeta = playerMsg.orientBeta;
            inputs[playerMsg.role].rawGamma = playerMsg.orientGamma;
          } else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            if(!inputs[playerMsg.role]) inputs[playerMsg.role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
            inputs[playerMsg.role].rawBeta += (playerMsg.beta||0) * 0.02;
            inputs[playerMsg.role].rawGamma += (playerMsg.gamma||0) * 0.02;
          }
        }
      }
    }catch(e){}
  };
  ws.onclose = ()=>{ appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); };
}).catch(e=>{ appendLog('No backend /api/token'); });

// keyboard fallback for local testing — mapped to the first two active roles
window.addEventListener('keydown', (ev)=>{
  const roles = Object.keys(players);
  if(roles.length >= 1){
    const r = roles[0]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    if(ev.key==='w') inputs[r].rawBeta = -20;
    if(ev.key==='s') inputs[r].rawBeta = 20;
    if(ev.key==='a') inputs[r].rawGamma = -20;
    if(ev.key==='d') inputs[r].rawGamma = 20;
  }
  if(roles.length >= 2){
    const r = roles[1]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    if(ev.key==='ArrowUp') inputs[r].rawBeta = -20;
    if(ev.key==='ArrowDown') inputs[r].rawBeta = 20;
    if(ev.key==='ArrowLeft') inputs[r].rawGamma = -20;
    if(ev.key==='ArrowRight') inputs[r].rawGamma = 20;
  }
});
window.addEventListener('keyup', (ev)=>{
  const roles = Object.keys(players);
  if(roles.length >= 1){ const r = roles[0]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0}; if(['w','s','a','d'].includes(ev.key)) { inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; } }
  if(roles.length >= 2){ const r = roles[1]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0}; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(ev.key)) { inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; } }
});

// animation
let last = performance.now();
function frame(now){
  const dt = Math.min(60, now-last)/1000; last = now;
  // physics
  step(dt);
  // draw
  ctx.clearRect(0,0,W,H);
  drawGround();
  drawPads();
  // draw all players in order
  const roleKeys = Object.keys(players);
  for(const role of roleKeys){
    const color = role==='blue' ? '#4ea1ff' : role==='red' ? '#ff6b6b' : role==='yellow' ? '#ffd86b' : role==='green' ? '#8fe58f' : role==='orange' ? '#ff9f4d' : role==='purple' ? '#b58cff' : role==='cyan' ? '#4de6e6' : '#ff6bff';
    drawLander(players[role], color);
  }
  drawHUD();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

restartBtn.addEventListener('click', ()=>{ resetRound(); appendLog('Round reset');
  for(const role of Object.keys(players)){
    const el = document.getElementById(`${role}Score`);
    if(el) el.textContent = players[role].score || 0;
  }
});

</script>
</body>
</html>
