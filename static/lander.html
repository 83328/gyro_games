<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Lander 2 — Gyro Games</title>
  <style>
    html,body{height:100%;margin:0;padding:0}
    body{font-family:'Segoe UI',Arial,Helvetica,sans-serif;background:#000;color:#e6eefc;overflow:hidden}
  canvas{position:fixed;top:0;left:0;width:100%;height:100%;background:radial-gradient(ellipse at center, #1a0a2e 0%, #0f051d 50%, #000000 100%)}
  h1{position:fixed;top:70px;left:50%;transform:translateX(-50%);margin:0;z-index:999;font-size:24px;text-shadow:0 4px 12px rgba(0,0,0,0.8);display:none}
  #msg{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(0,0,0,0.6);padding:8px 12px;border-radius:12px;color:#cfe;font-weight:600;transition:all 0.2s;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1)}
  #msg.countdown {
    top: 50%;
    bottom: auto;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2.8em;
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 18px 32px;
    border-radius: 16px;
    z-index: 100;
    backdrop-filter:blur(10px);
  }
    .hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;align-items:center;z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4)}
    button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
    button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
    .score{padding:8px 14px;border-radius:10px;background:rgba(255,255,255,0.08);font-weight:600;font-size:14px;transition:all 0.3s ease;border:1px solid rgba(255,255,255,0.1);text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  /* Top-left countdown badge (glass style) */
  #countdownBadge{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:10px 16px;border-radius:12px;font-size:20px;font-weight:800;z-index:10000;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1)}
  </style>
</head>
<body>
  
  <div class="hud">
    <button id="restart">Restart</button>
    <!-- per-role score containers will be appended here -->
    <div id="scoresHolder" class="scores" style="display:flex;gap:12px;align-items:center;margin-left:12px"></div>
  </div>
  <canvas id="c" width="700" height="420"></canvas>
  <div id="msg" style="color:#cfe">Connecting...</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const msg = document.getElementById('msg');
// runtime-safe logger: attempts to write to #connectionStatus if present, otherwise falls back to console
function appendLog(txt){
  try{
    const el = document.getElementById('connectionStatus');
    if(el) el.textContent = txt;
    else console.log(txt);
  }catch(e){ console.log(txt); }
}
// score elements are created dynamically in #scoresHolder
const scoresHolder = document.getElementById('scoresHolder');
const restartBtn = document.getElementById('restart');

// Game settings — tuned to be easier to control
const GRAVITY = 10; // reduced gravity for easier hovering
const THRUST_POWER = 40; // thrust
const ROT_TORQUE = 1.4; // gentler rotation torque for smoother turning
const FUEL_CONSUMPTION = 5.0; // consumption
const INPUT_SMOOTH = 0.12; // smoothing factor for incoming beta/gamma
const AUTO_LEVEL_FACTOR = 1.6; // auto-level assist strength

// ground generation
let W = canvas.width, H = canvas.height;
let ground = [];
let pads = [];
// Resize canvas to fit available viewport while preserving aspect ratio (without resetting game state)
const TARGET_ASPECT = 700/420; // original aspect
function resizeCanvasToDisplay(){
  // Prefer visualViewport dimensions when available (handles fullscreen/mobile chrome UI)
  const vv = window.visualViewport;
  const availW = Math.max(320, (vv?.width || window.innerWidth));
  const availH = Math.max(240, (vv?.height || window.innerHeight));
  // fit to available area preserving aspect
  let newW = Math.min(availW, Math.floor(availH * TARGET_ASPECT));
  let newH = Math.floor(newW / TARGET_ASPECT);
  // if width would be too small for height, swap
  if(newH > availH){ newH = availH; newW = Math.floor(newH * TARGET_ASPECT); }

  const clampedW = Math.max(320, newW);
  const clampedH = Math.max(240, newH);
  const oldW = W || clampedW;
  const oldH = H || clampedH;
  const scaleX = clampedW / oldW;
  const scaleY = clampedH / oldH;

  canvas.width = clampedW;
  canvas.height = clampedH;
  W = canvas.width; H = canvas.height;

  // Scale existing world state to preserve in-progress rounds without regenerating
  if(ground && ground.length){ for(const pt of ground){ pt.x *= scaleX; pt.y *= scaleY; } }
  if(pads && pads.length){ for(const p of pads){ p.x *= scaleX; p.y *= scaleY; p.w *= scaleX; } }
  for(const role of Object.keys(players)){
    const pl = players[role];
    if(!pl) continue;
    pl.x *= scaleX; pl.y *= scaleY; pl.vx *= scaleX; pl.vy *= scaleY;
  }
}
// Debounced resize helper to avoid thrashing when visualViewport fires many events
let _resizeTimer = null;
function scheduleResize(){ if(_resizeTimer) clearTimeout(_resizeTimer); _resizeTimer = setTimeout(()=>{ resizeCanvasToDisplay(); _resizeTimer = null; }, 80); }

// Listen to visualViewport changes which occur on fullscreen and when mobile browser chrome hides/shows
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', scheduleResize);
  window.visualViewport.addEventListener('scroll', scheduleResize);
}
// Also listen to orientation change
window.addEventListener('orientationchange', scheduleResize);
function genGround(){
  ground = [];
  const segments = 14;
  for(let i=0;i<=segments;i++){
    const x = i*(W/segments);
    // More pronounced terrain: higher amplitude and randomness
    const y = H - 40 - Math.round(Math.sin(i*1.2)*38) - Math.random()*32;
    ground.push({x,y});
  }
}
function groundYAt(x){
  // linear interpolate between points
  for(let i=0;i<ground.length-1;i++){
    const a=ground[i], b=ground[i+1];
    if(x>=a.x && x<=b.x){
      const t=(x-a.x)/(b.x-a.x); return a.y*(1-t)+b.y*t;
    }
  }
  return H-20;
}

// players state (dynamic based on selected player count). Roles in order: blue, red, yellow, green, orange, purple, cyan, magenta
const ROLE_ORDER = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();
let players = {};
let running = false; // whether physics/controls are active
let _countdownTimer = null;
let _intermissionTimer = null;
// persistent scores across rounds
let scores = {blue:0, red:0, yellow:0, green:0, orange:0, purple:0, cyan:0, magenta:0};

// Apply playerCount from room metadata and reinitialize game state
function applyPlayerCountFromMeta(n){
  const pc = parseInt(n, 10);
  if (!(pc >= 2 && pc <= 8)) return;
  if (pc === playerCount) return;
  playerCount = pc;
  try {
    // reflect in URL for consistency
    const u = new URL(window.location);
    u.searchParams.set('players', playerCount);
    window.history.replaceState({}, '', u);
  } catch(e){}
  // Reinitialize to match new count
  resetRound();
}

function initPlayers(){
  const n = playerCount;
  pads = [];
  players = {};
  const padW = 60;
  // Create pad positions
  let padPositions = [];
  for(let i=0;i<n;i++){
    const px = Math.floor((i+1) * W / (n+1));
    let minY = Infinity;
    for(let dx = -padW/2; dx <= padW/2; dx += 2){
      const gx = Math.max(0, Math.min(W, px + dx));
      const gy = groundYAt(gx);
      if(gy < minY) minY = gy;
    }
    padPositions.push({ x: px, y: minY - 8 });
  }
  // Shuffle pad assignments
  let shuffledRoles = ROLE_ORDER.slice(0, n).sort(() => Math.random() - 0.5);
  for(let i=0;i<n;i++){
    pads.push({ x: padPositions[i].x, y: padPositions[i].y, w: padW, role: shuffledRoles[i], landed:false, landedBy:null });
  }
  // Assign each player to a random starting position (not always above a pad)
  let usedX = [];
  const minX = 40, maxX = W - 40;
  for(let i=0;i<n;i++){
    const role = ROLE_ORDER[i];
    let x, tries = 0;
    do {
      x = Math.floor(Math.random() * (maxX - minX)) + minX;
      tries++;
    } while (usedX.some(px => Math.abs(px - x) < 40) && tries < 20);
    usedX.push(x);
    players[role] = { x: x, y: Math.max(60, H*0.12), vx:0, vy:0, angle:0, av:0, thrust:0, fuel:100, landed:false, crashed:false, score:scores[role]||0 };
  }
  // ...existing code...
  // rebuild the per-role score containers in the scoresHolder
  if(scoresHolder){
    // clear existing
    scoresHolder.innerHTML = '';
    const roleColors = {
      blue: '#4ea1ff', red: '#ff6b6b', yellow: '#ffd86b', green: '#8fe58f',
      orange: '#ff9f4d', purple: '#b58cff', cyan: '#4de6e6', magenta: '#ff6bff'
    };
    for(let i=0;i<n;i++){
      const role = ROLE_ORDER[i];
      const el = document.createElement('div');
      el.className = 'score';
      el.id = `${role}ScoreContainer`;
      el.style.color = roleColors[role] || '#fff';
      const existingScore = scores[role] || 0;
      el.innerHTML = `${role.charAt(0).toUpperCase()+role.slice(1)}: <span id="${role}Score">${existingScore}</span>`;
      scoresHolder.appendChild(el);
    }
  }
}


// input from websocket (per role): keep raw and smoothed values
const inputs = { blue: {rawBeta:0, rawGamma:0, beta:0, gamma:0}, red:{rawBeta:0, rawGamma:0, beta:0, gamma:0} };

function zeroInputsForActiveRoles(){
  const roles = Object.keys(players);
  for(const r of roles){
    if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; inputs[r].beta = 0; inputs[r].gamma = 0;
  }
}

function resetRound(){
  if(_intermissionTimer){ clearInterval(_intermissionTimer); _intermissionTimer = null; }
  genGround();
  initPlayers();
  // clear any stale inputs for all roles
  zeroInputsForActiveRoles();
  // begin a new round with countdown
  startCountdown();
}

function startCountdown(){
  // show a 3..2..1 then enable running
  let count = 3;
  running = false;
  msg.classList.add('countdown');
  msg.textContent = `Starting in ${count}...`;
  // show badge top-left
  countdownBadge.style.display = '';
  countdownBadge.textContent = `Starting in ${count}s`;
  if(_countdownTimer) clearInterval(_countdownTimer);
  _countdownTimer = setInterval(()=>{
    count -= 1;
    if(count > 0){ msg.textContent = `Starting in ${count}...`; countdownBadge.textContent = `Starting in ${count}s`; }
    else {
      clearInterval(_countdownTimer);
      msg.textContent = 'Go!';
      setTimeout(() => { msg.classList.remove('countdown'); }, 700);
      _countdownTimer = null;
      // hide badge when run begins
      countdownBadge.style.display = 'none';
      beginRun();
    }
  }, 1000);
}

function beginRun(){
  // zero thrust and mark running true
  for(const r of Object.keys(players)){ if(players[r]) players[r].thrust = 0; }
  zeroInputsForActiveRoles();
  running = true;
  if(_intermissionTimer){ clearInterval(_intermissionTimer); _intermissionTimer = null; }
}


// respond to window size changes
window.addEventListener('resize', ()=>{ resizeCanvasToDisplay(); });

// draw
function drawGround(){
  ctx.beginPath(); ctx.moveTo(0,H);
  for(const p of ground) ctx.lineTo(p.x,p.y);
  ctx.lineTo(W,H); ctx.closePath();
  const grad = ctx.createLinearGradient(0, H-100, 0, H);
  grad.addColorStop(0, '#334');
  grad.addColorStop(0.7, '#223');
  grad.addColorStop(1, '#112');
  ctx.fillStyle = grad;
  ctx.fill();
  // Add subtle glow along top edge
  ctx.strokeStyle = 'rgba(100,120,150,0.3)';
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawPads(){
  for(const [i,p] of pads.entries()){
    // pad colored by role
    const color = p.role==='blue' ? '#4ea1ff' : p.role==='red' ? '#ff6b6b' : p.role==='yellow' ? '#ffd86b' : p.role==='green' ? '#8fe58f' : p.role==='orange' ? '#ff9f4d' : p.role==='purple' ? '#b58cff' : p.role==='cyan' ? '#4de6e6' : '#ff6bff';
    const colorLight = p.role==='blue' ? '#60a5fa' : p.role==='red' ? '#f87171' : p.role==='yellow' ? '#fcd34d' : p.role==='green' ? '#34d399' : p.role==='orange' ? '#fb923c' : p.role==='purple' ? '#c084fc' : p.role==='cyan' ? '#22d3ee' : '#f472b6';
    ctx.save();
    // Glow effect
    if(p.landed){
      ctx.globalAlpha = 0.4;
      const glow = ctx.createRadialGradient(p.x, p.y-2, 0, p.x, p.y-2, p.w*0.8);
      glow.addColorStop(0, colorLight);
      glow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = glow;
      ctx.fillRect(p.x - p.w*0.8, p.y-6-p.w*0.5, p.w*1.6, p.w*0.8);
      ctx.globalAlpha = 1;
    }
    // Main pad with gradient
    const grad = ctx.createLinearGradient(p.x, p.y-6, p.x, p.y+4);
    if(p.landed){
      grad.addColorStop(0, '#fff');
      grad.addColorStop(0.5, colorLight);
      grad.addColorStop(1, color);
    } else {
      grad.addColorStop(0, colorLight);
      grad.addColorStop(1, color);
    }
    ctx.fillStyle = grad;
    ctx.fillRect(p.x - p.w/2, p.y-6, p.w, 10);
    // Glass highlight
    ctx.globalAlpha = 0.5;
    const highlight = ctx.createLinearGradient(p.x, p.y-6, p.x, p.y-2);
    highlight.addColorStop(0, 'rgba(255,255,255,0.8)');
    highlight.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = highlight;
    ctx.fillRect(p.x - p.w/2, p.y-6, p.w, 4);
    ctx.globalAlpha = 1;
    // Border
    ctx.strokeStyle = p.landed ? color : 'rgba(255,255,255,0.4)';
    ctx.lineWidth = p.landed ? 2.5 : 1.5;
    ctx.strokeRect(p.x - p.w/2, p.y-6, p.w, 10);
    ctx.restore();
  }
}

function drawLander(pl, color){
  const colorLight = color==='#4ea1ff' ? '#60a5fa' : color==='#ff6b6b' ? '#f87171' : color==='#ffd86b' ? '#fcd34d' : color==='#8fe58f' ? '#34d399' : color==='#ff9f4d' ? '#fb923c' : color==='#b58cff' ? '#c084fc' : color==='#4de6e6' ? '#22d3ee' : '#f472b6';
  // Check if lander is off screen
  if(pl.x < 0 || pl.x > W || pl.y < 0 || pl.y > H){
    // Draw triangle at edge and show coordinates
    let tx = Math.max(12, Math.min(W-12, pl.x));
    let ty = Math.max(12, Math.min(H-12, pl.y));
    let angle = 0;
    if(pl.x < 0) { tx = 12; angle = Math.PI; }
    if(pl.x > W) { tx = W-12; angle = 0; }
    if(pl.y < 0) { ty = 12; angle = Math.PI/2; }
    if(pl.y > H) { ty = H-12; angle = -Math.PI/2; }
    ctx.save(); ctx.translate(tx, ty); ctx.rotate(angle);
    // Glow
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.moveTo(0,-14); ctx.lineTo(12,14); ctx.lineTo(-12,14); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 1;
    // Main triangle with gradient
    const grad = ctx.createLinearGradient(0, -10, 0, 10);
    grad.addColorStop(0, colorLight);
    grad.addColorStop(1, color);
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.closePath(); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.restore();
    // Show coordinates
    ctx.save();
    ctx.font = '13px monospace';
    ctx.fillStyle = color;
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 4;
    ctx.fillText(`${pl.x.toFixed(0)},${pl.y.toFixed(0)}`, tx, ty+22);
    ctx.shadowBlur = 0;
    ctx.restore();
    return;
  }
  // Draw normal lander with glass effects
  ctx.save(); ctx.translate(pl.x, pl.y); ctx.rotate(pl.angle);
  // Outer glow
  ctx.globalAlpha = 0.2;
  const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 24);
  glow.addColorStop(0, colorLight);
  glow.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(14,14); ctx.lineTo(-14,14); ctx.closePath(); ctx.fill();
  ctx.globalAlpha = 1;
  // Main lander with gradient
  const grad = ctx.createLinearGradient(0, -12, 0, 10);
  grad.addColorStop(0, colorLight);
  grad.addColorStop(0.6, color);
  grad.addColorStop(1, color);
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.closePath(); ctx.fill();
  // Glossy highlight
  ctx.globalAlpha = 0.5;
  const highlight = ctx.createLinearGradient(0, -12, 0, -2);
  highlight.addColorStop(0, 'rgba(255,255,255,0.9)');
  highlight.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = highlight;
  ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(6,2); ctx.lineTo(-6,2); ctx.closePath(); ctx.fill();
  ctx.globalAlpha = 1;
  // Border
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.closePath(); ctx.stroke();
  // flame with glow
  if(pl.thrust>0 && pl.fuel>0){
    const flameHeight = 10+Math.random()*8*pl.thrust;
    // Flame glow
    ctx.globalAlpha = 0.4;
    const flameGlow = ctx.createRadialGradient(0, 10+flameHeight*0.5, 0, 0, 10+flameHeight*0.5, flameHeight*0.8);
    flameGlow.addColorStop(0, '#ffff00');
    flameGlow.addColorStop(0.5, '#ff8800');
    flameGlow.addColorStop(1, 'rgba(255,0,0,0)');
    ctx.fillStyle = flameGlow;
    ctx.beginPath(); ctx.arc(0, 10+flameHeight*0.5, flameHeight*0.8, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    // Flame gradient
    const flameGrad = ctx.createLinearGradient(0, 10, 0, 10+flameHeight);
    flameGrad.addColorStop(0, '#ffff88');
    flameGrad.addColorStop(0.3, '#ff8800');
    flameGrad.addColorStop(1, '#ff4400');
    ctx.fillStyle = flameGrad;
    ctx.beginPath(); ctx.moveTo(-6,10); ctx.lineTo(0,10+flameHeight); ctx.lineTo(6,10); ctx.closePath(); ctx.fill();
  }
  ctx.restore();
}

function drawHUD(){
  // Draw fuel bars on top right with glass style
  const fw = 120, fh = 10;
  let fy = 50;
  for(const role of Object.keys(players)){
    const p = players[role];
    // Background with glass effect
    ctx.fillStyle='rgba(0,0,0,0.4)';
    ctx.fillRect(W - fw - 10, fy, fw, fh);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.strokeRect(W - fw - 10, fy, fw, fh);
    // color by role
    const color = role==='blue' ? '#4ea1ff' : role==='red' ? '#ff6b6b' : role==='yellow' ? '#ffd86b' : role==='green' ? '#8fe58f' : role==='orange' ? '#ff9f4d' : role==='purple' ? '#b58cff' : role==='cyan' ? '#4de6e6' : '#ff6bff';
    const colorLight = role==='blue' ? '#60a5fa' : role==='red' ? '#f87171' : role==='yellow' ? '#fcd34d' : role==='green' ? '#34d399' : role==='orange' ? '#fb923c' : role==='purple' ? '#c084fc' : role==='cyan' ? '#22d3ee' : '#f472b6';
    const fuelWidth = fw * (p.fuel/100);
    if(fuelWidth > 0){
      // Fuel bar gradient
      const fuelGrad = ctx.createLinearGradient(W - fw - 10, fy, W - fw - 10, fy + fh);
      fuelGrad.addColorStop(0, colorLight);
      fuelGrad.addColorStop(1, color);
      ctx.fillStyle = fuelGrad;
      ctx.fillRect(W - fw - 10, fy, fuelWidth, fh);
      // Highlight
      ctx.globalAlpha = 0.5;
      const hlGrad = ctx.createLinearGradient(W - fw - 10, fy, W - fw - 10, fy + fh*0.5);
      hlGrad.addColorStop(0, 'rgba(255,255,255,0.6)');
      hlGrad.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = hlGrad;
      ctx.fillRect(W - fw - 10, fy, fuelWidth, fh*0.4);
      ctx.globalAlpha = 1;
    }
    fy += fh + 8;
  }
}

function allPlayersSettled(){
  const keys = Object.keys(players);
  if(!keys.length) return false;
  return keys.every(r => players[r]?.landed || players[r]?.crashed);
}

function startIntermission(){
  if(_intermissionTimer) return;
  running = false;
  let countdown = 3;
  msg.textContent = `Round complete — restarting in ${countdown}`;
  countdownBadge.style.display = '';
  countdownBadge.textContent = `Restarting in ${countdown}s`;
  _intermissionTimer = setInterval(()=>{
    countdown -= 1;
    if(countdown > 0){
      msg.textContent = `Round complete — restarting in ${countdown}`;
      countdownBadge.textContent = `Restarting in ${countdown}s`;
    } else {
      clearInterval(_intermissionTimer); _intermissionTimer = null;
      countdownBadge.style.display = 'none';
      resetRound();
    }
  }, 1000);
}

// physics and rules
function step(dt){
  // if countdown hasn't finished, don't apply physics so ships stay in place
  if(!running) return;

  for(const role of Object.keys(players)){
    const p = players[role];
      if(p.landed || p.crashed) { p.thrust = 0; continue; }
    // ensure inputs exist for this role
    if(!inputs[role]) inputs[role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    // smooth incoming raw inputs into working values
    inputs[role].beta = inputs[role].beta * (1 - INPUT_SMOOTH) + (inputs[role].rawBeta || 0) * INPUT_SMOOTH;
    inputs[role].gamma = inputs[role].gamma * (1 - INPUT_SMOOTH) + (inputs[role].rawGamma || 0) * INPUT_SMOOTH;
    const beta = inputs[role].beta || 0; const gamma = inputs[role].gamma || 0;
    // thrust mapping: positive beta -> thrust (tilt up increases thrust)
    let thrust = 0;
    if(running){ thrust = Math.max(0, Math.min(1, (beta)/35)); }
    // small deadzone
    if(Math.abs(thrust) < 0.03) thrust = 0;
    // rotation from gamma: left/right tilt -> angular acceleration sign
    const rotInput = Math.max(-1, Math.min(1, (gamma || 0)/30));

    // If off top, left, or right
    if(p.x < 0 || p.x > W || p.y < 0){
      if(thrust === 0){
        p.vy = Math.abs(p.vy) < 40 ? 40 : Math.abs(p.vy); // force downward velocity
        p.vx = 0; // stop horizontal drift
      }
      // If thrusting, allow movement as normal
    }

    // consume fuel
    if(thrust>0 && p.fuel>0){ p.fuel = Math.max(0, p.fuel - FUEL_CONSUMPTION * thrust * dt); }
    if(p.fuel<=0) thrust = 0;

    // thrust vector in ship's local -y direction
    const ax = Math.sin(p.angle) * (thrust) * THRUST_POWER;
    const ay = Math.cos(p.angle) * (-thrust) * THRUST_POWER;
    // apply gravity
    p.vx += ax * dt;
    p.vy += (ay + GRAVITY) * dt;
    // angular acceleration
    p.av += rotInput * ROT_TORQUE * dt;
    // auto-level assist nudges angular acceleration toward 0 when near upright
    p.av += (-p.angle) * AUTO_LEVEL_FACTOR * dt;
    p.angle += p.av * dt;
    // damping angular velocity slightly
    p.av *= 0.995;
    // position
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    p.thrust = thrust;

    // collision: use pad y if above pad, terrain otherwise
    const padIndex = pads.findIndex(pd => p.x >= pd.x - pd.w/2 && p.x <= pd.x + pd.w/2);
    let collisionY;
    if (padIndex !== -1) {
      // Pad top is pads[padIndex].y - 6
      collisionY = pads[padIndex].y - 16; // pad top minus lander height (10) and pad thickness (6)
    } else {
      // Terrain collision
      collisionY = groundYAt(p.x) - 14;
    }
    if (p.y >= collisionY) {
      const safeV = Math.abs(p.vy) < 40; // px/s
      const upright = Math.abs(p.angle) < 0.35; // ~20 deg
      if (padIndex !== -1 && safeV && upright) {
        // Landed on pad
        p.landed = true;
        p.x = pads[padIndex].x;
        p.y = pads[padIndex].y - 16;
        p.vx = 0; p.vy = 0; p.av = 0;
          scores[role] = (scores[role] || 0) + 1;
          p.score = scores[role];
        pads[padIndex].landed = true;
        pads[padIndex].landedBy = role;
        // update DOM score if present
        const scoreEl = document.getElementById(`${role}Score`);
        if(scoreEl) scoreEl.textContent = p.score;
        msg.textContent = `${role} landed successfully!`;
      } else {
        // Crashed (either on pad or terrain)
        p.crashed = true;
        p.y = collisionY;
        p.vx = 0; p.vy = 0; p.av = 0;
        msg.textContent = `${role} crashed...`;
      }
    }
    // keep in bounds
    p.x = Math.max(10, Math.min(W-10, p.x));
    p.y = Math.max(10, Math.min(H-10, p.y));
  }

  if(running && allPlayersSettled()){
    startIntermission();
  }
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if (!room || room.length !== 3) {
    room = 'DEF'; // fallback
  }
  return room.toUpperCase();
}
const ROOM_ID = getRoomId();
// create unified room badge and helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// Top-left countdown badge
const countdownBadge = (function(){
  let cb = document.getElementById('countdownBadge');
  if(!cb){ cb = document.createElement('div'); cb.id='countdownBadge'; cb.style.display='none'; document.body.appendChild(cb); }
  return cb;
})();

// initial layout (after badges exist)
resizeCanvasToDisplay();
resetRound();

// websocket hookup reuse /api/token
let ws = null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  let wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  // Add room id to wsUrl
  wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{
    appendLog(`Connected, Room ID: ${ROOM_ID}`);
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room: ${ROOM_ID}`);
    // Ask others for room meta and also announce our current understanding
    try { ws.send(JSON.stringify({ type: 'request-meta', t: Date.now() })); } catch(e){}
    try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
  };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if(!d) return;
      // Room metadata updates
      if (d.type === 'room-meta' && d.playerCount !== undefined) {
        applyPlayerCountFromMeta(d.playerCount);
        return;
      }
      if (d.type === 'request-meta') {
        try { ws.send(JSON.stringify({ type: 'room-meta', playerCount: playerCount, t: Date.now() })); } catch(e){}
        return;
      }
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || playerMsg.role==null) continue;
          if(playerMsg.room && playerMsg.room.toUpperCase() !== ROOM_ID) continue;
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined && playerMsg.orientBeta!==null){
            if(!inputs[playerMsg.role]) inputs[playerMsg.role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
            inputs[playerMsg.role].rawBeta = playerMsg.orientBeta;
            inputs[playerMsg.role].rawGamma = playerMsg.orientGamma;
          } else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            if(!inputs[playerMsg.role]) inputs[playerMsg.role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
            inputs[playerMsg.role].rawBeta += (playerMsg.beta||0) * 0.02;
            inputs[playerMsg.role].rawGamma += (playerMsg.gamma||0) * 0.02;
          }
        }
      }
    }catch(e){}
  };
  ws.onclose = ()=>{ appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); };
}).catch(e=>{ appendLog('No backend /api/token'); });

// keyboard fallback for local testing — mapped to the first two active roles
window.addEventListener('keydown', (ev)=>{
  const roles = Object.keys(players);
  if(roles.length >= 1){
    const r = roles[0]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    if(ev.key==='w') inputs[r].rawBeta = -20;
    if(ev.key==='s') inputs[r].rawBeta = 20;
    if(ev.key==='a') inputs[r].rawGamma = -20;
    if(ev.key==='d') inputs[r].rawGamma = 20;
  }
  if(roles.length >= 2){
    const r = roles[1]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    if(ev.key==='ArrowUp') inputs[r].rawBeta = -20;
    if(ev.key==='ArrowDown') inputs[r].rawBeta = 20;
    if(ev.key==='ArrowLeft') inputs[r].rawGamma = -20;
    if(ev.key==='ArrowRight') inputs[r].rawGamma = 20;
  }
});
window.addEventListener('keyup', (ev)=>{
  const roles = Object.keys(players);
  if(roles.length >= 1){ const r = roles[0]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0}; if(['w','s','a','d'].includes(ev.key)) { inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; } }
  if(roles.length >= 2){ const r = roles[1]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0}; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(ev.key)) { inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; } }
});

// animation
let last = performance.now();
function frame(now){
  const dt = Math.min(60, now-last)/1000; last = now;
  // physics
  step(dt);
  // draw
  ctx.clearRect(0,0,W,H);
  drawGround();
  drawPads();
  // draw all players in order
  const roleKeys = Object.keys(players);
  for(const role of roleKeys){
    const color = role==='blue' ? '#4ea1ff' : role==='red' ? '#ff6b6b' : role==='yellow' ? '#ffd86b' : role==='green' ? '#8fe58f' : role==='orange' ? '#ff9f4d' : role==='purple' ? '#b58cff' : role==='cyan' ? '#4de6e6' : '#ff6bff';
    drawLander(players[role], color);
  }
  drawHUD();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

restartBtn.addEventListener('click', ()=>{ resetRound(); appendLog('Round reset');
  for(const role of Object.keys(players)){
    const el = document.getElementById(`${role}Score`);
    if(el) el.textContent = players[role].score || 0;
  }
});

</script>
</body>
</html>
