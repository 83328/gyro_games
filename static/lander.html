<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Lander — Gyro Games</title>
  <style>
    html,body{height:100%}
    body{font-family:Arial,Helvetica,sans-serif;background:#050612;color:#e6eefc;display:flex;flex-direction:column;align-items:center;padding:12px;box-sizing:border-box;overflow:hidden}
  canvas{background:linear-gradient(#001, #002233);border:2px solid #223;margin:8px;max-width:100%;height:auto}
  #msg{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(0,0,0,0.4);padding:8px 12px;border-radius:6px;color:#cfe;font-weight:600}
    .hud{display:flex;gap:12px;align-items:center}
    button{padding:.4rem .8rem;border-radius:6px;border:none;background:#1f6feb;color:white}
    .score{font-size:14px}
  </style>
</head>
<body>
  <h1>Moon Lander</h1>
  <div class="hud">
    <label style="margin-left:8px">Players:
      <select id="playerCount" style="margin-left:6px">
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
        </select>
    </label>
    <button id="restart">Restart</button>
    <button id="fs">Fullscreen</button>
    <!-- per-role score containers will be appended here -->
    <div id="scoresHolder" class="scores" style="display:flex;gap:12px;align-items:center;margin-left:12px"></div>
  </div>
  <canvas id="c" width="700" height="420"></canvas>
  <div id="msg" style="color:#cfe">Connecting...</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const msg = document.getElementById('msg');
// score elements are created dynamically in #scoresHolder
const scoresHolder = document.getElementById('scoresHolder');
const restartBtn = document.getElementById('restart');

// Game settings — tuned to be easier to control
const GRAVITY = 10; // reduced gravity for easier hovering
const THRUST_POWER = 40; // thrust
const ROT_TORQUE = 1.4; // gentler rotation torque for smoother turning
const FUEL_CONSUMPTION = 5.0; // consumption
const INPUT_SMOOTH = 0.12; // smoothing factor for incoming beta/gamma
const AUTO_LEVEL_FACTOR = 1.6; // auto-level assist strength

// ground generation
let W = canvas.width, H = canvas.height;
let ground = [];
let pads = [];
// Resize canvas to fit available viewport while preserving aspect ratio
const TARGET_ASPECT = 700/420; // original aspect
function resizeCanvasToDisplay(){
  // reserve space for header and HUD
  const headerH = (document.querySelector('h1')?.offsetHeight || 40) + (document.querySelector('.hud')?.offsetHeight || 40) + 32;
  // Prefer visualViewport dimensions when available (handles fullscreen/mobile chrome UI)
  const vv = window.visualViewport;
  const availW = Math.max(320, (vv?.width || window.innerWidth) - 24);
  const availH = Math.max(240, ( (vv?.height || window.innerHeight) - headerH - 24));
  // fit to available area preserving aspect
  let newW = Math.min(availW, Math.floor(availH * TARGET_ASPECT));
  let newH = Math.floor(newW / TARGET_ASPECT);
  // if width would be too small for height, swap
  if(newH > availH){ newH = availH; newW = Math.floor(newH * TARGET_ASPECT); }
  canvas.width = Math.max(320, newW);
  canvas.height = Math.max(240, newH);
  W = canvas.width; H = canvas.height;
  // regenerate ground and reinitialize players/pads to match new size
  genGround();
  initPlayers();
}
// Debounced resize helper to avoid thrashing when visualViewport fires many events
let _resizeTimer = null;
function scheduleResize(){ if(_resizeTimer) clearTimeout(_resizeTimer); _resizeTimer = setTimeout(()=>{ resizeCanvasToDisplay(); _resizeTimer = null; }, 80); }

// Listen to visualViewport changes which occur on fullscreen and when mobile browser chrome hides/shows
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', scheduleResize);
  window.visualViewport.addEventListener('scroll', scheduleResize);
}
// Also listen to orientation change
window.addEventListener('orientationchange', scheduleResize);
function genGround(){
  ground = [];
  const segments = 14;
  for(let i=0;i<=segments;i++){
    const x = i*(W/segments);
    const y = H - 40 - Math.round(Math.sin(i*1.2)*20) - Math.random()*14;
    ground.push({x,y});
  }
}
function groundYAt(x){
  // linear interpolate between points
  for(let i=0;i<ground.length-1;i++){
    const a=ground[i], b=ground[i+1];
    if(x>=a.x && x<=b.x){
      const t=(x-a.x)/(b.x-a.x); return a.y*(1-t)+b.y*t;
    }
  }
  return H-20;
}

// players state (dynamic based on selected player count). Roles in order: blue, red, yellow, green, orange, purple, cyan, magenta
const ROLE_ORDER = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
let players = {};
let running = false; // whether physics/controls are active
let _countdownTimer = null;

function initPlayers(){
  const n = parseInt(document.getElementById('playerCount')?.value || 2, 10);
  players = {};
  const gap = W / (n + 1);
  for(let i=0;i<n;i++){
    const role = ROLE_ORDER[i];
    players[role] = { x: gap*(i+1), y: Math.max(60, H*0.12), vx:0, vy:0, angle:0, av:0, thrust:0, fuel:100, landed:false, crashed:false, score:0 };
  }
  // build pads evenly across width
  pads = [];
  const padW = 60;
  for(let i=0;i<n;i++){
    const px = Math.floor((i+1) * W / (n+1));
    const role = ROLE_ORDER[i];
    pads.push({ x: px, y: groundYAt(px), w: padW, role });
  }
  // rebuild the per-role score containers in the scoresHolder
  if(scoresHolder){
    // clear existing
    scoresHolder.innerHTML = '';
    const roleColors = {
      blue: '#4ea1ff', red: '#ff6b6b', yellow: '#ffd86b', green: '#8fe58f',
      orange: '#ff9f4d', purple: '#b58cff', cyan: '#4de6e6', magenta: '#ff6bff'
    };
    for(let i=0;i<n;i++){
      const role = ROLE_ORDER[i];
      const el = document.createElement('div');
      el.className = 'score';
      el.id = `${role}ScoreContainer`;
      el.style.color = roleColors[role] || '#fff';
      el.innerHTML = `${role.charAt(0).toUpperCase()+role.slice(1)}: <span id="${role}Score">0</span>`;
      scoresHolder.appendChild(el);
    }
  }
}


// input from websocket (per role): keep raw and smoothed values
const inputs = { blue: {rawBeta:0, rawGamma:0, beta:0, gamma:0}, red:{rawBeta:0, rawGamma:0, beta:0, gamma:0} };

function resetRound(){
  genGround();
  for(const r of Object.keys(players)){
    const p = players[r];
    p.x = Math.max(10, Math.min(W-10, p.x));
    p.y = Math.max(40, H*0.12); p.vx=0; p.vy=0; p.angle=0; p.av=0; p.fuel=100; p.landed=false; p.crashed=false;
    // ensure no immediate thrust on round start
    p.thrust = 0;
    // clear any stale inputs for this role
    if(inputs[r]){ inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; inputs[r].beta = 0; inputs[r].gamma = 0; }
  }
  // begin a new round with countdown
  startCountdown();
}

function startCountdown(){
  // show a 3..2..1 then enable running
  let count = 3;
  running = false;
  msg.textContent = `Starting in ${count}...`;
  if(_countdownTimer) clearInterval(_countdownTimer);
  _countdownTimer = setInterval(()=>{
    count -= 1;
    if(count > 0){ msg.textContent = `Starting in ${count}...`; }
    else { clearInterval(_countdownTimer); msg.textContent = 'Go!'; _countdownTimer = null; beginRun(); }
  }, 1000);
}

function beginRun(){
  // zero thrust and mark running true
  for(const r of Object.keys(players)){ if(players[r]) players[r].thrust = 0; }
  running = true;
}

// initial layout
resizeCanvasToDisplay();
initPlayers();
resetRound();

// respond to window size changes
window.addEventListener('resize', ()=>{ resizeCanvasToDisplay(); });
document.getElementById('playerCount')?.addEventListener('change', ()=>{ initPlayers(); resetRound(); });

// fullscreen toggle
const fsBtn = document.getElementById('fs');
fsBtn.addEventListener('click', ()=>{
  if(!document.fullscreenElement){
    document.documentElement.requestFullscreen?.();
  } else {
    document.exitFullscreen?.();
  }
});

// adjust on fullscreen change
document.addEventListener('fullscreenchange', ()=>{ setTimeout(resizeCanvasToDisplay, 80); });

// draw
function drawGround(){
  ctx.fillStyle='#223'; ctx.beginPath(); ctx.moveTo(0,H);
  for(const p of ground) ctx.lineTo(p.x,p.y);
  ctx.lineTo(W,H); ctx.closePath(); ctx.fill();
  // pads
  for(const [i,p] of pads.entries()){
    // pad colored by role
    const color = p.role==='blue' ? '#4ea1ff' : p.role==='red' ? '#ff6b6b' : p.role==='yellow' ? '#ffd86b' : p.role==='green' ? '#8fe58f' : p.role==='orange' ? '#ff9f4d' : p.role==='purple' ? '#b58cff' : p.role==='cyan' ? '#4de6e6' : '#ff6bff';
    ctx.fillStyle = color;
    ctx.fillRect(p.x - p.w/2, p.y-6, p.w, 10);
    ctx.strokeStyle = '#fff'; ctx.strokeRect(p.x - p.w/2, p.y-6, p.w, 10);
  }
}

function drawLander(pl, color){
  ctx.save(); ctx.translate(pl.x, pl.y); ctx.rotate(pl.angle);
  ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.closePath(); ctx.fill();
  // flame
  if(pl.thrust>0 && pl.fuel>0){ ctx.fillStyle='orange'; ctx.beginPath(); ctx.moveTo(-6,10); ctx.lineTo(0,10+Math.random()*8*pl.thrust); ctx.lineTo(6,10); ctx.closePath(); ctx.fill(); }
  ctx.restore();
}

function drawHUD(){
  ctx.fillStyle='white'; ctx.font='12px monospace';
  let y = 12;
  for(const role of Object.keys(players)){
    const p = players[role];
    ctx.fillText(`${role.charAt(0).toUpperCase()+role.slice(1)} fuel:${p.fuel.toFixed(0)} vx:${p.vx.toFixed(1)} vy:${p.vy.toFixed(1)} ang:${(p.angle*57.3).toFixed(0)}`, 8,y);
    y += 18;
  }
  // fuel bars: stack on right side
  const fw = 120, fh = 8;
  let fy = 8;
  for(const role of Object.keys(players)){
    const p = players[role];
    ctx.fillStyle='#333'; ctx.fillRect(W - fw - 10, fy, fw, fh);
    // color by role
    const color = role==='blue' ? '#4ea1ff' : role==='red' ? '#ff6b6b' : role==='yellow' ? '#ffd86b' : role==='green' ? '#8fe58f' : role==='orange' ? '#ff9f4d' : role==='purple' ? '#b58cff' : role==='cyan' ? '#4de6e6' : '#ff6bff';
    ctx.fillStyle = color; ctx.fillRect(W - fw - 10, fy, fw * (p.fuel/100), fh);
    fy += fh + 8;
  }
}

// physics and rules
function step(dt){
  // if countdown hasn't finished, don't apply physics so ships stay in place
  if(!running) return;

  for(const role of Object.keys(players)){
    const p = players[role];
    if(p.landed || p.crashed) { p.thrust = 0; continue; }
    // ensure inputs exist for this role
    if(!inputs[role]) inputs[role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
  // smooth incoming raw inputs into working values
  inputs[role].beta = inputs[role].beta * (1 - INPUT_SMOOTH) + (inputs[role].rawBeta || 0) * INPUT_SMOOTH;
  inputs[role].gamma = inputs[role].gamma * (1 - INPUT_SMOOTH) + (inputs[role].rawGamma || 0) * INPUT_SMOOTH;
  const beta = inputs[role].beta || 0; const gamma = inputs[role].gamma || 0;
  // thrust mapping: positive beta -> thrust (tilt up increases thrust)
  let thrust = 0;
  if(running){ thrust = Math.max(0, Math.min(1, (beta)/35)); }
    // small deadzone
    if(Math.abs(thrust) < 0.03) thrust = 0;
    // rotation from gamma: left/right tilt -> angular acceleration sign
    const rotInput = Math.max(-1, Math.min(1, (gamma || 0)/30));

    // consume fuel
    if(thrust>0 && p.fuel>0){ p.fuel = Math.max(0, p.fuel - FUEL_CONSUMPTION * thrust * dt); }
    if(p.fuel<=0) thrust = 0;

    // thrust vector in ship's local -y direction
    const ax = Math.sin(p.angle) * (thrust) * THRUST_POWER;
    const ay = Math.cos(p.angle) * (-thrust) * THRUST_POWER;
    // apply gravity
    p.vx += ax * dt;
    p.vy += (ay + GRAVITY) * dt;
    // angular acceleration
    p.av += rotInput * ROT_TORQUE * dt;
    // auto-level assist nudges angular acceleration toward 0 when near upright
    p.av += (-p.angle) * AUTO_LEVEL_FACTOR * dt;
    p.angle += p.av * dt;
    // damping angular velocity slightly
    p.av *= 0.995;
    // position
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    p.thrust = thrust;

    // ground collision — compare using the lander's bottom point so it rests on top of pads
    const gy = groundYAt(p.x);
    // lander bottom is at p.y + 10 (drawn with base at y=10), pad top is at gy - 4
    // so contact when p.y >= gy - 14
    if(p.y >= gy - 14){
      // landed surface contact
      // check if inside pad and gentle landing
      const padIndex = pads.findIndex(pd => p.x >= pd.x - pd.w/2 && p.x <= pd.x + pd.w/2);
      const safeV = Math.abs(p.vy) < 40; // px/s
      const upright = Math.abs(p.angle) < 0.35; // ~20 deg
      if(padIndex !== -1 && safeV && upright){
        p.landed = true; p.y = gy - 14; p.vx = 0; p.vy = 0; p.av = 0;
        p.score = (p.score || 0) + 1;
        // update DOM score if present
        const scoreEl = document.getElementById(`${role}Score`);
        if(scoreEl) scoreEl.textContent = p.score;
        msg.textContent = `${role} landed successfully!`;
      } else {
        p.crashed = true; p.y = gy - 14; p.vx = 0; p.vy = 0; p.av = 0;
        msg.textContent = `${role} crashed...`;
      }
    }
    // keep in bounds
    p.x = Math.max(10, Math.min(W-10, p.x));
    p.y = Math.max(10, Math.min(H-10, p.y));
  }
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if (!room || room.length !== 3) {
    room = 'DEF'; // fallback
  }
  return room.toUpperCase();
}
const ROOM_ID = getRoomId();

// websocket hookup reuse /api/token
let ws = null;
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token = data.token;
  const proto = (location.protocol==='https:')?'wss':'ws';
  let wsUrl = data.ws_url ? (data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)) : `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  // Add room id to wsUrl
  wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=>{ msg.textContent=`Connected, Room ID: ${ROOM_ID}`; };
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if(!d || d.role==null) return;
      // Only process messages for this room
      if (d.room && d.room.toUpperCase() !== ROOM_ID) return;
      // normalize short role codes (b/r/y/g/o/p/c/m -> blue/red/yellow/green/orange/purple/cyan/magenta)
      if(typeof d.role === 'string' && d.role.length === 1){
        d.role = (
          d.role === 'b' ? 'blue' :
          d.role === 'r' ? 'red' :
          d.role === 'y' ? 'yellow' :
          d.role === 'g' ? 'green' :
          d.role === 'o' ? 'orange' :
          d.role === 'p' ? 'purple' :
          d.role === 'c' ? 'cyan' :
          d.role === 'm' ? 'magenta' : d.role
        );
      }
      if(d.orientBeta!==undefined && d.orientGamma!==undefined && d.orientBeta!==null){
        if(!inputs[d.role]) inputs[d.role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
        inputs[d.role].rawBeta = d.orientBeta;
        inputs[d.role].rawGamma = d.orientGamma;
      } else if(d.beta!==undefined && d.gamma!==undefined){
        if(!inputs[d.role]) inputs[d.role] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
        inputs[d.role].rawBeta += (d.beta||0) * 0.02;
        inputs[d.role].rawGamma += (d.gamma||0) * 0.02;
      }
    }catch(e){}
  };
  ws.onclose = ()=>{ msg.textContent='Disconnected'; };
}).catch(e=>{ msg.textContent='No backend /api/token'; });

// keyboard fallback for local testing — mapped to the first two active roles
window.addEventListener('keydown', (ev)=>{
  const roles = Object.keys(players);
  if(roles.length >= 1){
    const r = roles[0]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    if(ev.key==='w') inputs[r].rawBeta = -20;
    if(ev.key==='s') inputs[r].rawBeta = 20;
    if(ev.key==='a') inputs[r].rawGamma = -20;
    if(ev.key==='d') inputs[r].rawGamma = 20;
  }
  if(roles.length >= 2){
    const r = roles[1]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0};
    if(ev.key==='ArrowUp') inputs[r].rawBeta = -20;
    if(ev.key==='ArrowDown') inputs[r].rawBeta = 20;
    if(ev.key==='ArrowLeft') inputs[r].rawGamma = -20;
    if(ev.key==='ArrowRight') inputs[r].rawGamma = 20;
  }
});
window.addEventListener('keyup', (ev)=>{
  const roles = Object.keys(players);
  if(roles.length >= 1){ const r = roles[0]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0}; if(['w','s','a','d'].includes(ev.key)) { inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; } }
  if(roles.length >= 2){ const r = roles[1]; if(!inputs[r]) inputs[r] = {rawBeta:0, rawGamma:0, beta:0, gamma:0}; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(ev.key)) { inputs[r].rawBeta = 0; inputs[r].rawGamma = 0; } }
});

// animation
let last = performance.now();
function frame(now){
  const dt = Math.min(60, now-last)/1000; last = now;
  // physics
  step(dt);
  // draw
  ctx.clearRect(0,0,W,H);
  drawGround();
  // draw all players in order
  const roleKeys = Object.keys(players);
  for(const role of roleKeys){
    const color = role==='blue' ? '#4ea1ff' : role==='red' ? '#ff6b6b' : role==='yellow' ? '#ffd86b' : role==='green' ? '#8fe58f' : role==='orange' ? '#ff9f4d' : role==='purple' ? '#b58cff' : role==='cyan' ? '#4de6e6' : '#ff6bff';
    drawLander(players[role], color);
  }
  drawHUD();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

restartBtn.addEventListener('click', ()=>{ resetRound(); msg.textContent='Round reset';
  for(const role of Object.keys(players)){
    const el = document.getElementById(`${role}Score`);
    if(el) el.textContent = players[role].score || 0;
  }
});

</script>
</body>
</html>
