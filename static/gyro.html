<!-- ~/gyro_stream/static/gyro.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Gyro Stream</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; padding: 0.6rem; margin:0; display:flex; flex-direction:column; align-items:stretch; gap:8px; background:#111; color:#fff }
  .controls{ display:flex; flex-direction:column; gap:8px; align-items:stretch }
    button { padding: 0.6rem 0.8rem; flex:1; border-radius:8px; border:none; font-weight:600 }
  .roles{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; --cols:4; }
  /* color the role buttons to match players */
  /* Use a CSS variable --cols to control equal-width buttons for N visible columns */
  .roles button { color: #012; font-weight:700; border-radius:8px; flex: 0 0 calc(100% / var(--cols) - 8px); min-width:88px; text-align:center }
  button[data-role="blue"]{ background:#4ea1ff; color:#042434 }
  button[data-role="red"]{ background:#ff6b6b; color:#3b0000 }
  button[data-role="yellow"]{ background:#ffd86b; color:#332900 }
  button[data-role="green"]{ background:#8fe58f; color:#042a04 }
  button[data-role="orange"]{ background:#ff9f4d; color:#2b1300 }
  button[data-role="purple"]{ background:#b58cff; color:#1f0533 }
  button[data-role="cyan"]{ background:#4de6e6; color:#022525 }
  button[data-role="magenta"]{ background:#ff6bff; color:#330033 }
  .roles button.selected{ outline:3px solid rgba(255,255,255,0.12); transform:translateY(-2px); box-shadow:0 6px 14px rgba(0,0,0,0.35); }
    @media (max-width:420px){ h2{font-size:16px} button{padding:10px 6px; font-size:14px} }
  /* larger, more tappable player count select */
  #transmitPlayerCount {
    font-size: 1rem;
    padding: 0.45rem 0.6rem;
    min-width: 88px;
    border-radius: 8px;
    background: #1b1b1b;
    color: #fff;
    border: 1px solid #333;
  }
  /* thin visual spacer between selector and the start/stop row */
  .spacer { height: 10px; width:100%; }
  </style>
</head>
<body>
  <h2 style="margin:0;">Select a colour to start</h2>
  <div class="controls">
    <div><span id="status">Starting…</span></div>
  </div>
  <div style="height:100px;">&nbsp;</div>
  <div class="roles">
    <div style="position:fixed;bottom:0;left:0;width:100%;background:#111;padding:12px 0 8px 0;display:flex;align-items:center;justify-content:center;gap:8px;z-index:10;box-shadow:0 -2px 12px #0008;flex-wrap:wrap;">
      <label for="roomIdInput" id="roomIdLabel" style="font-weight:600;color:#fff;">Room ID:</label>
  <input id="roomIdInput" type="text" maxlength="3" pattern="[A-Z]{3}" style="width:60px;text-transform:uppercase;font-size:1.1em;padding:4px 8px;border-radius:6px;border:1px solid #333;background:#222;color:#fff;text-align:center" value="" autocomplete="off" />
      <button id="setRoomBtn" style="padding:4px 10px;border-radius:6px;background:#1f6feb;color:#fff;font-weight:600">Set</button>
    </div>

    <!-- iOS permission overlay (hidden by default) -->
    <div id="permOverlay" style="display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:50"> 
      <div style="background:#111;padding:18px;border-radius:12px;border:1px solid #333;text-align:center;color:#fff;max-width:320px;margin:0 20px">
        <div style="font-weight:700;margin-bottom:8px">Enable motion</div>
        <div style="margin-bottom:12px;font-size:0.95em;opacity:0.9">Your browser requires permission to access motion sensors. Tap to enable and start streaming.</div>
        <button id="permBtn" style="padding:10px 14px;border-radius:8px;background:#1f6feb;color:#fff;border:none;font-weight:700">Enable motion & start</button>
        <div style="margin-top:10px;font-size:0.85em;opacity:0.8">You can change this later in Settings → Motion & Orientation</div>
      </div>
    </div>
    <button id="roleBlue" data-role="blue">Blue</button>
    <button id="roleRed" data-role="red">Red</button>
    <button id="roleYellow" data-role="yellow">Yellow</button>
    <button id="roleGreen" data-role="green">Green</button>
    <button id="roleOrange" data-role="orange">Orange</button>
    <button id="rolePurple" data-role="purple">Purple</button>
    <button id="roleCyan" data-role="cyan">Cyan</button>
    <button id="roleMagenta" data-role="magenta">Magenta</button>
  </div>

<script>
let AUTH_TOKEN = null;
// No start/stop button: streaming will start automatically
const statusEl = document.getElementById('status');

let socket = null;
let listening = false;
let sendCount = 0;
let role = null; // will be auto-assigned when we join a room (first-come order)
let latestOrientation = {alpha: null, beta: null, gamma: null};
// role index map for binary packing
const ROLE_INDEX = { blue:0, red:1, yellow:2, green:3, orange:4, purple:5, cyan:6, magenta:7 };

// Track claimed roles in this room (other clients have reserved them)
let claimedRoles = new Set();
// Wake lock sentinel
let wakeLock = null;
// Track a role the user chose locally before we have a websocket open
let pendingLocalRole = null;

async function requestWakeLock() {
  if (!('wakeLock' in navigator)) {
    log('Wake Lock API not supported');
    return false;
  }
  try {
    wakeLock = await navigator.wakeLock.request('screen');
    log('Wake lock acquired');
    // if the lock is released by the UA (e.g. screen off), null it
    wakeLock.addEventListener('release', () => {
      log('Wake lock released by UA');
      wakeLock = null;
    });
    return true;
  } catch (err) {
    log('Wake lock request failed: ' + err);
    wakeLock = null;
    return false;
  }
}

async function releaseWakeLock() {
  try {
    if (wakeLock) {
      await wakeLock.release();
      wakeLock = null;
      log('Wake lock released');
    }
  } catch (err) {
    log('Failed to release wake lock: ' + err);
  }
}

function log(s){ console.debug('[gyro]', s); }

// Send a small non-gaming claim/release message over the room to inform other clients
function sendClaim(r, action = 'claim') {
  if (!r) return; // nothing to claim/release
  if (!socket || socket.readyState !== WebSocket.OPEN) return;
  const msg = JSON.stringify({ type: 'role-claim', role: r, action: action, t: Date.now() });
  try { socket.send(msg); } catch (e) { /* best-effort */ }
}

// Update button UI to reflect which roles are claimed by others
function updateRoleButtons() {
  const roles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  roles.forEach(roleName => {
    const btn = document.querySelector(`button[data-role="${roleName}"]`);
    if (!btn) return;
    if (claimedRoles.has(roleName) && roleName !== role) {
      btn.disabled = true;
      btn.style.opacity = '0.35';
      btn.style.filter = 'grayscale(80%)';
      btn.title = 'Taken in this room';
    } else {
      btn.disabled = false;
      btn.style.opacity = '';
      btn.style.filter = '';
      btn.title = '';
    }
  });
}

// UI state helpers
function setUiDisconnected() {
  const roles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  roles.forEach(roleName => {
    const btn = document.querySelector(`button[data-role="${roleName}"]`);
    if (!btn) return;
    btn.disabled = true;
    btn.style.opacity = '0.35';
    btn.style.filter = 'grayscale(80%)';
  });
  // remove any colored background so disconnection is visually obvious
  document.body.style.background = '#111';
  document.body.style.color = '#fff';
  // allow quickly changing the room when disconnected
  try {
    if (setRoomBtn) {
      setRoomBtn.disabled = false;
      setRoomBtn.setAttribute('aria-disabled', 'false');
      setRoomBtn.style.opacity = '';
      setRoomBtn.style.filter = '';
      setRoomBtn.textContent = 'Reconnect';
    }
    if (roomIdInput) roomIdInput.focus();
  } catch (e) { /* best-effort */ }
}

function setUiConnected() {
  // restore per-role enabled/disabled according to claims and show selected color
  updateRoleButtons();
  try { applyRoleColor(role); } catch (e) { /* best-effort */ }
  // re-run room input validation so Set returns to its normal enabled/disabled state
  try { if (roomIdInput) roomIdInput.dispatchEvent(new Event('input')); } catch (e) {}
  try { if (setRoomBtn) setRoomBtn.textContent = 'Set'; } catch (e) {}
}

// Wrap the role button clicks so we claim the new role and release the old one
function claimableRoleClick(targetRole) {
  if (claimedRoles.has(targetRole) && targetRole !== role) {
    // already taken by someone else
    return;
  }
  const prev = role;
  if (prev === targetRole) return; // no change

  // If we're connected, perform optimistic claim immediately (as before)
  if (socket && socket.readyState === WebSocket.OPEN) {
    try {
      if (prev) {
        claimedRoles.delete(prev);
        if (socket && socket.readyState === WebSocket.OPEN) sendClaim(prev, 'release');
      }
    } catch (e) { /* best-effort */ }

    role = targetRole;

    try {
      claimedRoles.add(role);
      if (socket && socket.readyState === WebSocket.OPEN) sendClaim(role, 'claim');
    } catch (e) { /* best-effort */ }

    updateRoleButtons();
    applyRoleColor(role);
    // clear any pending local choice (shouldn't be one while connected)
    pendingLocalRole = null;
    return;
  }

  // Not connected: record the user's desired role but do not add to claimedRoles yet
  role = targetRole;
  pendingLocalRole = targetRole;
  // visually show their selection but do not disable other buttons (we don't know room state yet)
  applyRoleColor(role);
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room;
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function getPlayerCount() {
  const params = new URLSearchParams(window.location.search);
  const count = parseInt(params.get('players'), 10);
  if (count >= 2 && count <= 8) return count;
  return 2;
}

let ROOM_ID = getRoomId();
let PLAYER_COUNT = getPlayerCount();

// Apply a new player count coming from room metadata and update UI
function applyPlayerCount(countFromRoom){
  const n = parseInt(countFromRoom, 10);
  if (!(n >= 2 && n <= 8)) return;
  if (n === PLAYER_COUNT) return;
  PLAYER_COUNT = n;

  // Update URL param so refreshes stay in sync
  try {
    const newUrl = new URL(window.location);
    newUrl.searchParams.set('players', PLAYER_COUNT);
    window.history.replaceState({}, '', newUrl);
  } catch (e) { /* best-effort */ }

  updateVisibleRoles();

  // If the current role is now hidden, release it
  const allRoles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  const idx = allRoles.indexOf(role);
  if (idx >= PLAYER_COUNT) {
    try { releaseMyClaim(); } catch (e) {}
    role = null;
    pendingLocalRole = null;
    applyRoleColor(null);
  }
}

// Hide role buttons based on player count
function updateVisibleRoles() {
  const allRoles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  const visible = allRoles.slice(0, PLAYER_COUNT);
  allRoles.forEach((roleName, idx) => {
    const btn = document.querySelector(`button[data-role="${roleName}"]`);
    if (!btn) return;
    btn.style.display = idx < PLAYER_COUNT ? '' : 'none';
  });
  const rolesContainer = document.querySelector('.roles');
  if (rolesContainer) {
    rolesContainer.style.setProperty('--cols', Math.min(4, PLAYER_COUNT));
  }
}

updateVisibleRoles();

// Room ID input logic
const roomIdInput = document.getElementById('roomIdInput');
const setRoomBtn = document.getElementById('setRoomBtn');
if (roomIdInput) roomIdInput.value = ROOM_ID;
// disable Set until the user types a valid, different room
if (setRoomBtn) {
  setRoomBtn.disabled = true;
  setRoomBtn.setAttribute('aria-disabled', 'true');
  setRoomBtn.style.opacity = '0.35';
  setRoomBtn.style.filter = 'grayscale(80%)';

  // enable only when input is a valid 3-letter code and differs from current ROOM_ID
  const validateInput = () => {
    const val = (roomIdInput.value || '').toUpperCase().replace(/[^A-Z]/g, '');
    const enable = val.length === 3 && val !== ROOM_ID;
    setRoomBtn.disabled = !enable;
    setRoomBtn.setAttribute('aria-disabled', (!enable).toString());
    if (!enable) {
      setRoomBtn.style.opacity = '0.35';
      setRoomBtn.style.filter = 'grayscale(80%)';
    } else {
      setRoomBtn.style.opacity = '';
      setRoomBtn.style.filter = '';
    }
  };
  roomIdInput.addEventListener('input', validateInput);

  setRoomBtn.addEventListener('click', () => {
    let val = (roomIdInput.value || '').toUpperCase().replace(/[^A-Z]/g, '');
    if (val.length === 3) {
      // If we're currently streaming, stop first (releases claim etc.) so we can reconnect cleanly
      try { if (listening) stopStreaming(); } catch (e) {}

      // clear any known claims from previous room
      claimedRoles.clear();
      pendingLocalRole = null;
      
      ROOM_ID = val;
      roomIdInput.value = ROOM_ID;
      
      // Reset player count to default when switching rooms - we'll discover the real count from room-meta
      PLAYER_COUNT = 2;
      
      // Update URL to reflect new room and remove stale players param
      const newUrl = new URL(window.location);
      newUrl.searchParams.set('room', ROOM_ID);
      newUrl.searchParams.delete('players');
      window.history.replaceState({}, '', newUrl);
      
      // Reset visible roles to default before we learn the room's actual count
      updateVisibleRoles();
      
      statusEl.textContent = `Room set to ${ROOM_ID} — connecting...`;

      // restart streaming / websocket for the new room
      try { startStreaming(); } catch (e) { log('startStreaming failed: ' + e); }
      // keep button disabled until further changes
      setRoomBtn.disabled = true;
      setRoomBtn.setAttribute('aria-disabled', 'true');
      setRoomBtn.style.opacity = '0.35';
      setRoomBtn.style.filter = 'grayscale(80%)';
    } else {
      statusEl.textContent = 'Room ID must be 3 letters';
    }
  });
}
// validate initial state in case user edited the URL before page load
if (roomIdInput) {
  setTimeout(() => roomIdInput.dispatchEvent(new Event('input')), 0);
}

function buildWsUrl() {
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  return `${proto}://${location.host}/ws?token=${encodeURIComponent(AUTH_TOKEN)}&room=${ROOM_ID}`;
}

// Fetch token from backend before starting
fetch('/api/token')
  .then(response => response.json())
  .then(data => {
    AUTH_TOKEN = data.token;
    log('Loaded token from backend');
  })
  .catch(err => {
    log('Failed to fetch token: ' + err);
  });

function openSocket() {
  const url = buildWsUrl();
  log('Connecting: ' + url);
  socket = new WebSocket(url);
  socket.onopen = () => {
    statusEl.textContent = `Connected, Room ID: ${ROOM_ID}`;
    log('WebSocket open');
    // update visible status for auto-start
    statusEl.textContent = `Streaming — Room ${ROOM_ID}`;
    // ask existing clients to announce their claims so we sync
    try { socket.send(JSON.stringify({ type: 'request-claims', t: Date.now() })); } catch (e) {}

    // Ask for current room meta (player count) and also announce what we think it is
    try { socket.send(JSON.stringify({ type: 'request-meta', t: Date.now() })); } catch (e) {}
    try { socket.send(JSON.stringify({ type: 'room-meta', playerCount: PLAYER_COUNT, t: Date.now() })); } catch (e) {}

    // Wait briefly for incoming claim announcements, then reconcile any pending local selection
    setTimeout(() => {
      if (pendingLocalRole) {
        if (!claimedRoles.has(pendingLocalRole)) {
          // safe to claim
          role = pendingLocalRole;
          try { claimedRoles.add(role); if (socket && socket.readyState === WebSocket.OPEN) sendClaim(role, 'claim'); } catch (e) {}
          updateRoleButtons();
          applyRoleColor(role);
        } else {
          // someone else already took it; inform user and clear
          statusEl.textContent = `${pendingLocalRole} is already taken`; 
          // clear the visual selection
          role = null;
          pendingLocalRole = null;
          updateRoleButtons();
        }
      }
    }, 150);

    setUiConnected();
  };
  socket.onclose = () => {
    statusEl.textContent = `WebSocket closed, Room ID: ${ROOM_ID}`;
    log('WebSocket closed');
    setUiDisconnected();
  };
  socket.onerror = (e) => {
    log('Socket error');
    // suppressed console.warn to reduce noise
  };
  socket.onmessage = (ev) => {
    try {
      const data = JSON.parse(ev.data);
      if (!data || !data.type) return;
      if (data.type === 'role-claim' && data.role) {
        if (data.action === 'claim') claimedRoles.add(data.role);
        else if (data.action === 'release') claimedRoles.delete(data.role);
        updateRoleButtons();
      } else if (data.type === 'request-claims') {
        // another client wants current claims; reply with our claim
        if (role) sendClaim(role, 'claim');
      } else if (data.type === 'room-meta') {
        if (data.playerCount !== undefined) {
          applyPlayerCount(data.playerCount);
        }
      } else if (data.type === 'request-meta') {
        // Another peer (or server) is asking for room meta; reply with our current count
        try { socket.send(JSON.stringify({ type: 'room-meta', playerCount: PLAYER_COUNT, t: Date.now() })); } catch (e) {}
      }
    } catch (err) {
      // ignore non-json or malformed messages
    }
  };
}

function handleMotion(e) {
  if (!listening) return;
  const now = Date.now();
  if (!window._lastGyroSent) window._lastGyroSent = 0;
  const MIN_SEND_MS = 100;
  if (now - window._lastGyroSent < MIN_SEND_MS) return;
  window._lastGyroSent = now;
  const r = e.rotationRate || {};
  const acc = e.acceleration || e.accelerationIncludingGravity || {};

  // Binary packet format (little-endian):
  // [0] uint8 message type (1=motion)
  // [1] uint8 role index (0..7)
  // [2..5] uint32 timestamp (ms modulo 2^32)
  // [6..] eight float32 values in order: beta,gamma,orientAlpha,orientBeta,orientGamma,ax,ay,az
  const floats = new Float32Array(8);
  floats[0] = (typeof r.beta === 'number') ? r.beta : 0;
  floats[1] = (typeof r.gamma === 'number') ? r.gamma : 0;
  floats[2] = (typeof latestOrientation.alpha === 'number') ? latestOrientation.alpha : 0;
  floats[3] = (typeof latestOrientation.beta === 'number') ? latestOrientation.beta : 0;
  floats[4] = (typeof latestOrientation.gamma === 'number') ? latestOrientation.gamma : 0;
  floats[5] = (typeof acc.x === 'number') ? acc.x : 0;
  floats[6] = (typeof acc.y === 'number') ? acc.y : 0;
  floats[7] = (typeof acc.z === 'number') ? acc.z : 0;

  const headerBytes = 6; // 1 + 1 + 4
  const buf = new ArrayBuffer(headerBytes + floats.byteLength);
  const dv = new DataView(buf);
  dv.setUint8(0, 1); // motion message type
  dv.setUint8(1, (ROLE_INDEX[role] !== undefined) ? ROLE_INDEX[role] : 255);
  dv.setUint32(2, now >>> 0, true);
  // copy float32 bytes (little-endian)
  const floatBytes = new Uint8Array(buf, headerBytes);
  const src = new Uint8Array(floats.buffer);
  // ensure little-endian layout: Float32Array uses platform endianness, but DataView.setFloat32 would be safe.
  // We'll copy per-float to guarantee LE ordering.
  for (let i = 0; i < floats.length; ++i) {
    dv.setFloat32(headerBytes + i * 4, floats[i], true);
  }

  if (socket && socket.readyState === WebSocket.OPEN) {
    try { socket.send(buf); } catch (err) { /* best-effort */ }
  }
  sendCount += 1;
  if (sendCount % 50 === 0) log('sent binary motion frame len=' + buf.byteLength + ' role=' + role);
}

// role button handlers
function applyRoleColor(r) {
  // highlight the selected role button and keep the rest neutral
  const roles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  roles.forEach(roleName => {
    const btn = document.querySelector(`button[data-role="${roleName}"]`);
    if(!btn) return;
    if(roleName === r) btn.classList.add('selected'); else btn.classList.remove('selected');
  });
  // set the body background and hardcode text color for contrast
  const colorMap = {
    blue:    {bg: '#4ea1ff', text: '#042434'},
    red:     {bg: '#ff6b6b', text: '#3b0000'},
    yellow:  {bg: '#ffd86b', text: '#332900'},
    green:   {bg: '#8fe58f', text: '#042a04'},
    orange:  {bg: '#ff9f4d', text: '#2b1300'},
    purple:  {bg: '#b58cff', text: '#1f0533'},
    cyan:    {bg: '#4de6e6', text: '#022525'},
    magenta: {bg: '#ff6bff', text: '#330033'}
  };
  const style = colorMap[r] || {bg: '#111', text: '#fff'};
  document.body.style.background = style.bg;
  document.body.style.color = style.text;
  // Always keep Room ID label white for visibility
  const roomIdLabel = document.getElementById('roomIdLabel');
  const roomIdInput = document.getElementById('roomIdInput');
  if (roomIdLabel) roomIdLabel.style.color = '#fff';
  if (roomIdInput) roomIdInput.style.color = '#fff';
}

// Bind role buttons to claim-aware click handler
['blue','red','yellow','green','orange','purple','cyan','magenta'].forEach(rn => {
  const el = document.getElementById('role' + rn[0].toUpperCase() + rn.slice(1));
  if (!el) return;
  el.addEventListener('click', () => claimableRoleClick(rn));
});

// Always show all 8 color buttons, no player count selector needed
const rolesContainer = document.querySelector('.roles');
if(rolesContainer) rolesContainer.style.setProperty('--cols', Math.min(4, PLAYER_COUNT).toString());

// keep latest deviceorientation around so we can include it with motion payloads
window.addEventListener('deviceorientation', (ev) => {
  // ev.alpha/beta/gamma can be null on some devices
  latestOrientation.alpha = (ev.alpha !== null && ev.alpha !== undefined) ? ev.alpha : latestOrientation.alpha;
  latestOrientation.beta  = (ev.beta  !== null && ev.beta  !== undefined) ? ev.beta  : latestOrientation.beta;
  latestOrientation.gamma = (ev.gamma !== null && ev.gamma !== undefined) ? ev.gamma : latestOrientation.gamma;
}, {passive:true});

// streaming uses the minimal handleMotion payload (t, beta, role)
// ensure only the basic handler is registered when streaming starts

async function startStreaming() {
  try {
    // iOS requirement: request permission if available
    // request permission for motion and orientation on iOS
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const p = await DeviceMotionEvent.requestPermission();
      if (p !== 'granted') {
        alert('Motion permission denied');
        return;
      }
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try { await DeviceOrientationEvent.requestPermission(); } catch(e) { /* non-fatal */ }
    }
  } catch (err) {
    log('Permission request failed');
  }

  openSocket();
  listening = true;
  window.addEventListener('devicemotion', handleMotion);
  // try to keep the screen awake while streaming
  try { requestWakeLock(); } catch (e) { /* best-effort */ }
  // deviceorientation listener was already added above to cache values; ensure it's active
  // nothing else needed here
  statusEl.textContent = 'Streaming...';
  setUiConnected();
}

function stopStreaming() {
  listening = false;
  window.removeEventListener('devicemotion', handleMotion);
  if (socket) socket.close();
  // release wake lock when we stop
  try { releaseWakeLock(); } catch (e) {}
  statusEl.textContent = 'Stopped';
  setUiDisconnected();
}

// release our claim when we stop streaming (best-effort) and on page unload
function releaseMyClaim() {
  try {
    if (role) claimedRoles.delete(role);
    updateRoleButtons();
    if (socket && socket.readyState === WebSocket.OPEN) sendClaim(role, 'release');
  } catch (e) {}
}
window.addEventListener('beforeunload', releaseMyClaim);

// Re-acquire wake lock when the page becomes visible again (UA may release it)
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible' && listening) {
    // attempt to re-acquire if needed
    if (!wakeLock) await requestWakeLock();
  }
});

// Ensure claim released when stopStreaming is called
const _oldStopStreaming = stopStreaming;
stopStreaming = function() {
  releaseMyClaim();
  _oldStopStreaming();
};

// initialize UI buttons state in case some roles are already claimed
updateRoleButtons();

// Auto-start the streaming flow once the auth token is loaded
// If token fetch fails we still attempt to open socket without token (server will reject)
Promise.resolve().then(() => {
  // Wait a tick so the token fetch above has a chance to populate AUTH_TOKEN
  setTimeout(() => {
    // On iOS 13+ Safari the DeviceMotionEvent.requestPermission API requires a user gesture.
    // If the API exists, show a small overlay asking the user to tap to enable motion.
    const permBtn = document.getElementById('permBtn');
    const permOverlay = document.getElementById('permOverlay');
    const needsGesture = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function');
    if (needsGesture && permBtn && permOverlay) {
      permOverlay.style.display = 'flex';
      permBtn.addEventListener('click', async () => {
        try {
          // Request motion permission (some browsers require orientation permission as well)
          await DeviceMotionEvent.requestPermission();
        } catch (e) {
          // ignore, we'll try DeviceOrientationEvent as well
        }
        try { await DeviceOrientationEvent.requestPermission(); } catch (e) { /* non-fatal */ }
        permOverlay.style.display = 'none';
        startStreaming();
      }, { once: true });
    } else {
      startStreaming();
    }
  }, 50);
});
</script>
</body>
</html>
