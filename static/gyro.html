<!-- ~/gyro_stream/static/gyro.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Gyro Stream</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; padding: 0.6rem; margin:0; display:flex; flex-direction:column; align-items:stretch; gap:8px; background:#111; color:#fff }
  .controls{ display:flex; flex-direction:column; gap:8px; align-items:stretch }
    button { padding: 0.6rem 0.8rem; flex:1; border-radius:8px; border:none; font-weight:600 }
  .roles{ display:flex; gap:6px; }
  /* color the role buttons to match players */
  .roles button { color: #012; font-weight:700; border-radius:8px; }
  button[data-role="blue"]{ background:#4ea1ff; color:#042434 }
  button[data-role="red"]{ background:#ff6b6b; color:#3b0000 }
  button[data-role="yellow"]{ background:#ffd86b; color:#332900 }
  button[data-role="green"]{ background:#8fe58f; color:#042a04 }
  .roles button.selected{ outline:3px solid rgba(255,255,255,0.12); transform:translateY(-2px); box-shadow:0 6px 14px rgba(0,0,0,0.35); }
    @media (max-width:420px){ h2{font-size:16px} button{padding:10px 6px; font-size:14px} }
  </style>
</head>
<body>
  <h2 style="margin:0;">Gyroscope Streamer</h2>
  <div class="controls">
    <div><span id="status">Idle</span></div>
    <div style="display:flex;gap:8px;justify-content:flex-end"><button id="startBtn">Start</button><button id="stopBtn" disabled>Stop</button></div>
  </div>
  <div style="height:100px;">&nbsp;</div>
  <div class="roles">
    <button id="roleBlue" data-role="blue">Blue</button>
    <button id="roleRed" data-role="red">Red</button>
    <button id="roleYellow" data-role="yellow">Yellow</button>
    <button id="roleGreen" data-role="green">Green</button>
  </div>

<script>
let AUTH_TOKEN = null;
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const statusEl = document.getElementById('status');

let socket = null;
let listening = false;
let sendCount = 0;
let role = 'blue'; // default to blue so game will react
let latestOrientation = {alpha: null, beta: null, gamma: null};

function log(s){ console.debug('[gyro]', s); }


function buildWsUrl() {
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  return `${proto}://${location.host}/ws?token=${encodeURIComponent(AUTH_TOKEN)}`;
}

// Fetch token from backend before starting
fetch('/api/token')
  .then(response => response.json())
  .then(data => {
    AUTH_TOKEN = data.token;
    log('Loaded token from backend');
  })
  .catch(err => {
    log('Failed to fetch token: ' + err);
  });

function openSocket() {
  const url = buildWsUrl();
  log('Connecting: ' + url);
  socket = new WebSocket(url);
  socket.onopen = () => {
    statusEl.textContent = 'WebSocket connected';
    log('WebSocket open');
  };
  socket.onclose = () => {
    statusEl.textContent = 'WebSocket closed';
    log('WebSocket closed');
  };
  socket.onerror = (e) => {
    log('Socket error');
    // suppressed console.warn to reduce noise
  };
}

function handleMotion(e) {
  if (!listening) return;
  const r = e.rotationRate || {};
  const acc = e.acceleration || e.accelerationIncludingGravity || {};
  // minimal payload: timestamp and beta only
  const payload = {
    t: Date.now(),
    // gyro rotation rates (deg/s)
    beta: r.beta || 0,
    gamma: r.gamma || 0,
    // orientation angles (deg) when available — more stable for tilt controls
    orientAlpha: latestOrientation.alpha,
    orientBeta: latestOrientation.beta,
    orientGamma: latestOrientation.gamma,
    // acceleration (m/s^2) — can be used for flick/momentum controls
    ax: acc.x || 0,
    ay: acc.y || 0,
    az: acc.z || 0,
    role
  };
  const s = JSON.stringify(payload);
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(s);
  }
  // throttle logs to once every 20 sends to avoid flooding the UI
  sendCount += 1;
  if (sendCount % 20 === 0) {
    log('sent: ' + s);
  }
}

// role button handlers
function applyRoleColor(r) {
  // highlight the selected role button and keep the rest neutral
  const roles = ['blue','red','yellow','green'];
  roles.forEach(roleName => {
    const btn = document.querySelector(`button[data-role="${roleName}"]`);
    if(!btn) return;
    if(roleName === r) btn.classList.add('selected'); else btn.classList.remove('selected');
  });
  // preserve previous body color behavior for quick visual feedback
  if (r === 'blue') { document.body.style.background = '#4ea1ff'; document.body.style.color = '#e6f4ff'; }
  else if (r === 'red') { document.body.style.background = '#ff6b6b'; document.body.style.color = '#ffe6e6'; }
  else if (r === 'yellow') { document.body.style.background = '#ffd86b'; document.body.style.color = '#332900'; }
  else if (r === 'green') { document.body.style.background = '#8fe58f'; document.body.style.color = '#042a04'; }
  else { document.body.style.background = ''; document.body.style.color = ''; }
}

document.getElementById('roleBlue').addEventListener('click', () => { role='blue'; applyRoleColor('blue'); log('Role=blue'); });
document.getElementById('roleRed').addEventListener('click', () => { role='red'; applyRoleColor('red'); log('Role=red'); });
document.getElementById('roleYellow').addEventListener('click', () => { role='yellow'; applyRoleColor('yellow'); log('Role=yellow'); });
document.getElementById('roleGreen').addEventListener('click', () => { role='green'; applyRoleColor('green'); log('Role=green'); });

// keep latest deviceorientation around so we can include it with motion payloads
window.addEventListener('deviceorientation', (ev) => {
  // ev.alpha/beta/gamma can be null on some devices
  latestOrientation.alpha = (ev.alpha !== null && ev.alpha !== undefined) ? ev.alpha : latestOrientation.alpha;
  latestOrientation.beta  = (ev.beta  !== null && ev.beta  !== undefined) ? ev.beta  : latestOrientation.beta;
  latestOrientation.gamma = (ev.gamma !== null && ev.gamma !== undefined) ? ev.gamma : latestOrientation.gamma;
}, {passive:true});

// streaming uses the minimal handleMotion payload (t, beta, role)
// ensure only the basic handler is registered when streaming starts

async function startStreaming() {
  try {
    // iOS requirement: request permission if available
    // request permission for motion and orientation on iOS
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const p = await DeviceMotionEvent.requestPermission();
      if (p !== 'granted') {
        alert('Motion permission denied');
        return;
      }
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try { await DeviceOrientationEvent.requestPermission(); } catch(e) { /* non-fatal */ }
    }
  } catch (err) {
    log('Permission request failed');
  }

  openSocket();
  listening = true;
  window.addEventListener('devicemotion', handleMotion);
  // deviceorientation listener was already added above to cache values; ensure it's active
  // nothing else needed here
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusEl.textContent = 'Streaming...';
}

function stopStreaming() {
  listening = false;
  window.removeEventListener('devicemotion', handleMotion);
  if (socket) socket.close();
  startBtn.disabled = false;
  stopBtn.disabled = true;
  statusEl.textContent = 'Stopped';
}

startBtn.addEventListener('click', startStreaming);
stopBtn.addEventListener('click', stopStreaming);
</script>
</body>
</html>
