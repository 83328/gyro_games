<!-- ~/gyro_stream/static/gyro.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Gyro Stream</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; padding: 0.6rem; margin:0; display:flex; flex-direction:column; align-items:stretch; gap:8px; background:#111; color:#fff }
  .controls{ display:flex; flex-direction:column; gap:8px; align-items:stretch }
    button { padding: 0.6rem 0.8rem; flex:1; border-radius:8px; border:none; font-weight:600 }
  .roles{ display:flex; flex-wrap:wrap; gap:8px; justify-content:center; --cols:4; }
  /* color the role buttons to match players */
  /* Use a CSS variable --cols to control equal-width buttons for N visible columns */
  .roles button { color: #012; font-weight:700; border-radius:8px; flex: 0 0 calc(100% / var(--cols) - 8px); min-width:88px; text-align:center }
  button[data-role="blue"]{ background:#4ea1ff; color:#042434 }
  button[data-role="red"]{ background:#ff6b6b; color:#3b0000 }
  button[data-role="yellow"]{ background:#ffd86b; color:#332900 }
  button[data-role="green"]{ background:#8fe58f; color:#042a04 }
  button[data-role="orange"]{ background:#ff9f4d; color:#2b1300 }
  button[data-role="purple"]{ background:#b58cff; color:#1f0533 }
  button[data-role="cyan"]{ background:#4de6e6; color:#022525 }
  button[data-role="magenta"]{ background:#ff6bff; color:#330033 }
  .roles button.selected{ outline:3px solid rgba(255,255,255,0.12); transform:translateY(-2px); box-shadow:0 6px 14px rgba(0,0,0,0.35); }
    @media (max-width:420px){ h2{font-size:16px} button{padding:10px 6px; font-size:14px} }
  /* larger, more tappable player count select */
  #transmitPlayerCount {
    font-size: 1rem;
    padding: 0.45rem 0.6rem;
    min-width: 88px;
    border-radius: 8px;
    background: #1b1b1b;
    color: #fff;
    border: 1px solid #333;
  }
  /* thin visual spacer between selector and the start/stop row */
  .spacer { height: 10px; width:100%; }
  </style>
</head>
<body>
  <h2 style="margin:0;">Pick your colour and press start</h2>
  <div class="controls">
    <div><span id="status">Idle</span></div>
    <div style="margin:8px 0; display:flex; align-items:center; gap:8px; justify-content:center;">
  <label for="roomIdInput" id="roomIdLabel" style="font-weight:600;">Room ID:</label>
  <input id="roomIdInput" type="text" maxlength="3" pattern="[A-Z]{3}" style="width:60px;text-transform:uppercase;font-size:1.1em;padding:4px 8px;border-radius:6px;border:1px solid #333;background:#222;text-align:center" value="" autocomplete="off" />
      <button id="setRoomBtn" style="padding:4px 10px;border-radius:6px;background:#1f6feb;color:#fff;font-weight:600">Set</button>
    </div>
    <div style="display:flex;flex-direction:column;align-items:center;gap:8px">
      <div class="spacer" aria-hidden="true"></div>
      <div style="display:flex;gap:8px;justify-content:center">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>
    </div>
  </div>
  <div style="height:100px;">&nbsp;</div>
  <div class="roles">
    <button id="roleBlue" data-role="blue">Blue</button>
    <button id="roleRed" data-role="red">Red</button>
    <button id="roleYellow" data-role="yellow">Yellow</button>
    <button id="roleGreen" data-role="green">Green</button>
    <button id="roleOrange" data-role="orange">Orange</button>
    <button id="rolePurple" data-role="purple">Purple</button>
    <button id="roleCyan" data-role="cyan">Cyan</button>
    <button id="roleMagenta" data-role="magenta">Magenta</button>
  </div>

<script>
let AUTH_TOKEN = null;
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const statusEl = document.getElementById('status');

let socket = null;
let listening = false;
let sendCount = 0;
let role = 'blue'; // default to blue so game will react
let latestOrientation = {alpha: null, beta: null, gamma: null};

function log(s){ console.debug('[gyro]', s); }

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room;
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
let ROOM_ID = getRoomId();

// Room ID input logic
const roomIdInput = document.getElementById('roomIdInput');
const setRoomBtn = document.getElementById('setRoomBtn');
if (roomIdInput) roomIdInput.value = ROOM_ID;
if (setRoomBtn) {
  setRoomBtn.addEventListener('click', () => {
    let val = (roomIdInput.value || '').toUpperCase().replace(/[^A-Z]/g, '');
    if (val.length === 3) {
      ROOM_ID = val;
      roomIdInput.value = ROOM_ID;
      statusEl.textContent = `Room set to ${ROOM_ID}`;
    } else {
      statusEl.textContent = 'Room ID must be 3 letters';
    }
  });
}

function buildWsUrl() {
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  return `${proto}://${location.host}/ws?token=${encodeURIComponent(AUTH_TOKEN)}&room=${ROOM_ID}`;
}

// Fetch token from backend before starting
fetch('/api/token')
  .then(response => response.json())
  .then(data => {
    AUTH_TOKEN = data.token;
    log('Loaded token from backend');
  })
  .catch(err => {
    log('Failed to fetch token: ' + err);
  });

function openSocket() {
  const url = buildWsUrl();
  log('Connecting: ' + url);
  socket = new WebSocket(url);
  socket.onopen = () => {
    statusEl.textContent = `Connected, Room ID: ${ROOM_ID}`;
    log('WebSocket open');
  };
  socket.onclose = () => {
    statusEl.textContent = `WebSocket closed, Room ID: ${ROOM_ID}`;
    log('WebSocket closed');
  };
  socket.onerror = (e) => {
    log('Socket error');
    // suppressed console.warn to reduce noise
  };
}

function handleMotion(e) {
  if (!listening) return;
  const now = Date.now();
  if (!window._lastGyroSent) window._lastGyroSent = 0;
  const MIN_SEND_MS = 100;
  if (now - window._lastGyroSent < MIN_SEND_MS) return;
  window._lastGyroSent = now;
  const r = e.rotationRate || {};
  const acc = e.acceleration || e.accelerationIncludingGravity || {};
  function fmt(v){
    if (v === null || v === undefined) return null;
    if (typeof v !== 'number') return v;
    return Number(v.toFixed(4));
  }
  // Add room id to payload
  const payload = {
    t: Date.now(),
    beta: fmt(r.beta || 0),
    gamma: fmt(r.gamma || 0),
    orientAlpha: fmt(latestOrientation.alpha),
    orientBeta: fmt(latestOrientation.beta),
    orientGamma: fmt(latestOrientation.gamma),
    ax: fmt(acc.x || 0),
    ay: fmt(acc.y || 0),
    az: fmt(acc.z || 0),
    role: (
      role === 'blue' ? 'b' :
      role === 'red' ? 'r' :
      role === 'yellow' ? 'y' :
      role === 'green' ? 'g' :
      role === 'orange' ? 'o' :
      role === 'purple' ? 'p' :
      role === 'cyan' ? 'c' :
      role === 'magenta' ? 'm' : role
    ),
    room: ROOM_ID
  };
  const s = JSON.stringify(payload);
  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(s);
  }
  sendCount += 1;
  if (sendCount % 20 === 0) {
    log('sent: ' + s);
  }
}

// role button handlers
function applyRoleColor(r) {
  // highlight the selected role button and keep the rest neutral
  const roles = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  roles.forEach(roleName => {
    const btn = document.querySelector(`button[data-role="${roleName}"]`);
    if(!btn) return;
    if(roleName === r) btn.classList.add('selected'); else btn.classList.remove('selected');
  });
  // set the body background and hardcode text color for contrast
  const colorMap = {
    blue:    {bg: '#4ea1ff', text: '#042434'},
    red:     {bg: '#ff6b6b', text: '#3b0000'},
    yellow:  {bg: '#ffd86b', text: '#332900'},
    green:   {bg: '#8fe58f', text: '#042a04'},
    orange:  {bg: '#ff9f4d', text: '#2b1300'},
    purple:  {bg: '#b58cff', text: '#1f0533'},
    cyan:    {bg: '#4de6e6', text: '#022525'},
    magenta: {bg: '#ff6bff', text: '#330033'}
  };
  const style = colorMap[r] || {bg: '#111', text: '#fff'};
  document.body.style.background = style.bg;
  document.body.style.color = style.text;
  // Also update Room ID label and input to match text color
  const roomIdLabel = document.getElementById('roomIdLabel');
  const roomIdInput = document.getElementById('roomIdInput');
  if (roomIdLabel) roomIdLabel.style.color = style.text;
  if (roomIdInput) roomIdInput.style.color = '#fff';
}

document.getElementById('roleBlue').addEventListener('click', () => { role='blue'; applyRoleColor('blue'); log('Role=blue'); });
document.getElementById('roleRed').addEventListener('click', () => { role='red'; applyRoleColor('red'); log('Role=red'); });
document.getElementById('roleYellow').addEventListener('click', () => { role='yellow'; applyRoleColor('yellow'); log('Role=yellow'); });
document.getElementById('roleGreen').addEventListener('click', () => { role='green'; applyRoleColor('green'); log('Role=green'); });
document.getElementById('roleOrange').addEventListener('click', () => { role='orange'; applyRoleColor('orange'); log('Role=orange'); });
document.getElementById('rolePurple').addEventListener('click', () => { role='purple'; applyRoleColor('purple'); log('Role=purple'); });
document.getElementById('roleCyan').addEventListener('click', () => { role='cyan'; applyRoleColor('cyan'); log('Role=cyan'); });
document.getElementById('roleMagenta').addEventListener('click', () => { role='magenta'; applyRoleColor('magenta'); log('Role=magenta'); });

// Always show all 8 color buttons, no player count selector needed
const rolesContainer = document.querySelector('.roles');
if(rolesContainer) rolesContainer.style.setProperty('--cols', '8');

// keep latest deviceorientation around so we can include it with motion payloads
window.addEventListener('deviceorientation', (ev) => {
  // ev.alpha/beta/gamma can be null on some devices
  latestOrientation.alpha = (ev.alpha !== null && ev.alpha !== undefined) ? ev.alpha : latestOrientation.alpha;
  latestOrientation.beta  = (ev.beta  !== null && ev.beta  !== undefined) ? ev.beta  : latestOrientation.beta;
  latestOrientation.gamma = (ev.gamma !== null && ev.gamma !== undefined) ? ev.gamma : latestOrientation.gamma;
}, {passive:true});

// streaming uses the minimal handleMotion payload (t, beta, role)
// ensure only the basic handler is registered when streaming starts

async function startStreaming() {
  try {
    // iOS requirement: request permission if available
    // request permission for motion and orientation on iOS
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const p = await DeviceMotionEvent.requestPermission();
      if (p !== 'granted') {
        alert('Motion permission denied');
        return;
      }
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      try { await DeviceOrientationEvent.requestPermission(); } catch(e) { /* non-fatal */ }
    }
  } catch (err) {
    log('Permission request failed');
  }

  openSocket();
  listening = true;
  window.addEventListener('devicemotion', handleMotion);
  // deviceorientation listener was already added above to cache values; ensure it's active
  // nothing else needed here
  startBtn.disabled = true;
  stopBtn.disabled = false;
  statusEl.textContent = 'Streaming...';
}

function stopStreaming() {
  listening = false;
  window.removeEventListener('devicemotion', handleMotion);
  if (socket) socket.close();
  startBtn.disabled = false;
  stopBtn.disabled = true;
  statusEl.textContent = 'Stopped';
}

startBtn.addEventListener('click', startStreaming);
stopBtn.addEventListener('click', stopStreaming);
</script>
</body>
</html>
