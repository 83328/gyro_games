<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Gyro Paddle</title>
    <style>
        body { font-family: Arial, sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; align-items:center; padding:16px; }
        canvas { background:#222; border:2px solid #333; }
        #status { margin:8px 0; color:#ffd700; }
        #logs { width:80%; max-height:120px; overflow:auto; font-family:monospace; font-size:12px; background:#0f0f0f; padding:8px; border-radius:4px; }
    </style>
</head>
<body>
    <h1>Gyro Paddle</h1>
    <div id="status">Connecting...</div>
    <div id="scoreboard" style="display:flex; gap:16px; align-items:center; margin-bottom:6px;">
        <div style="color:#4ea1ff">Blue: <span id="scoreBlue">0</span></div>
        <div style="color:#ff6b6b">Red: <span id="scoreRed">0</span></div>
    </div>
    <canvas id="canvas" width="800" height="400"></canvas>
    <div id="logs"></div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const logs = document.getElementById('logs');

    // Room id extraction from URL
    function getRoomId() {
        const params = new URLSearchParams(window.location.search);
        let room = params.get('room');
        if (!room || room.length !== 3) {
            room = 'DEF'; // fallback
        }
        return room.toUpperCase();
    }
    const ROOM_ID = getRoomId();

    // Paddles
    const paddleWidth = 120;
    const paddleHeight = 16;
    let blueX = canvas.width/2 - paddleWidth/2;
    let redX = canvas.width/2 - paddleWidth/2;

    // Ball
    const ballRadius = 10;
    let ballX = canvas.width/2;
    let ballY = canvas.height/2;
    let ballSpeedX = 3;
    let ballSpeedY = -3;

    // Smoothing (per-role)
    const smoothWindow = 12;
    let blueBetaHistory = [];
    let redBetaHistory = [];

    function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(redX, 4, paddleWidth, paddleHeight);
        ctx.fillStyle = '#4ea1ff';
        ctx.fillRect(blueX, canvas.height - paddleHeight - 4, paddleWidth, paddleHeight);
        if (ballX - ballRadius < 0 || ballX + ballRadius > canvas.width) ballSpeedX = -ballSpeedX;

        let redHit = false;
        if (ballY + ballRadius > canvas.height - paddleHeight - 4 && ballX > blueX && ballX < blueX + paddleWidth) {
            ballSpeedY = -Math.abs(ballSpeedY);
            const hit = (ballX - blueX)/paddleWidth - 0.5;
            ballSpeedX += hit*2;
        }
        if (ballY - ballRadius < paddleHeight + 4 && ballX > redX && ballX < redX + paddleWidth) {
            ballSpeedY = Math.abs(ballSpeedY);
            const hit = (ballX - redX)/paddleWidth - 0.5;
            ballSpeedX += hit*2;
            redHit = true;
        }

        if (ballY - ballRadius > canvas.height) {
            redScore += 1;
            updateScoreUI();
            resetBall();
            appendLog('Blue missed - point to Red');
        }
        if (ballY - ballRadius < 0 && !redHit) {
            blueScore += 1;
            updateScoreUI();
            resetBall();
            appendLog('Red missed - point to Blue');
        }
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
        ctx.fill();
    }

    function updateBall() {
        ballX += ballSpeedX;
        ballY += ballSpeedY;
    }

    function appendLog(msg) {
        if (!logs) return;
        const t = new Date().toLocaleTimeString();
        logs.textContent = `${t} ${msg}\n` + logs.textContent;
        const lines = logs.textContent.split('\n');
        if (lines.length > 80) logs.textContent = lines.slice(0,80).join('\n');
    }

    function gameLoop() {
        updateBall();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function resetBall() {
        ballX = canvas.width/2;
        ballY = canvas.height/2;
        ballSpeedX = 3*(Math.random()>0.5?1:-1);
        ballSpeedY = (Math.random() > 0.5) ? -3 : 3;
    }

    function updatePaddle(beta, role='blue') {
        if (beta === undefined || beta === null) return;
        const scale = 0.8;
        const alpha = 0.12;
        if (role === 'blue') {
            blueBetaHistory.push(beta);
            if (blueBetaHistory.length > smoothWindow) blueBetaHistory.shift();
            const avg = blueBetaHistory.reduce((a,b)=>a+b,0)/blueBetaHistory.length;
            const clamped = Math.max(-90, Math.min(90, avg*scale));
            const norm = (clamped + 90) / 180;
            const target = norm * (canvas.width - paddleWidth);
            blueX = blueX*(1-alpha) + target*alpha;
            blueX = Math.max(0, Math.min(blueX, canvas.width - paddleWidth));
        } else if (role === 'red') {
            redBetaHistory.push(beta);
            if (redBetaHistory.length > smoothWindow) redBetaHistory.shift();
            const avg = redBetaHistory.reduce((a,b)=>a+b,0)/redBetaHistory.length;
            const clamped = Math.max(-90, Math.min(90, avg*scale));
            const norm = (clamped + 90) / 180;
            const target = norm * (canvas.width - paddleWidth);
            redX = redX*(1-alpha) + target*alpha;
            redX = Math.max(0, Math.min(redX, canvas.width - paddleWidth));
        }
    }

    let ws = null;
    let wsUrl = null;
    let blueScore = 0;
    let redScore = 0;
    const scoreBlueEl = document.getElementById('scoreBlue');
    const scoreRedEl = document.getElementById('scoreRed');

    function updateScoreUI() {
        if (scoreBlueEl) scoreBlueEl.textContent = String(blueScore);
        if (scoreRedEl) scoreRedEl.textContent = String(redScore);
    }

    updateScoreUI();

    fetch('/api/token').then(r=>{ if(!r.ok) throw new Error('no token'); return r.json(); }).then(data=>{
        const token = data.token;
        if (data.ws_url) {
            wsUrl = data.ws_url.includes('?') ? data.ws_url + '&token=' + encodeURIComponent(token) : data.ws_url + '?token=' + encodeURIComponent(token);
        } else {
            const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
            wsUrl = `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
        }
        // Add room id to wsUrl
        wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
        status.textContent = 'Ready  connecting...';
        connect();
    }).catch(e=>{
        status.textContent = 'No ws info (is server running?)';
        appendLog('Cannot fetch /api/token');
    });

    function connect() {
        if (!wsUrl) return;
        try {
            ws = new WebSocket(wsUrl);
            ws.onopen = () => { status.textContent = 'Connected'; };
            ws.onmessage = (ev) => {
                try {
                    const d = JSON.parse(ev.data);
                    if (!d) return;
                    // Only process messages for this room
                    if (d.room && d.room.toUpperCase() !== ROOM_ID) return;
                    if(typeof d.role === 'string' && d.role.length === 1){
                        d.role = (
                            d.role === 'b' ? 'blue' :
                            d.role === 'r' ? 'red' : undefined
                        );
                    }
                    if (d.beta !== undefined) updatePaddle(d.beta, d.role);
                } catch(e) { /* ignore parse errors */ }
            };
            ws.onclose = () => { status.textContent = 'Disconnected'; setTimeout(connect,3000); };
            ws.onerror = () => { status.textContent = 'WS error'; };
        } catch(e) {
            status.textContent = 'WS failed';
        }
    }

    gameLoop();
    </script>
</body>
</html>