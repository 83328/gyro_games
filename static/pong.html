<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Gyro Paddle</title>
    <style>
        body { font-family: Arial, sans-serif; background:#111; color:#eee; display:flex; flex-direction:column; align-items:center; padding:16px; }
        canvas { background:#222; border:2px solid #333; }
    #status { margin:8px 0; color:#fff; }
    #logs { display:none; }
    </style>
</head>
<body>
    <h1>Gyro Paddle</h1>
    
    <div id="scoreboard" style="display:flex; gap:16px; align-items:center; margin-bottom:6px;">
        <div style="color:#4ea1ff">Blue: <span id="scoreBlue">0</span></div>
        <div style="color:#ff6b6b">Red: <span id="scoreRed">0</span></div>
    </div>
    <canvas id="canvas" width="600" height="500"></canvas>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const logs = document.getElementById('logs');

    // Room id extraction from URL
    function getRoomId() {
        const params = new URLSearchParams(window.location.search);
        let room = params.get('room');
        if (!room || room.length !== 3) {
            room = 'DEF'; // fallback
        }
        return room.toUpperCase();
    }
    const ROOM_ID = getRoomId();

        (function(){
            let rb = document.getElementById('roomBadge');
            if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
            rb.textContent = `Room: ${ROOM_ID}`;
            window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
        })();

    // Paddles
    const paddleWidth = 16;
    const paddleHeight = 120;
    let blueY = canvas.height/2 - paddleHeight/2;
    let redY = canvas.height/2 - paddleHeight/2;

    // Ball
    const ballRadius = 10;
    let ballX = canvas.width/2;
    let ballY = canvas.height/2;
    let ballSpeedX = 3;
    let ballSpeedY = -3;

    // Smoothing (per-role)
    const smoothWindow = 12;
    let blueBetaHistory = [];
    let redBetaHistory = [];

    function draw() {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        // Draw paddles left/right
        ctx.fillStyle = '#ff6b6b';
        ctx.fillRect(4, redY, paddleWidth, paddleHeight);
        ctx.fillStyle = '#4ea1ff';
        ctx.fillRect(canvas.width - paddleWidth - 4, blueY, paddleWidth, paddleHeight);
        // Ball bounce on top/bottom
        if (ballY - ballRadius < 0 || ballY + ballRadius > canvas.height) ballSpeedY = -ballSpeedY;

        let blueHit = false;
        if (ballX - ballRadius < paddleWidth + 4 && ballY > redY && ballY < redY + paddleHeight) {
            ballSpeedX = Math.abs(ballSpeedX);
            const hit = (ballY - redY)/paddleHeight - 0.5;
            ballSpeedY += hit*2;
        }
        if (ballX + ballRadius > canvas.width - paddleWidth - 4 && ballY > blueY && ballY < blueY + paddleHeight) {
            ballSpeedX = -Math.abs(ballSpeedX);
            const hit = (ballY - blueY)/paddleHeight - 0.5;
            ballSpeedY += hit*2;
            blueHit = true;
        }

        if (ballX - ballRadius > canvas.width) {
            redScore += 1;
            updateScoreUI();
            resetBall();
        }
        if (ballX + ballRadius < 0 && !blueHit) {
            blueScore += 1;
            updateScoreUI();
            resetBall();
        }
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
        ctx.fill();
    }

    function updateBall() {
    ballX += ballSpeedX;
    ballY += ballSpeedY;
    }

    function appendLog(msg) {
        try{
            // Prefer writing to visible #status if present (for debugging), otherwise write to hidden logs or console
            const statusEl = document.getElementById('status');
            if(statusEl) { statusEl.textContent = msg; return; }
        }catch(e){}
        if (logs){
            const t = new Date().toLocaleTimeString();
            logs.textContent = `${t} ${msg}\n` + logs.textContent;
            const lines = logs.textContent.split('\n');
            if (lines.length > 80) logs.textContent = lines.slice(0,80).join('\n');
            return;
        }
        console.log(msg);
    }

    function gameLoop() {
        updateBall();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function resetBall() {
    ballX = canvas.width/2;
    ballY = canvas.height/2;
    ballSpeedX = 3*(Math.random()>0.5?1:-1);
    ballSpeedY = 3*(Math.random()>0.5?1:-1);
    }

    function updatePaddle(beta, role='blue') {
        if (beta === undefined || beta === null) return;
        // Use y (vertical position) for paddle movement instead of gamma
        const scale = 0.8;
        const alpha = 0.25;
        if (role === 'blue') {
            blueBetaHistory.push(beta);
            if (blueBetaHistory.length > smoothWindow) blueBetaHistory.shift();
            const avg = blueBetaHistory.reduce((a,b)=>a+b,0)/blueBetaHistory.length;
            // Interpret beta as y (vertical position)
            const clamped = Math.max(-90, Math.min(90, avg*scale));
            const norm = (clamped + 90) / 180;
            const target = norm * (canvas.height - paddleHeight);
            blueY = blueY*(1-alpha) + target*alpha;
            blueY = Math.max(0, Math.min(blueY, canvas.height - paddleHeight));
        } else if (role === 'red') {
            redBetaHistory.push(beta);
            if (redBetaHistory.length > smoothWindow) redBetaHistory.shift();
            const avg = redBetaHistory.reduce((a,b)=>a+b,0)/redBetaHistory.length;
            // Interpret beta as y (vertical position)
            const clamped = Math.max(-90, Math.min(90, avg*scale));
            const norm = (clamped + 90) / 180;
            const target = norm * (canvas.height - paddleHeight);
            redY = redY*(1-alpha) + target*alpha;
            redY = Math.max(0, Math.min(redY, canvas.height - paddleHeight));
        }
    }

    let ws = null;
    let wsUrl = null;
    let blueScore = 0;
    let redScore = 0;
    const scoreBlueEl = document.getElementById('scoreBlue');
    const scoreRedEl = document.getElementById('scoreRed');

    function updateScoreUI() {
        if (scoreBlueEl) scoreBlueEl.textContent = String(blueScore);
        if (scoreRedEl) scoreRedEl.textContent = String(redScore);
    }

    updateScoreUI();

    fetch('/api/token').then(r=>{ if(!r.ok) throw new Error('no token'); return r.json(); }).then(data=>{
        const token = data.token;
        if (data.ws_url) {
            wsUrl = data.ws_url.includes('?') ? data.ws_url + '&token=' + encodeURIComponent(token) : data.ws_url + '?token=' + encodeURIComponent(token);
        } else {
            const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
            wsUrl = `${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
        }
        // Add room id to wsUrl
        wsUrl += `&room=${encodeURIComponent(ROOM_ID)}`;
    appendLog('Ready connecting...');
        connect();
    }).catch(e=>{
    appendLog('No ws info (is server running?)');
        appendLog('Cannot fetch /api/token');
    });

    function connect() {
        if (!wsUrl) return;
        try {
            ws = new WebSocket(wsUrl);
            ws.onopen = () => { appendLog(`Connected, Room ID: ${ROOM_ID}`); if(window.__setRoomBadge) window.__setRoomBadge(`Connected â€” Room: ${ROOM_ID}`); };
            ws.onmessage = (ev) => {
                try {
                    const d = JSON.parse(ev.data);
                    if (!d) return;
                    // Only process messages for this room
                    if (d.room && d.room.toUpperCase() !== ROOM_ID) return;
                    if(typeof d.role === 'string' && d.role.length === 1){
                        d.role = (
                            d.role === 'b' ? 'blue' :
                            d.role === 'r' ? 'red' : undefined
                        );
                    }
                    if (d.beta !== undefined) updatePaddle(d.beta, d.role);
                } catch(e) { /* ignore parse errors */ }
            };
            ws.onclose = () => { appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(connect,3000); };
            ws.onerror = () => { appendLog('WS error'); if(window.__setRoomBadge) window.__setRoomBadge('WebSocket error'); };
        } catch(e) {
            appendLog('WS failed');
        }
    }

    gameLoop();
    </script>
</body>
</html>