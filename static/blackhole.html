<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blackhole Blasters</title>
<style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background: radial-gradient(circle at center, #000010 0%, #000 100%);
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
  }
  canvas {
    background: radial-gradient(circle at center, #000, #050512 70%, #000 100%);
    border: 2px solid #222;
    border-radius: 10px;
    box-shadow: 0 0 12px rgba(0,0,0,0.5);
  }
  #info { margin: 8px; font-size: 1.1em; }
  #scores { margin: 8px; }
</style>
</head>
<body>
  <h1>Blackhole Blasters</h1>
  <div id="info">Connecting...</div>
  <div id="scores">
    Players:
    <select id="playerCount" style="margin:0 8px">
      <option value="2">2 players</option>
      <option value="3">3 players</option>
      <option value="4">4 players</option>
    </select>
    <button id="newRound" style="margin-left:12px;display:none">New round</button>
    Blue: <span id="sBlue">0</span> — Red: <span id="sRed">0</span>
    <span id="yellowScoreContainer" style="display:none"> — Yellow: <span id="sYellow">0</span></span>
    <span id="greenScoreContainer" style="display:none"> — Green: <span id="sGreen">0</span></span>
  </div>
  <canvas id="c" width="700" height="600"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
const playerCountSel = document.getElementById('playerCount');
const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');

const colors = {blue:'#4ea1ff', red:'#ff6b6b', yellow:'#ffd86b', green:'#8fe58f'};
let ws=null;
let activeRoles = ['blue','red'];
let scores = {blue:0,red:0,yellow:0,green:0};
let players = {};
let bullets = [];
let timeLeft = 60;
let roundRunning = true;
// powerup state
let powerup = null; // {x,y,kind,ttl}
const POWERUP_SPAWN_INTERVAL = 8.0; // seconds between spawn attempts
let _powerupTimer = 4.0; // seed first spawn shortly

let blackhole = {x:canvas.width/2, y:canvas.height/2, radius:40, gravity:800};
let GALAXY_RADIUS = 280; // boundary (will be recalculated on resize)
// visual scaling: ship size and layout should adapt to canvas size
let SHIP_SCALE = 2.0;

function resizeCanvasToDisplay(){
  const headerH = (document.querySelector('h1')?.offsetHeight || 40) + (document.getElementById('info')?.offsetHeight || 30) + (document.getElementById('scores')?.offsetHeight || 30) + 36;
  const vv = window.visualViewport;
  const availW = Math.max(320, (vv?.width || window.innerWidth) - 24);
  const availH = Math.max(300, (vv?.height || window.innerHeight) - headerH - 24);
  // keep a square canvas that fits available area
  const size = Math.max(300, Math.min(availW, availH));
  canvas.width = Math.min(1100, size);
  canvas.height = canvas.width; // square playfield
  // center blackhole and compute galaxy radius relative to size
  blackhole.x = canvas.width/2; blackhole.y = canvas.height/2;
  GALAXY_RADIUS = Math.floor(Math.min(canvas.width, canvas.height) * 0.42);
  blackhole.radius = Math.max(16, Math.floor(Math.min(canvas.width, canvas.height) * 0.06));
  // scale gravity slightly with size so feel is preserved
  blackhole.gravity = 800 * (GALAXY_RADIUS / 280);
  // ship scale relative to the original 700 baseline; double the visual size
  SHIP_SCALE = (canvas.width / 700) * 2.0;
  // reposition players around the blackhole if they already exist
  const spawnR = Math.floor(GALAXY_RADIUS * 0.72);
  for(const role of Object.keys(players)){
    const p = players[role];
    // keep angle but reposition at same relative radius
    p.x = blackhole.x + Math.cos(p.angle - Math.PI/2) * spawnR;
    p.y = blackhole.y + Math.sin(p.angle - Math.PI/2) * spawnR;
  }
}

// listen to viewport/resize
if(window.visualViewport){ window.visualViewport.addEventListener('resize', resizeCanvasToDisplay); window.visualViewport.addEventListener('scroll', resizeCanvasToDisplay); }
window.addEventListener('resize', resizeCanvasToDisplay);

// init players
function initPlayers(){
  const n = parseInt(playerCountSel.value,10);
  activeRoles = ['blue','red'];
  if(n>=3){activeRoles.push('yellow'); yellowScoreContainer.style.display='';}
  else yellowScoreContainer.style.display='none';
  if(n>=4){activeRoles.push('green'); greenScoreContainer.style.display='';}
  else greenScoreContainer.style.display='none';

  players={};
  bullets=[];
  const angleStep = (Math.PI*2)/n;
  const spawnR = Math.floor(GALAXY_RADIUS * 0.72);
  for(let i=0;i<n;i++){
    const role = activeRoles[i];
    const angle = i*angleStep;
    players[role] = {
      x: blackhole.x + Math.cos(angle)*spawnR,
      y: blackhole.y + Math.sin(angle)*spawnR,
      vx: 0, vy: 0,
      angle: angle + Math.PI/2,
      rotSpeed: 0,
      thrust: 0,
      cooldown: 0,
      fireMultiplier: 1,
      powerupUntil: 0
    };
  }
  timeLeft = 60;
  roundRunning = true;
}
initPlayers();
playerCountSel.addEventListener('change',()=>initPlayers());
const newRoundBtn = document.getElementById('newRound');
let gameMessage = '';

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // galaxy boundary
  ctx.strokeStyle='rgba(255,255,255,0.1)';
  ctx.beginPath();
  ctx.arc(blackhole.x,blackhole.y,GALAXY_RADIUS,0,Math.PI*2);
  ctx.stroke();

  // blackhole core
  const grad = ctx.createRadialGradient(blackhole.x,blackhole.y,0,blackhole.x,blackhole.y,blackhole.radius*3);
  grad.addColorStop(0,'#000');
  grad.addColorStop(0.4,'#222');
  grad.addColorStop(1,'#000');
  ctx.fillStyle=grad;
  ctx.beginPath();
  ctx.arc(blackhole.x,blackhole.y,blackhole.radius,0,Math.PI*2);
  ctx.fill();

  // bullets
  for(const b of bullets){
    ctx.fillStyle=b.color;
    ctx.beginPath();
    const br = Math.max(2, Math.floor(3 * SHIP_SCALE));
    ctx.arc(b.x,b.y,br,0,Math.PI*2);
    ctx.fill();
  }

  // powerup
  if(powerup){
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#ffe066';
    ctx.arc(powerup.x, powerup.y, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='#fff'; ctx.stroke();
    ctx.fillStyle='#001'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('x2', powerup.x, powerup.y);
    ctx.restore();
  }

  // ships
  for(const role of activeRoles){
    const p = players[role];
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(p.angle);
    ctx.fillStyle=colors[role];
    // ship shape scaled by SHIP_SCALE
    const s = Math.max(1, Math.floor(8 * SHIP_SCALE));
    ctx.beginPath();
    ctx.moveTo(0,-(s+2));
    ctx.lineTo(s, s+2);
    ctx.lineTo(-s, s+2);
    ctx.closePath();
    ctx.fill();
    if(p.thrust>0){
      ctx.fillStyle='orange';
      ctx.beginPath();
      ctx.moveTo(-Math.max(3,Math.floor(4*SHIP_SCALE)), s+2);
      ctx.lineTo(0,s+2+Math.random()*6*SHIP_SCALE);
      ctx.lineTo(Math.max(3,Math.floor(4*SHIP_SCALE)), s+2);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  ctx.fillStyle='#fff';
  ctx.font='14px monospace';
  ctx.fillText(`Time left: ${Math.ceil(timeLeft)}s`,10,20);
  // overlay final message if needed
  drawGameMessage();
}

// step
function step(dt){
  if(!roundRunning) return;
  timeLeft -= dt;
  if(timeLeft<=0){
    roundRunning=false;
    // compute winner(s)
    let maxScore = -1; const winners=[];
    for(const r of Object.keys(scores)){
      if(!activeRoles.includes(r)) continue;
      const sc = scores[r] || 0;
      if(sc > maxScore){ maxScore = sc; winners.length=0; winners.push(r); }
      else if(sc === maxScore) winners.push(r);
    }
    if(maxScore <= 0){ gameMessage = "Time's up! No score."; }
    else if(winners.length===1){ gameMessage = `Time's up! Winner: ${winners[0].toUpperCase()} (${maxScore})`; }
    else { gameMessage = `Time's up! Tie: ${winners.map(w=>w.toUpperCase()).join(', ')} (${maxScore})`; }
    info.textContent = gameMessage;
    // show New round button to allow manual restart
    if(newRoundBtn) newRoundBtn.style.display='';
  }

  // update players
  for(const role of activeRoles){
    const p=players[role];

    // rotate
    p.angle += p.rotSpeed * dt;

    // thrust
    const thrustX = Math.sin(p.angle) * p.thrust * 200;
    const thrustY = -Math.cos(p.angle) * p.thrust * 200;
    p.vx += thrustX * dt;
    p.vy += thrustY * dt;

    // gravity
    const dx = blackhole.x - p.x;
    const dy = blackhole.y - p.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const pull = blackhole.gravity / (dist*dist);
    p.vx += dx/dist * pull * dt;
    p.vy += dy/dist * pull * dt;

    // move
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // limit to galaxy boundary
    const cx = p.x - blackhole.x;
    const cy = p.y - blackhole.y;
    const distFromCenter = Math.sqrt(cx*cx+cy*cy);
    if(distFromCenter > GALAXY_RADIUS){
      const nx = cx/distFromCenter;
      const ny = cy/distFromCenter;
      p.x = blackhole.x + nx * GALAXY_RADIUS;
      p.y = blackhole.y + ny * GALAXY_RADIUS;
      // bounce back slightly
      const dot = p.vx*nx + p.vy*ny;
      p.vx -= 1.2*dot*nx;
      p.vy -= 1.2*dot*ny;
    }

    // friction
    p.vx *= 0.995; p.vy *= 0.995;

    // shooting
      p.cooldown -= dt;
      const baseFireInterval = 1.0; // seconds between shots at normal rate
      const interval = baseFireInterval / (p.fireMultiplier || 1);
      if(p.cooldown<=0){
        bullets.push({
          x: p.x + Math.sin(p.angle)*12,
          y: p.y - Math.cos(p.angle)*12,
          vx: Math.sin(p.angle)*300 + p.vx,
          vy: -Math.cos(p.angle)*300 + p.vy,
          color: colors[role],
          owner: role,
          life: 2
        });
        p.cooldown = interval;
      }
  }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x += b.vx*dt;
    b.y += b.vy*dt;
    b.life -= dt;
    if(b.life<=0){bullets.splice(i,1);continue;}

    // collisions
    for(const role of activeRoles){
      if(role===b.owner) continue;
      const p=players[role];
      const dx=b.x-p.x, dy=b.y-p.y;
        // scale hit radius with ship size
        const hitR = Math.max(12, 12 * SHIP_SCALE); // px
        if(dx*dx+dy*dy < (hitR * hitR)){
        scores[b.owner]++;
        if(b.owner==='blue') sBlue.textContent=scores[b.owner];
        if(b.owner==='red') sRed.textContent=scores[b.owner];
        if(b.owner==='yellow') sYellow.textContent=scores[b.owner];
        if(b.owner==='green') sGreen.textContent=scores[b.owner];
        bullets.splice(i,1);
        break;
      }
    }
  }

  // powerup timer: spawn occasionally
  if(powerup==null){
    _powerupTimer -= dt;
    if(_powerupTimer <= 0){
      // spawn at random location within galaxy bounds but not too close to blackhole
      const angle = Math.random()*Math.PI*2;
      const r = 60 + Math.random()*(GALAXY_RADIUS-80);
      const px = blackhole.x + Math.cos(angle)*r;
      const py = blackhole.y + Math.sin(angle)*r;
      powerup = { x: px, y: py, kind: 'rapid', ttl: 12.0 };
      // reset spawn timer
      _powerupTimer = POWERUP_SPAWN_INTERVAL + Math.random()*6;
    }
  } else {
    // powerup active TTL
    powerup.ttl -= dt;
    if(powerup.ttl <= 0) powerup = null;
    else {
      // check pickup by players
      for(const role of activeRoles){
        const p = players[role];
        const dx = p.x - powerup.x, dy = p.y - powerup.y;
  const pickupR = Math.max(20, 30 * SHIP_SCALE);
  if(dx*dx+dy*dy < (pickupR * pickupR)){
          // apply rapid fire for 5s
          p.fireMultiplier = 2;
          p.powerupUntil = performance.now()/1000 + 5.0;
          powerup = null;
          info.textContent = `${role} picked up Rapid Fire!`;
          break;
        }
      }
    }
  }

  // expire player powerups
  const nowSec = performance.now()/1000;
  for(const role of activeRoles){
    const p = players[role];
    if(p.powerupUntil && p.powerupUntil <= nowSec){ p.fireMultiplier = 1; p.powerupUntil = 0; }
  }
}

// draw game messages when present
function drawGameMessage(){
  if(!gameMessage) return;
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(canvas.width/2 - 220, canvas.height/2 - 40, 440, 80);
  ctx.fillStyle='#fff'; ctx.font='20px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
  ctx.restore();
}

// input
function handleTilt(role,beta,gamma){
  const p=players[role]; if(!p||!roundRunning)return;

  // Forward/back (beta) = thrust
  const thrustVal = Math.max(0, Math.min(1, (-beta)/35));
  p.thrust = thrustVal;

  // Left/right (gamma) = rotation speed
  // make rotation less sensitive: divide gamma by a larger factor
  const rotVal = Math.max(-1, Math.min(1, gamma/70));
  p.rotSpeed = rotVal * 2.2; // radians per sec (slower)
}

// websocket
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token=data.token;
  const proto=(location.protocol==='https:')?'wss':'ws';
  const wsUrl=data.ws_url?(data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token):data.ws_url+'?token='+encodeURIComponent(token)):`${proto}://${location.host}/ws?token=${encodeURIComponent(token)}`;
  ws=new WebSocket(wsUrl);
  ws.onopen=()=>{info.textContent='Connected';};
  ws.onmessage=(ev)=>{
    try{
      const d=JSON.parse(ev.data);
      if(!d||!d.role) return;
      if(typeof d.role === 'string' && d.role.length===1){
        d.role = (d.role === 'b' ? 'blue' : (d.role === 'r' ? 'red' : (d.role === 'y' ? 'yellow' : (d.role === 'g' ? 'green' : d.role))));
      }
      if(!activeRoles.includes(d.role)) return;
      if(d.orientBeta!==undefined && d.orientGamma!==undefined){
        handleTilt(d.role,d.orientBeta,d.orientGamma);
      }else if(d.beta!==undefined && d.gamma!==undefined){
        handleTilt(d.role,d.beta,d.gamma);
      }
    }catch(e){}
  };
  ws.onclose=()=>{info.textContent='Disconnected';setTimeout(()=>location.reload(),2000);};
}).catch(e=>{info.textContent='No backend /api/token';});

let last=performance.now();
function frame(now){
  const dt=Math.min(40,now-last)/1000; last=now;
  step(dt);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

if(newRoundBtn){
  newRoundBtn.addEventListener('click', ()=>{
    gameMessage = '';
    bullets = [];
    powerup = null;
    // reset scores to zero for active roles
    for(const r of Object.keys(scores)) scores[r]=0;
    sBlue.textContent = 0; sRed.textContent = 0; sYellow.textContent=0; sGreen.textContent=0;
    if(newRoundBtn) newRoundBtn.style.display='none';
    info.textContent = 'New round';
    initPlayers();
  });
}
</script>
</body>
</html>
