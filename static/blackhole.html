<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blasters</title>
<style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background: radial-gradient(circle at center, #000010 0%, #000 100%);
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px;
  }
  canvas {
    background: radial-gradient(circle at center, #000, #050512 70%, #000 100%);
    border: 2px solid #222;
    border-radius: 10px;
    box-shadow: 0 0 12px rgba(0,0,0,0.5);
  }
  #info { margin: 8px; font-size: 1.1em; }
  #scores { margin: 8px; }
</style>
</head>
<body>
  <h1>Blasters</h1>
  
  <div id="scores">
    <button id="newRound" style="margin-left:12px;display:none">New round</button>
  <span id="blueScoreContainer">Blue: <span id="sBlue">0</span></span> — <span id="redScoreContainer">Red: <span id="sRed">0</span></span>
  <span id="yellowScoreContainer" style="display:none"> — <span id="lblYellow">Yellow</span>: <span id="sYellow">0</span></span>
  <span id="greenScoreContainer" style="display:none"> — <span id="lblGreen">Green</span>: <span id="sGreen">0</span></span>
  <span id="orangeScoreContainer" style="display:none"> — <span id="lblOrange">Orange</span>: <span id="sOrange">0</span></span>
  <span id="purpleScoreContainer" style="display:none"> — <span id="lblPurple">Purple</span>: <span id="sPurple">0</span></span>
  <span id="cyanScoreContainer" style="display:none"> — <span id="lblCyan">Cyan</span>: <span id="sCyan">0</span></span>
  <span id="magentaScoreContainer" style="display:none"> — <span id="lblMagenta">Magenta</span>: <span id="sMagenta">0</span></span>
  </div>
  <canvas id="c" width="700" height="600"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// runtime-safe logger: attempts to write to #info if present, otherwise falls back to console
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();
function applyPlayerCountFromMeta(newCount){
  const clamped = Math.max(2, Math.min(8, parseInt(newCount || playerCount, 10)));
  if(Number.isNaN(clamped) || clamped === playerCount) return;
  playerCount = clamped;
  const params = new URLSearchParams(window.location.search);
  params.set('players', String(playerCount));
  const qs = params.toString();
  window.history.replaceState({}, '', `${window.location.pathname}?${qs}`);
  resetGame('Player count updated');
}
const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

const colors = {blue:'#4ea1ff', red:'#ff6b6b', yellow:'#ffd86b', green:'#8fe58f', orange:'#ff9f4d', purple:'#b58cff', cyan:'#4de6e6', magenta:'#ff6bff'};
let ws=null;
let activeRoles = ['blue','red'];
let scores = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};

// map for convenient score span updates
const scoreSpans = { blue: sBlue, red: sRed, yellow: sYellow, green: sGreen, orange: sOrange, purple: sPurple, cyan: sCyan, magenta: sMagenta };
let players = {};
let bullets = [];
let timeLeft = 60;
let roundRunning = true;
let intermissionTimer = null; // auto-restart timer handle
let intermissionLeft = 0; // seconds until next round
// powerup state
let powerup = null; // {x,y,kind:'rapid'|'shield'|'speed'}
const POWERUP_SPAWN_INTERVAL = 8.0; // seconds between spawn attempts
let _powerupTimer = 4.0; // seed first spawn shortly

// Square playfield without blackhole; ships move within rectangular bounds
let CENTER_X = canvas.width/2, CENTER_Y = canvas.height/2;
let SPAWN_RADIUS = Math.floor(Math.min(canvas.width, canvas.height) * 0.42);
// visual scaling: ship size and layout should adapt to canvas size
let SHIP_SCALE = 2.0;
// movement & gameplay constants
const MAX_SPEED_BASE = 320; // px/s at SHIP_SCALE=1 on width~700
const INVULN_DURATION = 2.0; // seconds of spawn protection
const HIT_FLASH_DURATION = 0.15; // seconds
const BULLET_MAX_BOUNCES = 2;

function resizeCanvasToDisplay(){
  const headerH = (document.querySelector('h1')?.offsetHeight || 40) + (document.getElementById('info')?.offsetHeight || 30) + (document.getElementById('scores')?.offsetHeight || 30) + 36;
  const vv = window.visualViewport;
  const availW = Math.max(320, (vv?.width || window.innerWidth) - 24);
  const availH = Math.max(300, (vv?.height || window.innerHeight) - headerH - 24);
  // rectangular canvas similar to blob: fill available space within caps
  const W = Math.max(400, Math.min(1400, Math.floor(availW)));
  const H = Math.max(300, Math.min(1000, Math.floor(availH)));
  canvas.width = W;
  canvas.height = H;
  // update center and spawn radius relative to min dimension
  CENTER_X = canvas.width/2; CENTER_Y = canvas.height/2;
  SPAWN_RADIUS = Math.floor(Math.min(canvas.width, canvas.height) * 0.36);
  // ship scale relative to the original 700 baseline; double the visual size
  SHIP_SCALE = (canvas.width / 700) * 2.0;
  // reposition players around center if they already exist, preserve angle
  for(const role of Object.keys(players)){
    const p = players[role];
    p.x = CENTER_X + Math.cos(p.angle - Math.PI/2) * SPAWN_RADIUS;
    p.y = CENTER_Y + Math.sin(p.angle - Math.PI/2) * SPAWN_RADIUS;
  }
}

// listen to viewport/resize
if(window.visualViewport){ window.visualViewport.addEventListener('resize', resizeCanvasToDisplay); window.visualViewport.addEventListener('scroll', resizeCanvasToDisplay); }
window.addEventListener('resize', resizeCanvasToDisplay);
// apply initial sizing immediately
resizeCanvasToDisplay();

// Winner splash overlay (similar to paint)
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 10001;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '52px';
winOverlay.style.fontWeight = '800';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);

function showWinnerSplash(role, opts={}){
  const bg = opts.background || colors[role] || '#000';
  winOverlay.style.background = bg;
  // pick readable text color based on luminance unless overridden
  let hex = (bg.replace('#',''));
  let r=0,g=0,b=0;
  try{ r = parseInt(hex.substring(0,2),16); g = parseInt(hex.substring(2,4),16); b = parseInt(hex.substring(4,6),16); }catch(e){}
  const lum = 0.2126*r + 0.7152*g + 0.0722*b;
  winOverlay.style.color = opts.textColor || ((lum > 170) ? '#001' : '#fff');
  const base = role ? role.charAt(0).toUpperCase() + role.slice(1) : 'Winner';
  const label = opts.label || `${base} wins!`;
  winOverlay.textContent = label;
  winOverlay.style.display = 'flex';
  if(winOverlay._hideTimeout){ clearTimeout(winOverlay._hideTimeout); }
  const duration = opts.duration || 3000;
  winOverlay._hideTimeout = setTimeout(()=>{ winOverlay.style.display = 'none'; }, duration);
}
// expose helper for future winner triggers
window.__showWinnerSplash = showWinnerSplash;

// init players
function initPlayers(){
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, n);

  players={};
  bullets=[];
  const angleStep = (Math.PI*2)/n;
  const spawnR = SPAWN_RADIUS;
  for(let i=0;i<n;i++){
    const role = activeRoles[i];
    const angle = i*angleStep;
    players[role] = {
      x: CENTER_X + Math.cos(angle)*spawnR,
      y: CENTER_Y + Math.sin(angle)*spawnR,
      vx: 0, vy: 0,
      angle: angle + Math.PI/2,
      rotSpeed: 0,
      thrust: 0,
      cooldown: 0,
      fireMultiplier: 1,
      powerupUntil: 0,
      shieldUntil: 0,
      speedUntil: 0,
      invulUntil: performance.now()/1000 + INVULN_DURATION,
      hitFlashUntil: 0,
      lastFireInterval: 1.0
    };
  }
  timeLeft = 60;
  roundRunning = true;
  // Color HUD labels and numeric spans for quick scanning
  const containers = {
    blue: document.getElementById('blueScoreContainer'),
    red: document.getElementById('redScoreContainer'),
    yellow: document.getElementById('yellowScoreContainer'),
    green: document.getElementById('greenScoreContainer'),
    orange: document.getElementById('orangeScoreContainer'),
    purple: document.getElementById('purpleScoreContainer'),
    cyan: document.getElementById('cyanScoreContainer'),
    magenta: document.getElementById('magentaScoreContainer')
  };
  const spans = { blue: sBlue, red: sRed, yellow: sYellow, green: sGreen };
  for(const role of Object.keys(containers)){
    const c = containers[role];
    if(c && activeRoles.includes(role)){
      c.style.display = '';
      c.style.color = colors[role];
      if(spans[role]) spans[role].style.color = colors[role];
    } else if(c){
      c.style.display = 'none';
    }
  }
}
initPlayers();
const newRoundBtn = document.getElementById('newRound');
let gameMessage = '';

function resetGame(reason){
  gameMessage = '';
  bullets = [];
  powerup = null;
  for(const r of Object.keys(scores)) scores[r]=0;
  for(const k of Object.keys(scoreSpans)){
    const sp = scoreSpans[k]; if(sp) sp.textContent = 0;
  }
  if(newRoundBtn) newRoundBtn.style.display='none';
  if(winOverlay){
    winOverlay.style.display='none';
    if(winOverlay._hideTimeout) clearTimeout(winOverlay._hideTimeout);
  }
  if(reason) appendLog(reason);
  if(intermissionTimer){ clearInterval(intermissionTimer); intermissionTimer = null; }
  initPlayers();
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // optional subtle border to emphasize square arena
  ctx.strokeStyle='rgba(255,255,255,0.15)';
  ctx.lineWidth = 2;
  ctx.strokeRect(1,1,canvas.width-2,canvas.height-2);

  // bullets
  for(const b of bullets){
    ctx.fillStyle=b.color;
    ctx.beginPath();
    const br = Math.max(2, Math.floor(3 * SHIP_SCALE));
    ctx.arc(b.x,b.y,br,0,Math.PI*2);
    ctx.fill();
  }

  // powerup
  if(powerup){
    ctx.save();
    ctx.beginPath();
    // color/icon by kind
    const pcol = powerup.kind==='shield' ? '#7fd3ff' : powerup.kind==='speed' ? '#8fff9c' : '#ffe066';
    ctx.fillStyle = pcol;
    ctx.arc(powerup.x, powerup.y, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='#fff'; ctx.stroke();
    ctx.fillStyle='#001'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const label = powerup.kind==='shield' ? 'SH' : powerup.kind==='speed' ? 'SPD' : 'x2';
    ctx.fillText(label, powerup.x, powerup.y);
    ctx.restore();
  }

  // ships
  for(const role of activeRoles){
    const p = players[role];
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(p.angle);
    ctx.fillStyle=colors[role];
    // ship shape scaled by SHIP_SCALE (1/3 smaller)
    const s = Math.max(1, Math.floor(8 * SHIP_SCALE * (2/3)));
    ctx.beginPath();
    ctx.moveTo(0,-(s+2));
    ctx.lineTo(s, s+2);
    ctx.lineTo(-s, s+2);
    ctx.closePath();
    ctx.fill();
    // hit flash overlay
    const nowSec = performance.now()/1000;
    if(p.hitFlashUntil && p.hitFlashUntil > nowSec){
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.fill();
    }
    // shield outline when active (circular indicator)
    if(p.shieldUntil && p.shieldUntil > nowSec){
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(100,200,255,0.9)';
      ctx.beginPath();
      ctx.arc(0,0, Math.max(12, Math.floor(14*SHIP_SCALE)), 0, Math.PI*2);
      ctx.stroke();
    }
    if(p.thrust>0){
      ctx.fillStyle='orange';
      ctx.beginPath();
      ctx.moveTo(-Math.max(3,Math.floor(4*SHIP_SCALE)), s+2);
      ctx.lineTo(0,s+2+Math.random()*6*SHIP_SCALE);
      ctx.lineTo(Math.max(3,Math.floor(4*SHIP_SCALE)), s+2);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // cooldown arc removed per request
  }

  ctx.fillStyle='#fff';
  ctx.font='14px monospace';
  const timerText = intermissionTimer ? `Next round in ${Math.max(0, Math.ceil(intermissionLeft))}s` : `Time left: ${Math.ceil(timeLeft)}s`;
  ctx.fillText(timerText,10,20);
  // overlay final message if needed
  drawGameMessage();
}

// step
function step(dt){
  if(!roundRunning) return;
  timeLeft -= dt;
  if(timeLeft<=0){
    roundRunning=false;
    // compute winner(s)
    let maxScore = -1; const winners=[];
    for(const r of Object.keys(scores)){
      if(!activeRoles.includes(r)) continue;
      const sc = scores[r] || 0;
      if(sc > maxScore){ maxScore = sc; winners.length=0; winners.push(r); }
      else if(sc === maxScore) winners.push(r);
    }
    if(maxScore <= 0){
      gameMessage = "Time's up! No score.";
      showWinnerSplash(null, { label: 'No score', background:'#e6e6e6', textColor:'#111', duration:2200 });
    }
    else if(winners.length===1){
      const winner = winners[0];
      const label = `${winner.charAt(0).toUpperCase() + winner.slice(1)} wins!`;
      gameMessage = `Time's up! Winner: ${winner.toUpperCase()} (${maxScore})`;
      showWinnerSplash(winner, { label, duration:4000 });
    }
    else {
      const tieLabel = `Tie: ${winners.map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(', ')}`;
      gameMessage = `Time's up! Tie: ${winners.map(w=>w.toUpperCase()).join(', ')} (${maxScore})`;
      showWinnerSplash(null, { label: tieLabel, background:'#f7f7f7', textColor:'#111', duration:4000 });
    }
    appendLog(gameMessage);
    // Auto-restart in 5s with lightweight countdown (no extra UI controls)
    if(newRoundBtn) newRoundBtn.style.display='none';
    intermissionLeft = 5;
    if(intermissionTimer) { clearInterval(intermissionTimer); intermissionTimer=null; }
    intermissionTimer = setInterval(()=>{
      intermissionLeft -= 1;
      if(intermissionLeft <= 0){
        clearInterval(intermissionTimer); intermissionTimer=null;
        resetGame('Auto new round');
      }
    }, 1000);
  }

  // update players
  for(const role of activeRoles){
    const p=players[role];

    // rotate
    p.angle += p.rotSpeed * dt;

    // thrust
    const thrustX = Math.sin(p.angle) * p.thrust * 200;
    const thrustY = -Math.cos(p.angle) * p.thrust * 200;
    p.vx += thrustX * dt;
    p.vy += thrustY * dt;

    // move
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    // limit to rectangular arena with bounce
    const pad = Math.max(8, Math.floor(10 * SHIP_SCALE));
    const minX = pad, maxX = canvas.width - pad;
    const minY = pad, maxY = canvas.height - pad;
    if(p.x < minX){ p.x = minX; p.vx = Math.abs(p.vx) * 0.6; }
    if(p.x > maxX){ p.x = maxX; p.vx = -Math.abs(p.vx) * 0.6; }
    if(p.y < minY){ p.y = minY; p.vy = Math.abs(p.vy) * 0.6; }
    if(p.y > maxY){ p.y = maxY; p.vy = -Math.abs(p.vy) * 0.6; }

    // friction
    p.vx *= 0.995; p.vy *= 0.995;

    // clamp speed with optional speed powerup boost
    const maxSpeed = (MAX_SPEED_BASE * (canvas.width/700)) * (p.speedUntil && (performance.now()/1000) < p.speedUntil ? 1.35 : 1.0);
    const sp = Math.hypot(p.vx, p.vy);
    if(sp > maxSpeed){ const k = maxSpeed / sp; p.vx *= k; p.vy *= k; }

    // shooting
      p.cooldown -= dt;
      const baseFireInterval = 1.0; // seconds between shots at normal rate
      const interval = baseFireInterval / (p.fireMultiplier || 1);
      p.lastFireInterval = interval;
      if(p.cooldown<=0){
        bullets.push({
          x: p.x + Math.sin(p.angle)*12,
          y: p.y - Math.cos(p.angle)*12,
          vx: Math.sin(p.angle)*300 + p.vx,
          vy: -Math.cos(p.angle)*300 + p.vy,
          color: colors[role],
          owner: role,
          life: 2
        });
        p.cooldown = interval;
      }
  }

  // build spatial hash of players for bullet collision queries
  const hash = makeSpatialHash(64);
  for(const role of activeRoles){ const p = players[role]; if(p) hash.add({role, x:p.x, y:p.y}); }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x += b.vx*dt;
    b.y += b.vy*dt;
    b.life -= dt;
    if(b.life<=0){bullets.splice(i,1);continue;}

    // despawn bullets at arena edges (no ricochet)
    if(b.x <= 1 || b.x >= canvas.width-1 || b.y <= 1 || b.y >= canvas.height-1){ bullets.splice(i,1); continue; }

    // collisions (skip owner and invulnerable/shielded targets)
    const candidates = hash.queryNeighbors({x:b.x,y:b.y});
    for(const cand of candidates){
      const role = cand.role;
      if(role===b.owner) continue;
      const p=players[role];
      const nowSec = performance.now()/1000;
      if(!p) continue;
      if(p.invulUntil && p.invulUntil > nowSec) continue;
      const shieldActive = p.shieldUntil && p.shieldUntil > nowSec;
      const dx=b.x-p.x, dy=b.y-p.y;
        // scale hit radius with ship size
        // reduce hit radius to match smaller ships (2/3 size)
        const hitR = Math.max(8, Math.floor(12 * SHIP_SCALE * (2/3))); // px
        if(dx*dx+dy*dy < (hitR * hitR)){
        if(!shieldActive){
          scores[b.owner]++;
          const span = scoreSpans[b.owner]; if(span) span.textContent = scores[b.owner];
        }
        // hit feedback and knockback on target
        p.hitFlashUntil = nowSec + HIT_FLASH_DURATION;
        const knock = 60; // px/s impulse
        const mag = Math.hypot(b.vx, b.vy) || 1;
        p.vx += (b.vx/mag) * knock;
        p.vy += (b.vy/mag) * knock;
        bullets.splice(i,1);
        break;
      }
    }
  }

  // powerup timer: spawn occasionally within rectangular arena
  if(powerup==null){
    _powerupTimer -= dt;
    if(_powerupTimer <= 0){
      // spawn at random location within arena bounds with margin
      const margin = 40;
      const px = margin + Math.random() * (canvas.width - margin*2);
      const py = margin + Math.random() * (canvas.height - margin*2);
      // choose powerup kind
      const kinds = ['rapid','shield','speed'];
      const kind = kinds[Math.floor(Math.random()*kinds.length)];
      powerup = { x: px, y: py, kind };
      // reset spawn timer
      _powerupTimer = POWERUP_SPAWN_INTERVAL + Math.random()*6;
    }
  } else {
    // no expiry: wait until picked up
    for(const role of activeRoles){
      const p = players[role];
      const dx = p.x - powerup.x, dy = p.y - powerup.y;
      const pickupR = Math.max(20, 30 * SHIP_SCALE);
      if(dx*dx+dy*dy < (pickupR * pickupR)){
        const nowSec = performance.now()/1000;
        if(powerup.kind === 'rapid'){
          p.fireMultiplier = 2;
          p.powerupUntil = nowSec + 5.0;
        } else if(powerup.kind === 'shield'){
          p.shieldUntil = nowSec + 6.0;
        } else if(powerup.kind === 'speed'){
          p.speedUntil = nowSec + 6.0;
        }
        powerup = null;
        appendLog(`${role} picked up Rapid Fire!`);
        break;
      }
    }
  }

  // expire player powerups
  const nowSec = performance.now()/1000;
  for(const role of activeRoles){
    const p = players[role];
    if(p.powerupUntil && p.powerupUntil <= nowSec){ p.fireMultiplier = 1; p.powerupUntil = 0; }
  }
}

// draw game messages when present
function drawGameMessage(){
  if(!gameMessage) return;
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(canvas.width/2 - 220, canvas.height/2 - 40, 440, 80);
  ctx.fillStyle='#fff'; ctx.font='20px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
  ctx.restore();
}

// input
function handleTilt(role,beta,gamma){
  const p=players[role]; if(!p||!roundRunning)return;

  // Forward/back (beta) = thrust
  // invert: tilting up increases thrust
  // apply deadzone and cubic easing for precision
  const DEAD = 4; // degrees
  let t = (Math.abs(beta) < DEAD) ? 0 : (beta / 35);
  t = Math.max(0, Math.min(1, t));
  const thrustVal = t * t * t; // cubic ease-in
  p.thrust = thrustVal;

  // Left/right (gamma) = rotation speed
  // make rotation less sensitive: divide gamma by a larger factor
  const rotVal = Math.max(-1, Math.min(1, gamma/70));
  // reduce turning at high thrust for better control
  const turnScale = 1 - 0.4 * p.thrust; // 60% at max thrust
  p.rotSpeed = rotVal * 2.2 * turnScale; // radians per sec
}

// simple spatial hash for players to speed up bullet collision checks
function makeSpatialHash(cellSize){
  return {
    cellSize,
    map: new Map(),
    clear(){ this.map.clear(); },
    key(x,y){ return `${x},${y}`; },
    add(obj){
      const cx = Math.floor(obj.x / this.cellSize);
      const cy = Math.floor(obj.y / this.cellSize);
      const k = `${cx},${cy}`;
      if(!this.map.has(k)) this.map.set(k, []);
      this.map.get(k).push(obj);
    },
    queryNeighbors(obj){
      const cx = Math.floor(obj.x / this.cellSize);
      const cy = Math.floor(obj.y / this.cellSize);
      let neighbors = [];
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          const k = `${cx+dx},${cy+dy}`;
          if(this.map.has(k)) neighbors = neighbors.concat(this.map.get(k));
        }
      }
      return neighbors;
    }
  };
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
const ROOM_ID = getRoomId();

// unified room badge helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// websocket
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token=data.token;
  const proto=(location.protocol==='https:')?'wss':'ws';
  const wsUrl=data.ws_url?(data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token)+'&room='+ROOM_ID:data.ws_url+'?token='+encodeURIComponent(token)+'&room='+ROOM_ID):`${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  ws=new WebSocket(wsUrl);
  ws.onopen=()=>{
    appendLog('Connected');
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected — Room: ${ROOM_ID}`);
    ws.send(JSON.stringify({type:'request-meta', room:ROOM_ID}));
    ws.send(JSON.stringify({type:'room-meta', room:ROOM_ID, meta:{playerCount}}));
  };
  ws.onmessage=(ev)=>{
    try{
      const d=JSON.parse(ev.data);
      if(!d) return;
      if(d.type==='room-meta' && (!d.room || String(d.room).toUpperCase()===ROOM_ID)){
        if(d.meta && d.meta.playerCount!==undefined) applyPlayerCountFromMeta(d.meta.playerCount);
        return;
      }
      if(d.type==='request-meta' && (!d.room || String(d.room).toUpperCase()===ROOM_ID)){
        ws.send(JSON.stringify({type:'room-meta', room:ROOM_ID, meta:{playerCount}}));
        return;
      }
      if(d.type==='batch' && d.meta && d.meta.playerCount!==undefined){
        applyPlayerCountFromMeta(d.meta.playerCount);
      }
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || !playerMsg.role) continue;
          if(playerMsg.room && String(playerMsg.room).toUpperCase() !== ROOM_ID) continue;
          if(!activeRoles.includes(playerMsg.role)) continue;
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined){
            handleTilt(playerMsg.role,playerMsg.orientBeta,playerMsg.orientGamma);
          }else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            handleTilt(playerMsg.role,playerMsg.beta,playerMsg.gamma);
          }
        }
      }
    }catch(e){}
  };
  ws.onclose=()=>{appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000);};
}).catch(e=>{appendLog('No backend /api/token');});

let last=performance.now();
function frame(now){
  const dt=Math.min(40,now-last)/1000; last=now;
  step(dt);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

if(newRoundBtn){
  newRoundBtn.addEventListener('click', ()=>{
    resetGame('New round');
  });
}
</script>
</body>
</html>
