<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blasters</title>
<style>
  html,body{height:100%;margin:0;padding:0}
  body {
    font-family:'Segoe UI',Arial,Helvetica,sans-serif;
    background:#000;
    color:#eee;
    overflow:hidden;
  }
  canvas {
    position:fixed;
    top:0; left:0;
    width:100%; height:100%;
    background:radial-gradient(ellipse at center, #0d1224 0%, #060a15 50%, #000000 100%);
  }
  h1{display:none}
  /* Glass HUD */
  .hud{position:fixed;top:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;align-items:center;z-index:1000;background:rgba(0,0,0,0.6);padding:12px 20px;border-radius:16px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);box-shadow:0 8px 32px rgba(0,0,0,0.4)}
  .role{padding:8px 14px;border-radius:10px;background:rgba(255,255,255,0.08);font-weight:600;font-size:14px;transition:all 0.3s ease;border:1px solid rgba(255,255,255,0.1);text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  .role:hover{background:rgba(255,255,255,0.12);transform:translateY(-2px)}
  button{background:rgba(255,255,255,0.15);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:8px 16px;border-radius:10px;font-weight:600;cursor:pointer;transition:all 0.3s ease;font-size:14px;text-shadow:0 2px 4px rgba(0,0,0,0.5)}
  button:hover{background:rgba(255,255,255,0.25);transform:translateY(-2px);box-shadow:0 4px 12px rgba(255,255,255,0.2)}
</style>
</head>
<body>
  <h1>Blasters</h1>

  <div class="hud">
    <div class="role" id="blueScoreContainer">Blue <span id="sBlue">0</span></div>
    <div class="role" id="redScoreContainer">Red <span id="sRed">0</span></div>
    <div class="role" id="yellowScoreContainer" style="display:none">Yellow <span id="sYellow">0</span></div>
    <div class="role" id="greenScoreContainer" style="display:none">Green <span id="sGreen">0</span></div>
    <div class="role" id="orangeScoreContainer" style="display:none">Orange <span id="sOrange">0</span></div>
    <div class="role" id="purpleScoreContainer" style="display:none">Purple <span id="sPurple">0</span></div>
    <div class="role" id="cyanScoreContainer" style="display:none">Cyan <span id="sCyan">0</span></div>
    <div class="role" id="magentaScoreContainer" style="display:none">Magenta <span id="sMagenta">0</span></div>
    <button id="newRound" style="display:none">New round</button>
  </div>

  <canvas id="c" width="700" height="600"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// runtime-safe logger: attempts to write to #info if present, otherwise falls back to console
function appendLog(msg){
  try{
    const el = document.getElementById('info');
    if(el) el.textContent = msg;
    else console.log(msg);
  }catch(e){ console.log(msg); }
}
// Read player count from URL parameter
function getPlayerCountFromUrl() {
  const params = new URLSearchParams(window.location.search);
  return Math.max(2, Math.min(8, parseInt(params.get('players') || '2', 10)));
}
let playerCount = getPlayerCountFromUrl();
function applyPlayerCountFromMeta(newCount){
  const clamped = Math.max(2, Math.min(8, parseInt(newCount || playerCount, 10)));
  if(Number.isNaN(clamped) || clamped === playerCount) return;
  playerCount = clamped;
  const params = new URLSearchParams(window.location.search);
  params.set('players', String(playerCount));
  const qs = params.toString();
  window.history.replaceState({}, '', `${window.location.pathname}?${qs}`);
  resetGame('Player count updated');
}
const yellowScoreContainer = document.getElementById('yellowScoreContainer');
const greenScoreContainer = document.getElementById('greenScoreContainer');
const sBlue = document.getElementById('sBlue');
const sRed = document.getElementById('sRed');
const sYellow = document.getElementById('sYellow');
const sGreen = document.getElementById('sGreen');
const sOrange = document.getElementById('sOrange');
const sPurple = document.getElementById('sPurple');
const sCyan = document.getElementById('sCyan');
const sMagenta = document.getElementById('sMagenta');

const colors = {blue:'#4ea1ff', red:'#ff6b6b', yellow:'#ffd86b', green:'#8fe58f', orange:'#ff9f4d', purple:'#b58cff', cyan:'#4de6e6', magenta:'#ff6bff'};
let ws=null;
let activeRoles = ['blue','red'];
let scores = {blue:0,red:0,yellow:0,green:0,orange:0,purple:0,cyan:0,magenta:0};

// map for convenient score span updates
const scoreSpans = { blue: sBlue, red: sRed, yellow: sYellow, green: sGreen, orange: sOrange, purple: sPurple, cyan: sCyan, magenta: sMagenta };
let players = {};
let bullets = [];
let timeLeft = 60;
let roundRunning = true;
let intermissionTimer = null; // auto-restart timer handle
let intermissionLeft = 0; // seconds until next round
// powerup state
let powerup = null; // {x,y,kind:'rapid'|'shield'|'speed'}
const POWERUP_SPAWN_INTERVAL = 8.0; // seconds between spawn attempts
let _powerupTimer = 4.0; // seed first spawn shortly

// Square playfield without blackhole; ships move within rectangular bounds
let CENTER_X = canvas.width/2, CENTER_Y = canvas.height/2;
let SPAWN_RADIUS = Math.floor(Math.min(canvas.width, canvas.height) * 0.42);
// visual scaling: ship size and layout should adapt to canvas size
let SHIP_SCALE = 2.0;
// movement & gameplay constants
const MAX_SPEED_BASE = 320; // px/s at SHIP_SCALE=1 on width~700
const INVULN_DURATION = 2.0; // seconds of spawn protection
const HIT_FLASH_DURATION = 0.15; // seconds
const BULLET_MAX_BOUNCES = 2;

function resizeCanvasToDisplay(){
  const oldCenter = {x:CENTER_X, y:CENTER_Y};
  const oldSpawn = SPAWN_RADIUS || 1;
  const w = window.innerWidth;
  const h = window.innerHeight;
  const size = Math.min(w,h);
  canvas.width = w;
  canvas.height = h;
  CENTER_X = canvas.width/2; CENTER_Y = canvas.height/2;
  SPAWN_RADIUS = Math.floor(size * 0.38);
  SHIP_SCALE = Math.max(1.2, (size/700) * 1.6);
  // reposition players relative to new center
  for(const role of Object.keys(players)){
    const p = players[role];
    const ang = p.angle - Math.PI/2;
    // keep their angular slot, adjust radius proportionally
    const dist = Math.hypot(p.x - oldCenter.x, p.y - oldCenter.y);
    const scaledDist = dist * (SPAWN_RADIUS/oldSpawn);
    p.x = CENTER_X + Math.cos(ang) * scaledDist;
    p.y = CENTER_Y + Math.sin(ang) * scaledDist;
  }
}

window.addEventListener('resize', resizeCanvasToDisplay);
resizeCanvasToDisplay();

// Winner splash overlay (similar to paint)
const winOverlay = document.createElement('div');
winOverlay.style.position = 'fixed';
winOverlay.style.left = '0';
winOverlay.style.top = '0';
winOverlay.style.width = '100%';
winOverlay.style.height = '100%';
winOverlay.style.display = 'none';
winOverlay.style.alignItems = 'center';
winOverlay.style.justifyContent = 'center';
winOverlay.style.zIndex = 10001;
winOverlay.style.color = '#001';
winOverlay.style.fontFamily = 'Arial, Helvetica, sans-serif';
winOverlay.style.fontSize = '52px';
winOverlay.style.fontWeight = '800';
winOverlay.style.pointerEvents = 'none';
winOverlay.style.textShadow = '0 1px 0 rgba(255,255,255,0.6)';
document.body.appendChild(winOverlay);

function showWinnerSplash(role, opts={}){
  const bg = opts.background || colors[role] || '#000';
  winOverlay.style.background = bg;
  // pick readable text color based on luminance unless overridden
  let hex = (bg.replace('#',''));
  let r=0,g=0,b=0;
  try{ r = parseInt(hex.substring(0,2),16); g = parseInt(hex.substring(2,4),16); b = parseInt(hex.substring(4,6),16); }catch(e){}
  const lum = 0.2126*r + 0.7152*g + 0.0722*b;
  winOverlay.style.color = opts.textColor || ((lum > 170) ? '#001' : '#fff');
  const base = role ? role.charAt(0).toUpperCase() + role.slice(1) : 'Winner';
  const label = opts.label || `${base} wins!`;
  winOverlay.textContent = label;
  winOverlay.style.display = 'flex';
  if(winOverlay._hideTimeout){ clearTimeout(winOverlay._hideTimeout); }
  const duration = opts.duration || 3000;
  winOverlay._hideTimeout = setTimeout(()=>{ winOverlay.style.display = 'none'; }, duration);
}
// expose helper for future winner triggers
window.__showWinnerSplash = showWinnerSplash;

// init players
function initPlayers(){
  const n = playerCount;
  const possible = ['blue','red','yellow','green','orange','purple','cyan','magenta'];
  activeRoles = possible.slice(0, n);

  players={};
  bullets=[];
  const angleStep = (Math.PI*2)/n;
  const spawnR = SPAWN_RADIUS;
  for(let i=0;i<n;i++){
    const role = activeRoles[i];
    const angle = i*angleStep;
    players[role] = {
      x: CENTER_X + Math.cos(angle)*spawnR,
      y: CENTER_Y + Math.sin(angle)*spawnR,
      vx: 0, vy: 0,
      angle: angle + Math.PI/2,
      rotSpeed: 0,
      thrust: 0,
      cooldown: 0,
      fireMultiplier: 1,
      powerupUntil: 0,
      shieldUntil: 0,
      speedUntil: 0,
      invulUntil: performance.now()/1000 + INVULN_DURATION,
      hitFlashUntil: 0,
      lastFireInterval: 1.0,
      health: 100,
      maxHealth: 100
    };
  }
  timeLeft = 60;
  roundRunning = true;
  // Color HUD labels and numeric spans for quick scanning
  const containers = {
    blue: document.getElementById('blueScoreContainer'),
    red: document.getElementById('redScoreContainer'),
    yellow: document.getElementById('yellowScoreContainer'),
    green: document.getElementById('greenScoreContainer'),
    orange: document.getElementById('orangeScoreContainer'),
    purple: document.getElementById('purpleScoreContainer'),
    cyan: document.getElementById('cyanScoreContainer'),
    magenta: document.getElementById('magentaScoreContainer')
  };
  const spans = { blue: sBlue, red: sRed, yellow: sYellow, green: sGreen, orange: sOrange, purple: sPurple, cyan: sCyan, magenta: sMagenta };
  for(const role of Object.keys(containers)){
    const c = containers[role];
    if(c && activeRoles.includes(role)){
      c.style.display = '';
      c.style.color = colors[role];
      if(spans[role]) spans[role].style.color = colors[role];
    } else if(c){
      c.style.display = 'none';
    }
  }
}
initPlayers();
const newRoundBtn = document.getElementById('newRound');
let gameMessage = '';

function resetGame(reason){
  gameMessage = '';
  bullets = [];
  powerup = null;
  // Note: scores persist across rounds
  if(newRoundBtn) newRoundBtn.style.display='none';
  if(winOverlay){
    winOverlay.style.display='none';
    if(winOverlay._hideTimeout) clearTimeout(winOverlay._hideTimeout);
  }
  if(reason) appendLog(reason);
  if(intermissionTimer){ clearInterval(intermissionTimer); intermissionTimer = null; }
  initPlayers();
}

// draw
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // optional subtle border to emphasize square arena
  ctx.strokeStyle='rgba(255,255,255,0.15)';
  ctx.lineWidth = 2;
  ctx.strokeRect(1,1,canvas.width-2,canvas.height-2);

  // bullets
  for(const b of bullets){
    ctx.fillStyle=b.color;
    ctx.beginPath();
    const br = Math.max(2, Math.floor(3 * SHIP_SCALE));
    ctx.arc(b.x,b.y,br,0,Math.PI*2);
    ctx.fill();
  }

  // powerup
  if(powerup){
    ctx.save();
    ctx.beginPath();
    // color/icon by kind
    const pcol = powerup.kind==='shield' ? '#7fd3ff' : powerup.kind==='speed' ? '#8fff9c' : '#ffe066';
    ctx.fillStyle = pcol;
    ctx.arc(powerup.x, powerup.y, 10, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle='#fff'; ctx.stroke();
    ctx.fillStyle='#001'; ctx.font='12px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const label = powerup.kind==='shield' ? 'SH' : powerup.kind==='speed' ? 'SPD' : 'x2';
    ctx.fillText(label, powerup.x, powerup.y);
    ctx.restore();
  }

  // health bars in HUD
  ctx.save();
  const barW = 80, barH = 8;
  let barX = 10, barY = 40;
  for(const role of activeRoles){
    const p = players[role];
    // background
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(barX, barY, barW, barH);
    // health - always keep role color
    const healthPct = Math.max(0, p.health / p.maxHealth);
    ctx.fillStyle = colors[role];
    ctx.fillRect(barX, barY, barW * healthPct, barH);
    // border
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barW, barH);
    // label
    ctx.fillStyle = colors[role];
    ctx.font = '10px monospace';
    ctx.fillText(role.charAt(0).toUpperCase(), barX - 12, barY + 7);
    barY += barH + 4;
  }
  ctx.restore();

  // ships
  for(const role of activeRoles){
    const p = players[role];
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(p.angle);
    ctx.fillStyle=colors[role];
    // ship shape scaled by SHIP_SCALE
    const s = Math.max(1, Math.floor(10 * SHIP_SCALE));
    ctx.beginPath();
    ctx.moveTo(0,-(s+2));
    ctx.lineTo(s, s+2);
    ctx.lineTo(-s, s+2);
    ctx.closePath();
    ctx.fill();
    // hit flash overlay
    const nowSec = performance.now()/1000;
    if(p.hitFlashUntil && p.hitFlashUntil > nowSec){
      ctx.fillStyle='rgba(255,255,255,0.8)';
      ctx.fill();
    }
    // shield outline when active (circular indicator)
    if(p.shieldUntil && p.shieldUntil > nowSec){
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(100,200,255,0.9)';
      ctx.beginPath();
      ctx.arc(0,0, Math.max(12, Math.floor(14*SHIP_SCALE)), 0, Math.PI*2);
      ctx.stroke();
    }
    if(p.thrust>0){
      ctx.fillStyle='orange';
      ctx.beginPath();
      ctx.moveTo(-Math.max(3,Math.floor(4*SHIP_SCALE)), s+2);
      ctx.lineTo(0,s+2+Math.random()*6*SHIP_SCALE);
      ctx.lineTo(Math.max(3,Math.floor(4*SHIP_SCALE)), s+2);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();

    // cooldown arc removed per request
  }

  ctx.fillStyle='#fff';
  ctx.font='14px monospace';
  const timerText = intermissionTimer ? `Next round in ${Math.max(0, Math.ceil(intermissionLeft))}s` : `Time left: ${Math.ceil(timeLeft)}s`;
  ctx.fillText(timerText,10,20);
  // overlay final message if needed
  drawGameMessage();
}

// step
function step(dt){
  if(!roundRunning) return;
  timeLeft -= dt;
  if(timeLeft<=0){
    roundRunning=false;
    // compute winner(s)
    let maxScore = -1; const winners=[];
    for(const r of Object.keys(scores)){
      if(!activeRoles.includes(r)) continue;
      const sc = scores[r] || 0;
      if(sc > maxScore){ maxScore = sc; winners.length=0; winners.push(r); }
      else if(sc === maxScore) winners.push(r);
    }
    if(maxScore <= 0){
      gameMessage = "Time's up! No score.";
      showWinnerSplash(null, { label: 'No score', background:'#e6e6e6', textColor:'#111', duration:2200 });
    }
    else if(winners.length===1){
      const winner = winners[0];
      const label = `${winner.charAt(0).toUpperCase() + winner.slice(1)} wins!`;
      gameMessage = `Time's up! Winner: ${winner.toUpperCase()} (${maxScore})`;
      showWinnerSplash(winner, { label, duration:4000 });
    }
    else {
      const tieLabel = `Tie: ${winners.map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(', ')}`;
      gameMessage = `Time's up! Tie: ${winners.map(w=>w.toUpperCase()).join(', ')} (${maxScore})`;
      showWinnerSplash(null, { label: tieLabel, background:'#f7f7f7', textColor:'#111', duration:4000 });
    }
    appendLog(gameMessage);
    // Auto-restart in 5s with lightweight countdown (no extra UI controls)
    if(newRoundBtn) newRoundBtn.style.display='none';
    intermissionLeft = 5;
    if(intermissionTimer) { clearInterval(intermissionTimer); intermissionTimer=null; }
    intermissionTimer = setInterval(()=>{
      intermissionLeft -= 1;
      if(intermissionLeft <= 0){
        clearInterval(intermissionTimer); intermissionTimer=null;
        resetGame('Auto new round');
      }
    }, 1000);
  }

  // update players
  for(const role of activeRoles){
    const p=players[role];

    // rotate
    p.angle += p.rotSpeed * dt;

    // thrust
    const thrustX = Math.sin(p.angle) * p.thrust * 200;
    const thrustY = -Math.cos(p.angle) * p.thrust * 200;
    p.vx += thrustX * dt;
    p.vy += thrustY * dt;

    // move
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    // limit to rectangular arena with bounce
    const pad = Math.max(8, Math.floor(10 * SHIP_SCALE));
    const minX = pad, maxX = canvas.width - pad;
    const minY = pad, maxY = canvas.height - pad;
    if(p.x < minX){ p.x = minX; p.vx = Math.abs(p.vx) * 0.6; }
    if(p.x > maxX){ p.x = maxX; p.vx = -Math.abs(p.vx) * 0.6; }
    if(p.y < minY){ p.y = minY; p.vy = Math.abs(p.vy) * 0.6; }
    if(p.y > maxY){ p.y = maxY; p.vy = -Math.abs(p.vy) * 0.6; }

    // friction
    p.vx *= 0.995; p.vy *= 0.995;

    // clamp speed with optional speed powerup boost
    const maxSpeed = (MAX_SPEED_BASE * (canvas.width/700)) * (p.speedUntil && (performance.now()/1000) < p.speedUntil ? 1.35 : 1.0);
    const sp = Math.hypot(p.vx, p.vy);
    if(sp > maxSpeed){ const k = maxSpeed / sp; p.vx *= k; p.vy *= k; }

    // shooting
      p.cooldown -= dt;
      const baseFireInterval = 1.0; // seconds between shots at normal rate
      const interval = baseFireInterval / (p.fireMultiplier || 1);
      p.lastFireInterval = interval;
      if(p.cooldown<=0){
        bullets.push({
          x: p.x + Math.sin(p.angle)*12,
          y: p.y - Math.cos(p.angle)*12,
          vx: Math.sin(p.angle)*300 + p.vx,
          vy: -Math.cos(p.angle)*300 + p.vy,
          color: colors[role],
          owner: role,
          life: 2
        });
        p.cooldown = interval;
      }
  }

  // build spatial hash of players for bullet collision queries
  const hash = makeSpatialHash(64);
  for(const role of activeRoles){ const p = players[role]; if(p) hash.add({role, x:p.x, y:p.y}); }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x += b.vx*dt;
    b.y += b.vy*dt;
    b.life -= dt;
    if(b.life<=0){bullets.splice(i,1);continue;}

    // despawn bullets at arena edges (no ricochet)
    if(b.x <= 1 || b.x >= canvas.width-1 || b.y <= 1 || b.y >= canvas.height-1){ bullets.splice(i,1); continue; }

    // collisions (skip owner and invulnerable/shielded targets)
    const candidates = hash.queryNeighbors({x:b.x,y:b.y});
    for(const cand of candidates){
      const role = cand.role;
      if(role===b.owner) continue;
      const p=players[role];
      const nowSec = performance.now()/1000;
      if(!p) continue;
      if(p.invulUntil && p.invulUntil > nowSec) continue;
      const shieldActive = p.shieldUntil && p.shieldUntil > nowSec;
      const dx=b.x-p.x, dy=b.y-p.y;
        // scale hit radius with ship size
        const hitR = Math.max(10, Math.floor(16 * SHIP_SCALE)); // px
        if(dx*dx+dy*dy < (hitR * hitR)){
        if(!shieldActive){
          p.health -= 25; // 4 hits to kill
          if(p.health <= 0){
            p.health = 0;
            // give kill point
            scores[b.owner]++;
            const span = scoreSpans[b.owner]; if(span) span.textContent = scores[b.owner];
            // respawn after 2 seconds
            const respawnRole = role;
            setTimeout(() => {
              const rp = players[respawnRole];
              if(rp) {
                // respawn at original spawn position
                const idx = activeRoles.indexOf(respawnRole);
                const angleStep = (Math.PI*2)/activeRoles.length;
                const angle = idx * angleStep;
                rp.x = CENTER_X + Math.cos(angle) * SPAWN_RADIUS;
                rp.y = CENTER_Y + Math.sin(angle) * SPAWN_RADIUS;
                rp.vx = 0; rp.vy = 0;
                rp.health = rp.maxHealth;
                rp.invulUntil = performance.now()/1000 + INVULN_DURATION;
              }
            }, 2000);
          }
        }
        // hit feedback and knockback on target
        p.hitFlashUntil = nowSec + HIT_FLASH_DURATION;
        const knock = 80; // px/s impulse
        const mag = Math.hypot(b.vx, b.vy) || 1;
        p.vx += (b.vx/mag) * knock;
        p.vy += (b.vy/mag) * knock;
        bullets.splice(i,1);
        break;
      }
    }
  }

  // powerup timer: spawn occasionally within rectangular arena
  if(powerup==null){
    _powerupTimer -= dt;
    if(_powerupTimer <= 0){
      // spawn at random location within arena bounds with margin
      const margin = 40;
      const px = margin + Math.random() * (canvas.width - margin*2);
      const py = margin + Math.random() * (canvas.height - margin*2);
      // choose powerup kind
      const kinds = ['rapid','shield','speed'];
      const kind = kinds[Math.floor(Math.random()*kinds.length)];
      powerup = { x: px, y: py, kind };
      // reset spawn timer
      _powerupTimer = POWERUP_SPAWN_INTERVAL + Math.random()*6;
    }
  } else {
    // no expiry: wait until picked up
    for(const role of activeRoles){
      const p = players[role];
      const dx = p.x - powerup.x, dy = p.y - powerup.y;
      const pickupR = Math.max(20, 30 * SHIP_SCALE);
      if(dx*dx+dy*dy < (pickupR * pickupR)){
        const nowSec = performance.now()/1000;
        if(powerup.kind === 'rapid'){
          p.fireMultiplier = 2;
          p.powerupUntil = nowSec + 5.0;
        } else if(powerup.kind === 'shield'){
          p.shieldUntil = nowSec + 6.0;
        } else if(powerup.kind === 'speed'){
          p.speedUntil = nowSec + 6.0;
        }
        powerup = null;
        appendLog(`${role} picked up Rapid Fire!`);
        break;
      }
    }
  }

  // expire player powerups
  const nowSec = performance.now()/1000;
  for(const role of activeRoles){
    const p = players[role];
    if(p.powerupUntil && p.powerupUntil <= nowSec){ p.fireMultiplier = 1; p.powerupUntil = 0; }
  }
}

// draw game messages when present
function drawGameMessage(){
  if(!gameMessage) return;
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(canvas.width/2 - 220, canvas.height/2 - 40, 440, 80);
  ctx.fillStyle='#fff'; ctx.font='20px monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
  ctx.restore();
}

// input
function handleTilt(role,beta,gamma){
  const p=players[role]; if(!p||!roundRunning)return;

  // Forward/back (beta) = thrust
  // invert: tilting up increases thrust
  // apply deadzone and cubic easing for precision
  const DEAD = 4; // degrees
  let t = (Math.abs(beta) < DEAD) ? 0 : (beta / 35);
  t = Math.max(0, Math.min(1, t));
  const thrustVal = t * t * t; // cubic ease-in
  p.thrust = thrustVal;

  // Left/right (gamma) = rotation speed
  // make rotation less sensitive: divide gamma by a larger factor
  const rotVal = Math.max(-1, Math.min(1, gamma/90));
  // reduce turning at high thrust for better control (less penalty)
  const turnScale = 1 - 0.2 * p.thrust; // 80% at max thrust
  p.rotSpeed = rotVal * 1.8 * turnScale; // radians per sec
}

// simple spatial hash for players to speed up bullet collision checks
function makeSpatialHash(cellSize){
  return {
    cellSize,
    map: new Map(),
    clear(){ this.map.clear(); },
    key(x,y){ return `${x},${y}`; },
    add(obj){
      const cx = Math.floor(obj.x / this.cellSize);
      const cy = Math.floor(obj.y / this.cellSize);
      const k = `${cx},${cy}`;
      if(!this.map.has(k)) this.map.set(k, []);
      this.map.get(k).push(obj);
    },
    queryNeighbors(obj){
      const cx = Math.floor(obj.x / this.cellSize);
      const cy = Math.floor(obj.y / this.cellSize);
      let neighbors = [];
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          const k = `${cx+dx},${cy+dy}`;
          if(this.map.has(k)) neighbors = neighbors.concat(this.map.get(k));
        }
      }
      return neighbors;
    }
  };
}

// Room id extraction from URL
function getRoomId() {
  const params = new URLSearchParams(window.location.search);
  let room = params.get('room');
  if(room && /^[A-Z]{3}$/.test(room)) return room.toUpperCase();
  // fallback: generate random room if missing (shouldn't happen from QR)
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let code = '';
  for (let i = 0; i < 3; ++i) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}
const ROOM_ID = getRoomId();

// unified room badge helper
(function(){
  let rb = document.getElementById('roomBadge');
  if(!rb){ rb = document.createElement('div'); rb.id='roomBadge'; rb.style.cssText='position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.6);color:#fff;padding:6px 10px;border-radius:6px;font-weight:700;z-index:10000'; document.body.appendChild(rb); }
  rb.textContent = `Room: ${ROOM_ID}`;
  window.__setRoomBadge = function(s){ if(rb) rb.textContent = s; };
})();

// websocket
fetch('/api/token').then(r=>r.json()).then(data=>{
  const token=data.token;
  const proto=(location.protocol==='https:')?'wss':'ws';
  const wsUrl=data.ws_url?(data.ws_url.includes('?')?data.ws_url+'&token='+encodeURIComponent(token)+'&room='+ROOM_ID:data.ws_url+'?token='+encodeURIComponent(token)+'&room='+ROOM_ID):`${proto}://${location.host}/ws?token=${encodeURIComponent(token)}&room=${ROOM_ID}`;
  ws=new WebSocket(wsUrl);
  ws.onopen=()=>{
    appendLog('Connected');
    if(window.__setRoomBadge) window.__setRoomBadge(`Connected â€” Room: ${ROOM_ID}`);
    ws.send(JSON.stringify({type:'request-meta', room:ROOM_ID}));
    ws.send(JSON.stringify({type:'room-meta', room:ROOM_ID, meta:{playerCount}}));
  };
  ws.onmessage=(ev)=>{
    try{
      const d=JSON.parse(ev.data);
      if(!d) return;
      if(d.type==='room-meta' && (!d.room || String(d.room).toUpperCase()===ROOM_ID)){
        if(d.meta && d.meta.playerCount!==undefined) applyPlayerCountFromMeta(d.meta.playerCount);
        return;
      }
      if(d.type==='request-meta' && (!d.room || String(d.room).toUpperCase()===ROOM_ID)){
        ws.send(JSON.stringify({type:'room-meta', room:ROOM_ID, meta:{playerCount}}));
        return;
      }
      if(d.type==='batch' && d.meta && d.meta.playerCount!==undefined){
        applyPlayerCountFromMeta(d.meta.playerCount);
      }
      
      // Handle batch messages (aggregated state from server)
      if(d.type === 'batch' && Array.isArray(d.players)){
        for(const playerMsg of d.players){
          if(!playerMsg || !playerMsg.role) continue;
          if(playerMsg.room && String(playerMsg.room).toUpperCase() !== ROOM_ID) continue;
          if(!activeRoles.includes(playerMsg.role)) continue;
          if(playerMsg.orientBeta!==undefined && playerMsg.orientGamma!==undefined){
            handleTilt(playerMsg.role,playerMsg.orientBeta,playerMsg.orientGamma);
          }else if(playerMsg.beta!==undefined && playerMsg.gamma!==undefined){
            handleTilt(playerMsg.role,playerMsg.beta,playerMsg.gamma);
          }
        }
      }
    }catch(e){}
  };
  ws.onclose=()=>{appendLog('Disconnected'); if(window.__setRoomBadge) window.__setRoomBadge('Disconnected'); setTimeout(()=>location.reload(),2000);};
}).catch(e=>{appendLog('No backend /api/token');});

let last=performance.now();
function frame(now){
  const dt=Math.min(40,now-last)/1000; last=now;
  step(dt);
  draw();
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

if(newRoundBtn){
  newRoundBtn.addEventListener('click', ()=>{
    resetGame('New round');
  });
}
</script>
</body>
</html>
